// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/google/uuid"
	"github.com/rezible/rezible/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/rezible/rezible/ent/alert"
	"github.com/rezible/rezible/ent/alertmetrics"
	"github.com/rezible/rezible/ent/environment"
	"github.com/rezible/rezible/ent/functionality"
	"github.com/rezible/rezible/ent/incident"
	"github.com/rezible/rezible/ent/incidentdebrief"
	"github.com/rezible/rezible/ent/incidentdebriefmessage"
	"github.com/rezible/rezible/ent/incidentdebriefquestion"
	"github.com/rezible/rezible/ent/incidentdebriefsuggestion"
	"github.com/rezible/rezible/ent/incidentevent"
	"github.com/rezible/rezible/ent/incidenteventcontext"
	"github.com/rezible/rezible/ent/incidenteventcontributingfactor"
	"github.com/rezible/rezible/ent/incidenteventevidence"
	"github.com/rezible/rezible/ent/incidenteventsystemcomponent"
	"github.com/rezible/rezible/ent/incidentfield"
	"github.com/rezible/rezible/ent/incidentfieldoption"
	"github.com/rezible/rezible/ent/incidentlink"
	"github.com/rezible/rezible/ent/incidentmilestone"
	"github.com/rezible/rezible/ent/incidentrole"
	"github.com/rezible/rezible/ent/incidentroleassignment"
	"github.com/rezible/rezible/ent/incidentseverity"
	"github.com/rezible/rezible/ent/incidenttag"
	"github.com/rezible/rezible/ent/incidentteamassignment"
	"github.com/rezible/rezible/ent/incidenttype"
	"github.com/rezible/rezible/ent/meetingschedule"
	"github.com/rezible/rezible/ent/meetingsession"
	"github.com/rezible/rezible/ent/oncallannotation"
	"github.com/rezible/rezible/ent/oncallannotationalertfeedback"
	"github.com/rezible/rezible/ent/oncallevent"
	"github.com/rezible/rezible/ent/oncallhandovertemplate"
	"github.com/rezible/rezible/ent/oncallroster"
	"github.com/rezible/rezible/ent/oncallrostermetrics"
	"github.com/rezible/rezible/ent/oncallschedule"
	"github.com/rezible/rezible/ent/oncallscheduleparticipant"
	"github.com/rezible/rezible/ent/oncallusershift"
	"github.com/rezible/rezible/ent/oncallusershifthandover"
	"github.com/rezible/rezible/ent/oncallusershiftmetrics"
	"github.com/rezible/rezible/ent/playbook"
	"github.com/rezible/rezible/ent/providerconfig"
	"github.com/rezible/rezible/ent/providersynchistory"
	"github.com/rezible/rezible/ent/retrospective"
	"github.com/rezible/rezible/ent/retrospectivediscussion"
	"github.com/rezible/rezible/ent/retrospectivediscussionreply"
	"github.com/rezible/rezible/ent/retrospectivereview"
	"github.com/rezible/rezible/ent/systemanalysis"
	"github.com/rezible/rezible/ent/systemanalysiscomponent"
	"github.com/rezible/rezible/ent/systemanalysisrelationship"
	"github.com/rezible/rezible/ent/systemcomponent"
	"github.com/rezible/rezible/ent/systemcomponentconstraint"
	"github.com/rezible/rezible/ent/systemcomponentcontrol"
	"github.com/rezible/rezible/ent/systemcomponentkind"
	"github.com/rezible/rezible/ent/systemcomponentrelationship"
	"github.com/rezible/rezible/ent/systemcomponentsignal"
	"github.com/rezible/rezible/ent/systemhazard"
	"github.com/rezible/rezible/ent/systemrelationshipcontrolaction"
	"github.com/rezible/rezible/ent/systemrelationshipfeedbacksignal"
	"github.com/rezible/rezible/ent/task"
	"github.com/rezible/rezible/ent/team"
	"github.com/rezible/rezible/ent/tenant"
	"github.com/rezible/rezible/ent/ticket"
	"github.com/rezible/rezible/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Alert is the client for interacting with the Alert builders.
	Alert *AlertClient
	// AlertMetrics is the client for interacting with the AlertMetrics builders.
	AlertMetrics *AlertMetricsClient
	// Environment is the client for interacting with the Environment builders.
	Environment *EnvironmentClient
	// Functionality is the client for interacting with the Functionality builders.
	Functionality *FunctionalityClient
	// Incident is the client for interacting with the Incident builders.
	Incident *IncidentClient
	// IncidentDebrief is the client for interacting with the IncidentDebrief builders.
	IncidentDebrief *IncidentDebriefClient
	// IncidentDebriefMessage is the client for interacting with the IncidentDebriefMessage builders.
	IncidentDebriefMessage *IncidentDebriefMessageClient
	// IncidentDebriefQuestion is the client for interacting with the IncidentDebriefQuestion builders.
	IncidentDebriefQuestion *IncidentDebriefQuestionClient
	// IncidentDebriefSuggestion is the client for interacting with the IncidentDebriefSuggestion builders.
	IncidentDebriefSuggestion *IncidentDebriefSuggestionClient
	// IncidentEvent is the client for interacting with the IncidentEvent builders.
	IncidentEvent *IncidentEventClient
	// IncidentEventContext is the client for interacting with the IncidentEventContext builders.
	IncidentEventContext *IncidentEventContextClient
	// IncidentEventContributingFactor is the client for interacting with the IncidentEventContributingFactor builders.
	IncidentEventContributingFactor *IncidentEventContributingFactorClient
	// IncidentEventEvidence is the client for interacting with the IncidentEventEvidence builders.
	IncidentEventEvidence *IncidentEventEvidenceClient
	// IncidentEventSystemComponent is the client for interacting with the IncidentEventSystemComponent builders.
	IncidentEventSystemComponent *IncidentEventSystemComponentClient
	// IncidentField is the client for interacting with the IncidentField builders.
	IncidentField *IncidentFieldClient
	// IncidentFieldOption is the client for interacting with the IncidentFieldOption builders.
	IncidentFieldOption *IncidentFieldOptionClient
	// IncidentLink is the client for interacting with the IncidentLink builders.
	IncidentLink *IncidentLinkClient
	// IncidentMilestone is the client for interacting with the IncidentMilestone builders.
	IncidentMilestone *IncidentMilestoneClient
	// IncidentRole is the client for interacting with the IncidentRole builders.
	IncidentRole *IncidentRoleClient
	// IncidentRoleAssignment is the client for interacting with the IncidentRoleAssignment builders.
	IncidentRoleAssignment *IncidentRoleAssignmentClient
	// IncidentSeverity is the client for interacting with the IncidentSeverity builders.
	IncidentSeverity *IncidentSeverityClient
	// IncidentTag is the client for interacting with the IncidentTag builders.
	IncidentTag *IncidentTagClient
	// IncidentTeamAssignment is the client for interacting with the IncidentTeamAssignment builders.
	IncidentTeamAssignment *IncidentTeamAssignmentClient
	// IncidentType is the client for interacting with the IncidentType builders.
	IncidentType *IncidentTypeClient
	// MeetingSchedule is the client for interacting with the MeetingSchedule builders.
	MeetingSchedule *MeetingScheduleClient
	// MeetingSession is the client for interacting with the MeetingSession builders.
	MeetingSession *MeetingSessionClient
	// OncallAnnotation is the client for interacting with the OncallAnnotation builders.
	OncallAnnotation *OncallAnnotationClient
	// OncallAnnotationAlertFeedback is the client for interacting with the OncallAnnotationAlertFeedback builders.
	OncallAnnotationAlertFeedback *OncallAnnotationAlertFeedbackClient
	// OncallEvent is the client for interacting with the OncallEvent builders.
	OncallEvent *OncallEventClient
	// OncallHandoverTemplate is the client for interacting with the OncallHandoverTemplate builders.
	OncallHandoverTemplate *OncallHandoverTemplateClient
	// OncallRoster is the client for interacting with the OncallRoster builders.
	OncallRoster *OncallRosterClient
	// OncallRosterMetrics is the client for interacting with the OncallRosterMetrics builders.
	OncallRosterMetrics *OncallRosterMetricsClient
	// OncallSchedule is the client for interacting with the OncallSchedule builders.
	OncallSchedule *OncallScheduleClient
	// OncallScheduleParticipant is the client for interacting with the OncallScheduleParticipant builders.
	OncallScheduleParticipant *OncallScheduleParticipantClient
	// OncallUserShift is the client for interacting with the OncallUserShift builders.
	OncallUserShift *OncallUserShiftClient
	// OncallUserShiftHandover is the client for interacting with the OncallUserShiftHandover builders.
	OncallUserShiftHandover *OncallUserShiftHandoverClient
	// OncallUserShiftMetrics is the client for interacting with the OncallUserShiftMetrics builders.
	OncallUserShiftMetrics *OncallUserShiftMetricsClient
	// Playbook is the client for interacting with the Playbook builders.
	Playbook *PlaybookClient
	// ProviderConfig is the client for interacting with the ProviderConfig builders.
	ProviderConfig *ProviderConfigClient
	// ProviderSyncHistory is the client for interacting with the ProviderSyncHistory builders.
	ProviderSyncHistory *ProviderSyncHistoryClient
	// Retrospective is the client for interacting with the Retrospective builders.
	Retrospective *RetrospectiveClient
	// RetrospectiveDiscussion is the client for interacting with the RetrospectiveDiscussion builders.
	RetrospectiveDiscussion *RetrospectiveDiscussionClient
	// RetrospectiveDiscussionReply is the client for interacting with the RetrospectiveDiscussionReply builders.
	RetrospectiveDiscussionReply *RetrospectiveDiscussionReplyClient
	// RetrospectiveReview is the client for interacting with the RetrospectiveReview builders.
	RetrospectiveReview *RetrospectiveReviewClient
	// SystemAnalysis is the client for interacting with the SystemAnalysis builders.
	SystemAnalysis *SystemAnalysisClient
	// SystemAnalysisComponent is the client for interacting with the SystemAnalysisComponent builders.
	SystemAnalysisComponent *SystemAnalysisComponentClient
	// SystemAnalysisRelationship is the client for interacting with the SystemAnalysisRelationship builders.
	SystemAnalysisRelationship *SystemAnalysisRelationshipClient
	// SystemComponent is the client for interacting with the SystemComponent builders.
	SystemComponent *SystemComponentClient
	// SystemComponentConstraint is the client for interacting with the SystemComponentConstraint builders.
	SystemComponentConstraint *SystemComponentConstraintClient
	// SystemComponentControl is the client for interacting with the SystemComponentControl builders.
	SystemComponentControl *SystemComponentControlClient
	// SystemComponentKind is the client for interacting with the SystemComponentKind builders.
	SystemComponentKind *SystemComponentKindClient
	// SystemComponentRelationship is the client for interacting with the SystemComponentRelationship builders.
	SystemComponentRelationship *SystemComponentRelationshipClient
	// SystemComponentSignal is the client for interacting with the SystemComponentSignal builders.
	SystemComponentSignal *SystemComponentSignalClient
	// SystemHazard is the client for interacting with the SystemHazard builders.
	SystemHazard *SystemHazardClient
	// SystemRelationshipControlAction is the client for interacting with the SystemRelationshipControlAction builders.
	SystemRelationshipControlAction *SystemRelationshipControlActionClient
	// SystemRelationshipFeedbackSignal is the client for interacting with the SystemRelationshipFeedbackSignal builders.
	SystemRelationshipFeedbackSignal *SystemRelationshipFeedbackSignalClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// Team is the client for interacting with the Team builders.
	Team *TeamClient
	// Tenant is the client for interacting with the Tenant builders.
	Tenant *TenantClient
	// Ticket is the client for interacting with the Ticket builders.
	Ticket *TicketClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Alert = NewAlertClient(c.config)
	c.AlertMetrics = NewAlertMetricsClient(c.config)
	c.Environment = NewEnvironmentClient(c.config)
	c.Functionality = NewFunctionalityClient(c.config)
	c.Incident = NewIncidentClient(c.config)
	c.IncidentDebrief = NewIncidentDebriefClient(c.config)
	c.IncidentDebriefMessage = NewIncidentDebriefMessageClient(c.config)
	c.IncidentDebriefQuestion = NewIncidentDebriefQuestionClient(c.config)
	c.IncidentDebriefSuggestion = NewIncidentDebriefSuggestionClient(c.config)
	c.IncidentEvent = NewIncidentEventClient(c.config)
	c.IncidentEventContext = NewIncidentEventContextClient(c.config)
	c.IncidentEventContributingFactor = NewIncidentEventContributingFactorClient(c.config)
	c.IncidentEventEvidence = NewIncidentEventEvidenceClient(c.config)
	c.IncidentEventSystemComponent = NewIncidentEventSystemComponentClient(c.config)
	c.IncidentField = NewIncidentFieldClient(c.config)
	c.IncidentFieldOption = NewIncidentFieldOptionClient(c.config)
	c.IncidentLink = NewIncidentLinkClient(c.config)
	c.IncidentMilestone = NewIncidentMilestoneClient(c.config)
	c.IncidentRole = NewIncidentRoleClient(c.config)
	c.IncidentRoleAssignment = NewIncidentRoleAssignmentClient(c.config)
	c.IncidentSeverity = NewIncidentSeverityClient(c.config)
	c.IncidentTag = NewIncidentTagClient(c.config)
	c.IncidentTeamAssignment = NewIncidentTeamAssignmentClient(c.config)
	c.IncidentType = NewIncidentTypeClient(c.config)
	c.MeetingSchedule = NewMeetingScheduleClient(c.config)
	c.MeetingSession = NewMeetingSessionClient(c.config)
	c.OncallAnnotation = NewOncallAnnotationClient(c.config)
	c.OncallAnnotationAlertFeedback = NewOncallAnnotationAlertFeedbackClient(c.config)
	c.OncallEvent = NewOncallEventClient(c.config)
	c.OncallHandoverTemplate = NewOncallHandoverTemplateClient(c.config)
	c.OncallRoster = NewOncallRosterClient(c.config)
	c.OncallRosterMetrics = NewOncallRosterMetricsClient(c.config)
	c.OncallSchedule = NewOncallScheduleClient(c.config)
	c.OncallScheduleParticipant = NewOncallScheduleParticipantClient(c.config)
	c.OncallUserShift = NewOncallUserShiftClient(c.config)
	c.OncallUserShiftHandover = NewOncallUserShiftHandoverClient(c.config)
	c.OncallUserShiftMetrics = NewOncallUserShiftMetricsClient(c.config)
	c.Playbook = NewPlaybookClient(c.config)
	c.ProviderConfig = NewProviderConfigClient(c.config)
	c.ProviderSyncHistory = NewProviderSyncHistoryClient(c.config)
	c.Retrospective = NewRetrospectiveClient(c.config)
	c.RetrospectiveDiscussion = NewRetrospectiveDiscussionClient(c.config)
	c.RetrospectiveDiscussionReply = NewRetrospectiveDiscussionReplyClient(c.config)
	c.RetrospectiveReview = NewRetrospectiveReviewClient(c.config)
	c.SystemAnalysis = NewSystemAnalysisClient(c.config)
	c.SystemAnalysisComponent = NewSystemAnalysisComponentClient(c.config)
	c.SystemAnalysisRelationship = NewSystemAnalysisRelationshipClient(c.config)
	c.SystemComponent = NewSystemComponentClient(c.config)
	c.SystemComponentConstraint = NewSystemComponentConstraintClient(c.config)
	c.SystemComponentControl = NewSystemComponentControlClient(c.config)
	c.SystemComponentKind = NewSystemComponentKindClient(c.config)
	c.SystemComponentRelationship = NewSystemComponentRelationshipClient(c.config)
	c.SystemComponentSignal = NewSystemComponentSignalClient(c.config)
	c.SystemHazard = NewSystemHazardClient(c.config)
	c.SystemRelationshipControlAction = NewSystemRelationshipControlActionClient(c.config)
	c.SystemRelationshipFeedbackSignal = NewSystemRelationshipFeedbackSignalClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.Team = NewTeamClient(c.config)
	c.Tenant = NewTenantClient(c.config)
	c.Ticket = NewTicketClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                              ctx,
		config:                           cfg,
		Alert:                            NewAlertClient(cfg),
		AlertMetrics:                     NewAlertMetricsClient(cfg),
		Environment:                      NewEnvironmentClient(cfg),
		Functionality:                    NewFunctionalityClient(cfg),
		Incident:                         NewIncidentClient(cfg),
		IncidentDebrief:                  NewIncidentDebriefClient(cfg),
		IncidentDebriefMessage:           NewIncidentDebriefMessageClient(cfg),
		IncidentDebriefQuestion:          NewIncidentDebriefQuestionClient(cfg),
		IncidentDebriefSuggestion:        NewIncidentDebriefSuggestionClient(cfg),
		IncidentEvent:                    NewIncidentEventClient(cfg),
		IncidentEventContext:             NewIncidentEventContextClient(cfg),
		IncidentEventContributingFactor:  NewIncidentEventContributingFactorClient(cfg),
		IncidentEventEvidence:            NewIncidentEventEvidenceClient(cfg),
		IncidentEventSystemComponent:     NewIncidentEventSystemComponentClient(cfg),
		IncidentField:                    NewIncidentFieldClient(cfg),
		IncidentFieldOption:              NewIncidentFieldOptionClient(cfg),
		IncidentLink:                     NewIncidentLinkClient(cfg),
		IncidentMilestone:                NewIncidentMilestoneClient(cfg),
		IncidentRole:                     NewIncidentRoleClient(cfg),
		IncidentRoleAssignment:           NewIncidentRoleAssignmentClient(cfg),
		IncidentSeverity:                 NewIncidentSeverityClient(cfg),
		IncidentTag:                      NewIncidentTagClient(cfg),
		IncidentTeamAssignment:           NewIncidentTeamAssignmentClient(cfg),
		IncidentType:                     NewIncidentTypeClient(cfg),
		MeetingSchedule:                  NewMeetingScheduleClient(cfg),
		MeetingSession:                   NewMeetingSessionClient(cfg),
		OncallAnnotation:                 NewOncallAnnotationClient(cfg),
		OncallAnnotationAlertFeedback:    NewOncallAnnotationAlertFeedbackClient(cfg),
		OncallEvent:                      NewOncallEventClient(cfg),
		OncallHandoverTemplate:           NewOncallHandoverTemplateClient(cfg),
		OncallRoster:                     NewOncallRosterClient(cfg),
		OncallRosterMetrics:              NewOncallRosterMetricsClient(cfg),
		OncallSchedule:                   NewOncallScheduleClient(cfg),
		OncallScheduleParticipant:        NewOncallScheduleParticipantClient(cfg),
		OncallUserShift:                  NewOncallUserShiftClient(cfg),
		OncallUserShiftHandover:          NewOncallUserShiftHandoverClient(cfg),
		OncallUserShiftMetrics:           NewOncallUserShiftMetricsClient(cfg),
		Playbook:                         NewPlaybookClient(cfg),
		ProviderConfig:                   NewProviderConfigClient(cfg),
		ProviderSyncHistory:              NewProviderSyncHistoryClient(cfg),
		Retrospective:                    NewRetrospectiveClient(cfg),
		RetrospectiveDiscussion:          NewRetrospectiveDiscussionClient(cfg),
		RetrospectiveDiscussionReply:     NewRetrospectiveDiscussionReplyClient(cfg),
		RetrospectiveReview:              NewRetrospectiveReviewClient(cfg),
		SystemAnalysis:                   NewSystemAnalysisClient(cfg),
		SystemAnalysisComponent:          NewSystemAnalysisComponentClient(cfg),
		SystemAnalysisRelationship:       NewSystemAnalysisRelationshipClient(cfg),
		SystemComponent:                  NewSystemComponentClient(cfg),
		SystemComponentConstraint:        NewSystemComponentConstraintClient(cfg),
		SystemComponentControl:           NewSystemComponentControlClient(cfg),
		SystemComponentKind:              NewSystemComponentKindClient(cfg),
		SystemComponentRelationship:      NewSystemComponentRelationshipClient(cfg),
		SystemComponentSignal:            NewSystemComponentSignalClient(cfg),
		SystemHazard:                     NewSystemHazardClient(cfg),
		SystemRelationshipControlAction:  NewSystemRelationshipControlActionClient(cfg),
		SystemRelationshipFeedbackSignal: NewSystemRelationshipFeedbackSignalClient(cfg),
		Task:                             NewTaskClient(cfg),
		Team:                             NewTeamClient(cfg),
		Tenant:                           NewTenantClient(cfg),
		Ticket:                           NewTicketClient(cfg),
		User:                             NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                              ctx,
		config:                           cfg,
		Alert:                            NewAlertClient(cfg),
		AlertMetrics:                     NewAlertMetricsClient(cfg),
		Environment:                      NewEnvironmentClient(cfg),
		Functionality:                    NewFunctionalityClient(cfg),
		Incident:                         NewIncidentClient(cfg),
		IncidentDebrief:                  NewIncidentDebriefClient(cfg),
		IncidentDebriefMessage:           NewIncidentDebriefMessageClient(cfg),
		IncidentDebriefQuestion:          NewIncidentDebriefQuestionClient(cfg),
		IncidentDebriefSuggestion:        NewIncidentDebriefSuggestionClient(cfg),
		IncidentEvent:                    NewIncidentEventClient(cfg),
		IncidentEventContext:             NewIncidentEventContextClient(cfg),
		IncidentEventContributingFactor:  NewIncidentEventContributingFactorClient(cfg),
		IncidentEventEvidence:            NewIncidentEventEvidenceClient(cfg),
		IncidentEventSystemComponent:     NewIncidentEventSystemComponentClient(cfg),
		IncidentField:                    NewIncidentFieldClient(cfg),
		IncidentFieldOption:              NewIncidentFieldOptionClient(cfg),
		IncidentLink:                     NewIncidentLinkClient(cfg),
		IncidentMilestone:                NewIncidentMilestoneClient(cfg),
		IncidentRole:                     NewIncidentRoleClient(cfg),
		IncidentRoleAssignment:           NewIncidentRoleAssignmentClient(cfg),
		IncidentSeverity:                 NewIncidentSeverityClient(cfg),
		IncidentTag:                      NewIncidentTagClient(cfg),
		IncidentTeamAssignment:           NewIncidentTeamAssignmentClient(cfg),
		IncidentType:                     NewIncidentTypeClient(cfg),
		MeetingSchedule:                  NewMeetingScheduleClient(cfg),
		MeetingSession:                   NewMeetingSessionClient(cfg),
		OncallAnnotation:                 NewOncallAnnotationClient(cfg),
		OncallAnnotationAlertFeedback:    NewOncallAnnotationAlertFeedbackClient(cfg),
		OncallEvent:                      NewOncallEventClient(cfg),
		OncallHandoverTemplate:           NewOncallHandoverTemplateClient(cfg),
		OncallRoster:                     NewOncallRosterClient(cfg),
		OncallRosterMetrics:              NewOncallRosterMetricsClient(cfg),
		OncallSchedule:                   NewOncallScheduleClient(cfg),
		OncallScheduleParticipant:        NewOncallScheduleParticipantClient(cfg),
		OncallUserShift:                  NewOncallUserShiftClient(cfg),
		OncallUserShiftHandover:          NewOncallUserShiftHandoverClient(cfg),
		OncallUserShiftMetrics:           NewOncallUserShiftMetricsClient(cfg),
		Playbook:                         NewPlaybookClient(cfg),
		ProviderConfig:                   NewProviderConfigClient(cfg),
		ProviderSyncHistory:              NewProviderSyncHistoryClient(cfg),
		Retrospective:                    NewRetrospectiveClient(cfg),
		RetrospectiveDiscussion:          NewRetrospectiveDiscussionClient(cfg),
		RetrospectiveDiscussionReply:     NewRetrospectiveDiscussionReplyClient(cfg),
		RetrospectiveReview:              NewRetrospectiveReviewClient(cfg),
		SystemAnalysis:                   NewSystemAnalysisClient(cfg),
		SystemAnalysisComponent:          NewSystemAnalysisComponentClient(cfg),
		SystemAnalysisRelationship:       NewSystemAnalysisRelationshipClient(cfg),
		SystemComponent:                  NewSystemComponentClient(cfg),
		SystemComponentConstraint:        NewSystemComponentConstraintClient(cfg),
		SystemComponentControl:           NewSystemComponentControlClient(cfg),
		SystemComponentKind:              NewSystemComponentKindClient(cfg),
		SystemComponentRelationship:      NewSystemComponentRelationshipClient(cfg),
		SystemComponentSignal:            NewSystemComponentSignalClient(cfg),
		SystemHazard:                     NewSystemHazardClient(cfg),
		SystemRelationshipControlAction:  NewSystemRelationshipControlActionClient(cfg),
		SystemRelationshipFeedbackSignal: NewSystemRelationshipFeedbackSignalClient(cfg),
		Task:                             NewTaskClient(cfg),
		Team:                             NewTeamClient(cfg),
		Tenant:                           NewTenantClient(cfg),
		Ticket:                           NewTicketClient(cfg),
		User:                             NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Alert.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Alert, c.AlertMetrics, c.Environment, c.Functionality, c.Incident,
		c.IncidentDebrief, c.IncidentDebriefMessage, c.IncidentDebriefQuestion,
		c.IncidentDebriefSuggestion, c.IncidentEvent, c.IncidentEventContext,
		c.IncidentEventContributingFactor, c.IncidentEventEvidence,
		c.IncidentEventSystemComponent, c.IncidentField, c.IncidentFieldOption,
		c.IncidentLink, c.IncidentMilestone, c.IncidentRole, c.IncidentRoleAssignment,
		c.IncidentSeverity, c.IncidentTag, c.IncidentTeamAssignment, c.IncidentType,
		c.MeetingSchedule, c.MeetingSession, c.OncallAnnotation,
		c.OncallAnnotationAlertFeedback, c.OncallEvent, c.OncallHandoverTemplate,
		c.OncallRoster, c.OncallRosterMetrics, c.OncallSchedule,
		c.OncallScheduleParticipant, c.OncallUserShift, c.OncallUserShiftHandover,
		c.OncallUserShiftMetrics, c.Playbook, c.ProviderConfig, c.ProviderSyncHistory,
		c.Retrospective, c.RetrospectiveDiscussion, c.RetrospectiveDiscussionReply,
		c.RetrospectiveReview, c.SystemAnalysis, c.SystemAnalysisComponent,
		c.SystemAnalysisRelationship, c.SystemComponent, c.SystemComponentConstraint,
		c.SystemComponentControl, c.SystemComponentKind, c.SystemComponentRelationship,
		c.SystemComponentSignal, c.SystemHazard, c.SystemRelationshipControlAction,
		c.SystemRelationshipFeedbackSignal, c.Task, c.Team, c.Tenant, c.Ticket, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Alert, c.AlertMetrics, c.Environment, c.Functionality, c.Incident,
		c.IncidentDebrief, c.IncidentDebriefMessage, c.IncidentDebriefQuestion,
		c.IncidentDebriefSuggestion, c.IncidentEvent, c.IncidentEventContext,
		c.IncidentEventContributingFactor, c.IncidentEventEvidence,
		c.IncidentEventSystemComponent, c.IncidentField, c.IncidentFieldOption,
		c.IncidentLink, c.IncidentMilestone, c.IncidentRole, c.IncidentRoleAssignment,
		c.IncidentSeverity, c.IncidentTag, c.IncidentTeamAssignment, c.IncidentType,
		c.MeetingSchedule, c.MeetingSession, c.OncallAnnotation,
		c.OncallAnnotationAlertFeedback, c.OncallEvent, c.OncallHandoverTemplate,
		c.OncallRoster, c.OncallRosterMetrics, c.OncallSchedule,
		c.OncallScheduleParticipant, c.OncallUserShift, c.OncallUserShiftHandover,
		c.OncallUserShiftMetrics, c.Playbook, c.ProviderConfig, c.ProviderSyncHistory,
		c.Retrospective, c.RetrospectiveDiscussion, c.RetrospectiveDiscussionReply,
		c.RetrospectiveReview, c.SystemAnalysis, c.SystemAnalysisComponent,
		c.SystemAnalysisRelationship, c.SystemComponent, c.SystemComponentConstraint,
		c.SystemComponentControl, c.SystemComponentKind, c.SystemComponentRelationship,
		c.SystemComponentSignal, c.SystemHazard, c.SystemRelationshipControlAction,
		c.SystemRelationshipFeedbackSignal, c.Task, c.Team, c.Tenant, c.Ticket, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AlertMutation:
		return c.Alert.mutate(ctx, m)
	case *AlertMetricsMutation:
		return c.AlertMetrics.mutate(ctx, m)
	case *EnvironmentMutation:
		return c.Environment.mutate(ctx, m)
	case *FunctionalityMutation:
		return c.Functionality.mutate(ctx, m)
	case *IncidentMutation:
		return c.Incident.mutate(ctx, m)
	case *IncidentDebriefMutation:
		return c.IncidentDebrief.mutate(ctx, m)
	case *IncidentDebriefMessageMutation:
		return c.IncidentDebriefMessage.mutate(ctx, m)
	case *IncidentDebriefQuestionMutation:
		return c.IncidentDebriefQuestion.mutate(ctx, m)
	case *IncidentDebriefSuggestionMutation:
		return c.IncidentDebriefSuggestion.mutate(ctx, m)
	case *IncidentEventMutation:
		return c.IncidentEvent.mutate(ctx, m)
	case *IncidentEventContextMutation:
		return c.IncidentEventContext.mutate(ctx, m)
	case *IncidentEventContributingFactorMutation:
		return c.IncidentEventContributingFactor.mutate(ctx, m)
	case *IncidentEventEvidenceMutation:
		return c.IncidentEventEvidence.mutate(ctx, m)
	case *IncidentEventSystemComponentMutation:
		return c.IncidentEventSystemComponent.mutate(ctx, m)
	case *IncidentFieldMutation:
		return c.IncidentField.mutate(ctx, m)
	case *IncidentFieldOptionMutation:
		return c.IncidentFieldOption.mutate(ctx, m)
	case *IncidentLinkMutation:
		return c.IncidentLink.mutate(ctx, m)
	case *IncidentMilestoneMutation:
		return c.IncidentMilestone.mutate(ctx, m)
	case *IncidentRoleMutation:
		return c.IncidentRole.mutate(ctx, m)
	case *IncidentRoleAssignmentMutation:
		return c.IncidentRoleAssignment.mutate(ctx, m)
	case *IncidentSeverityMutation:
		return c.IncidentSeverity.mutate(ctx, m)
	case *IncidentTagMutation:
		return c.IncidentTag.mutate(ctx, m)
	case *IncidentTeamAssignmentMutation:
		return c.IncidentTeamAssignment.mutate(ctx, m)
	case *IncidentTypeMutation:
		return c.IncidentType.mutate(ctx, m)
	case *MeetingScheduleMutation:
		return c.MeetingSchedule.mutate(ctx, m)
	case *MeetingSessionMutation:
		return c.MeetingSession.mutate(ctx, m)
	case *OncallAnnotationMutation:
		return c.OncallAnnotation.mutate(ctx, m)
	case *OncallAnnotationAlertFeedbackMutation:
		return c.OncallAnnotationAlertFeedback.mutate(ctx, m)
	case *OncallEventMutation:
		return c.OncallEvent.mutate(ctx, m)
	case *OncallHandoverTemplateMutation:
		return c.OncallHandoverTemplate.mutate(ctx, m)
	case *OncallRosterMutation:
		return c.OncallRoster.mutate(ctx, m)
	case *OncallRosterMetricsMutation:
		return c.OncallRosterMetrics.mutate(ctx, m)
	case *OncallScheduleMutation:
		return c.OncallSchedule.mutate(ctx, m)
	case *OncallScheduleParticipantMutation:
		return c.OncallScheduleParticipant.mutate(ctx, m)
	case *OncallUserShiftMutation:
		return c.OncallUserShift.mutate(ctx, m)
	case *OncallUserShiftHandoverMutation:
		return c.OncallUserShiftHandover.mutate(ctx, m)
	case *OncallUserShiftMetricsMutation:
		return c.OncallUserShiftMetrics.mutate(ctx, m)
	case *PlaybookMutation:
		return c.Playbook.mutate(ctx, m)
	case *ProviderConfigMutation:
		return c.ProviderConfig.mutate(ctx, m)
	case *ProviderSyncHistoryMutation:
		return c.ProviderSyncHistory.mutate(ctx, m)
	case *RetrospectiveMutation:
		return c.Retrospective.mutate(ctx, m)
	case *RetrospectiveDiscussionMutation:
		return c.RetrospectiveDiscussion.mutate(ctx, m)
	case *RetrospectiveDiscussionReplyMutation:
		return c.RetrospectiveDiscussionReply.mutate(ctx, m)
	case *RetrospectiveReviewMutation:
		return c.RetrospectiveReview.mutate(ctx, m)
	case *SystemAnalysisMutation:
		return c.SystemAnalysis.mutate(ctx, m)
	case *SystemAnalysisComponentMutation:
		return c.SystemAnalysisComponent.mutate(ctx, m)
	case *SystemAnalysisRelationshipMutation:
		return c.SystemAnalysisRelationship.mutate(ctx, m)
	case *SystemComponentMutation:
		return c.SystemComponent.mutate(ctx, m)
	case *SystemComponentConstraintMutation:
		return c.SystemComponentConstraint.mutate(ctx, m)
	case *SystemComponentControlMutation:
		return c.SystemComponentControl.mutate(ctx, m)
	case *SystemComponentKindMutation:
		return c.SystemComponentKind.mutate(ctx, m)
	case *SystemComponentRelationshipMutation:
		return c.SystemComponentRelationship.mutate(ctx, m)
	case *SystemComponentSignalMutation:
		return c.SystemComponentSignal.mutate(ctx, m)
	case *SystemHazardMutation:
		return c.SystemHazard.mutate(ctx, m)
	case *SystemRelationshipControlActionMutation:
		return c.SystemRelationshipControlAction.mutate(ctx, m)
	case *SystemRelationshipFeedbackSignalMutation:
		return c.SystemRelationshipFeedbackSignal.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *TeamMutation:
		return c.Team.mutate(ctx, m)
	case *TenantMutation:
		return c.Tenant.mutate(ctx, m)
	case *TicketMutation:
		return c.Ticket.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AlertClient is a client for the Alert schema.
type AlertClient struct {
	config
}

// NewAlertClient returns a client for the Alert from the given config.
func NewAlertClient(c config) *AlertClient {
	return &AlertClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `alert.Hooks(f(g(h())))`.
func (c *AlertClient) Use(hooks ...Hook) {
	c.hooks.Alert = append(c.hooks.Alert, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `alert.Intercept(f(g(h())))`.
func (c *AlertClient) Intercept(interceptors ...Interceptor) {
	c.inters.Alert = append(c.inters.Alert, interceptors...)
}

// Create returns a builder for creating a Alert entity.
func (c *AlertClient) Create() *AlertCreate {
	mutation := newAlertMutation(c.config, OpCreate)
	return &AlertCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Alert entities.
func (c *AlertClient) CreateBulk(builders ...*AlertCreate) *AlertCreateBulk {
	return &AlertCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlertClient) MapCreateBulk(slice any, setFunc func(*AlertCreate, int)) *AlertCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlertCreateBulk{err: fmt.Errorf("calling to AlertClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlertCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlertCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Alert.
func (c *AlertClient) Update() *AlertUpdate {
	mutation := newAlertMutation(c.config, OpUpdate)
	return &AlertUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlertClient) UpdateOne(a *Alert) *AlertUpdateOne {
	mutation := newAlertMutation(c.config, OpUpdateOne, withAlert(a))
	return &AlertUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlertClient) UpdateOneID(id uuid.UUID) *AlertUpdateOne {
	mutation := newAlertMutation(c.config, OpUpdateOne, withAlertID(id))
	return &AlertUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Alert.
func (c *AlertClient) Delete() *AlertDelete {
	mutation := newAlertMutation(c.config, OpDelete)
	return &AlertDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlertClient) DeleteOne(a *Alert) *AlertDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlertClient) DeleteOneID(id uuid.UUID) *AlertDeleteOne {
	builder := c.Delete().Where(alert.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlertDeleteOne{builder}
}

// Query returns a query builder for Alert.
func (c *AlertClient) Query() *AlertQuery {
	return &AlertQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlert},
		inters: c.Interceptors(),
	}
}

// Get returns a Alert entity by its id.
func (c *AlertClient) Get(ctx context.Context, id uuid.UUID) (*Alert, error) {
	return c.Query().Where(alert.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlertClient) GetX(ctx context.Context, id uuid.UUID) *Alert {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetrics queries the metrics edge of a Alert.
func (c *AlertClient) QueryMetrics(a *Alert) *AlertMetricsQuery {
	query := (&AlertMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alert.Table, alert.FieldID, id),
			sqlgraph.To(alertmetrics.Table, alertmetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, alert.MetricsTable, alert.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaybooks queries the playbooks edge of a Alert.
func (c *AlertClient) QueryPlaybooks(a *Alert) *PlaybookQuery {
	query := (&PlaybookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alert.Table, alert.FieldID, id),
			sqlgraph.To(playbook.Table, playbook.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, alert.PlaybooksTable, alert.PlaybooksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstances queries the instances edge of a Alert.
func (c *AlertClient) QueryInstances(a *Alert) *OncallEventQuery {
	query := (&OncallEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alert.Table, alert.FieldID, id),
			sqlgraph.To(oncallevent.Table, oncallevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, alert.InstancesTable, alert.InstancesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AlertClient) Hooks() []Hook {
	hooks := c.hooks.Alert
	return append(hooks[:len(hooks):len(hooks)], alert.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AlertClient) Interceptors() []Interceptor {
	return c.inters.Alert
}

func (c *AlertClient) mutate(ctx context.Context, m *AlertMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlertCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlertUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlertUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlertDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Alert mutation op: %q", m.Op())
	}
}

// AlertMetricsClient is a client for the AlertMetrics schema.
type AlertMetricsClient struct {
	config
}

// NewAlertMetricsClient returns a client for the AlertMetrics from the given config.
func NewAlertMetricsClient(c config) *AlertMetricsClient {
	return &AlertMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `alertmetrics.Hooks(f(g(h())))`.
func (c *AlertMetricsClient) Use(hooks ...Hook) {
	c.hooks.AlertMetrics = append(c.hooks.AlertMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `alertmetrics.Intercept(f(g(h())))`.
func (c *AlertMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.AlertMetrics = append(c.inters.AlertMetrics, interceptors...)
}

// Create returns a builder for creating a AlertMetrics entity.
func (c *AlertMetricsClient) Create() *AlertMetricsCreate {
	mutation := newAlertMetricsMutation(c.config, OpCreate)
	return &AlertMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AlertMetrics entities.
func (c *AlertMetricsClient) CreateBulk(builders ...*AlertMetricsCreate) *AlertMetricsCreateBulk {
	return &AlertMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlertMetricsClient) MapCreateBulk(slice any, setFunc func(*AlertMetricsCreate, int)) *AlertMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlertMetricsCreateBulk{err: fmt.Errorf("calling to AlertMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlertMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlertMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AlertMetrics.
func (c *AlertMetricsClient) Update() *AlertMetricsUpdate {
	mutation := newAlertMetricsMutation(c.config, OpUpdate)
	return &AlertMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlertMetricsClient) UpdateOne(am *AlertMetrics) *AlertMetricsUpdateOne {
	mutation := newAlertMetricsMutation(c.config, OpUpdateOne, withAlertMetrics(am))
	return &AlertMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlertMetricsClient) UpdateOneID(id uuid.UUID) *AlertMetricsUpdateOne {
	mutation := newAlertMetricsMutation(c.config, OpUpdateOne, withAlertMetricsID(id))
	return &AlertMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AlertMetrics.
func (c *AlertMetricsClient) Delete() *AlertMetricsDelete {
	mutation := newAlertMetricsMutation(c.config, OpDelete)
	return &AlertMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlertMetricsClient) DeleteOne(am *AlertMetrics) *AlertMetricsDeleteOne {
	return c.DeleteOneID(am.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlertMetricsClient) DeleteOneID(id uuid.UUID) *AlertMetricsDeleteOne {
	builder := c.Delete().Where(alertmetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlertMetricsDeleteOne{builder}
}

// Query returns a query builder for AlertMetrics.
func (c *AlertMetricsClient) Query() *AlertMetricsQuery {
	return &AlertMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlertMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a AlertMetrics entity by its id.
func (c *AlertMetricsClient) Get(ctx context.Context, id uuid.UUID) (*AlertMetrics, error) {
	return c.Query().Where(alertmetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlertMetricsClient) GetX(ctx context.Context, id uuid.UUID) *AlertMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAlert queries the alert edge of a AlertMetrics.
func (c *AlertMetricsClient) QueryAlert(am *AlertMetrics) *AlertQuery {
	query := (&AlertClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := am.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alertmetrics.Table, alertmetrics.FieldID, id),
			sqlgraph.To(alert.Table, alert.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, alertmetrics.AlertTable, alertmetrics.AlertColumn),
		)
		fromV = sqlgraph.Neighbors(am.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AlertMetricsClient) Hooks() []Hook {
	hooks := c.hooks.AlertMetrics
	return append(hooks[:len(hooks):len(hooks)], alertmetrics.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AlertMetricsClient) Interceptors() []Interceptor {
	return c.inters.AlertMetrics
}

func (c *AlertMetricsClient) mutate(ctx context.Context, m *AlertMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlertMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlertMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlertMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlertMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AlertMetrics mutation op: %q", m.Op())
	}
}

// EnvironmentClient is a client for the Environment schema.
type EnvironmentClient struct {
	config
}

// NewEnvironmentClient returns a client for the Environment from the given config.
func NewEnvironmentClient(c config) *EnvironmentClient {
	return &EnvironmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `environment.Hooks(f(g(h())))`.
func (c *EnvironmentClient) Use(hooks ...Hook) {
	c.hooks.Environment = append(c.hooks.Environment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `environment.Intercept(f(g(h())))`.
func (c *EnvironmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Environment = append(c.inters.Environment, interceptors...)
}

// Create returns a builder for creating a Environment entity.
func (c *EnvironmentClient) Create() *EnvironmentCreate {
	mutation := newEnvironmentMutation(c.config, OpCreate)
	return &EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Environment entities.
func (c *EnvironmentClient) CreateBulk(builders ...*EnvironmentCreate) *EnvironmentCreateBulk {
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvironmentClient) MapCreateBulk(slice any, setFunc func(*EnvironmentCreate, int)) *EnvironmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvironmentCreateBulk{err: fmt.Errorf("calling to EnvironmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvironmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Environment.
func (c *EnvironmentClient) Update() *EnvironmentUpdate {
	mutation := newEnvironmentMutation(c.config, OpUpdate)
	return &EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvironmentClient) UpdateOne(e *Environment) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironment(e))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvironmentClient) UpdateOneID(id uuid.UUID) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironmentID(id))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Environment.
func (c *EnvironmentClient) Delete() *EnvironmentDelete {
	mutation := newEnvironmentMutation(c.config, OpDelete)
	return &EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvironmentClient) DeleteOne(e *Environment) *EnvironmentDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvironmentClient) DeleteOneID(id uuid.UUID) *EnvironmentDeleteOne {
	builder := c.Delete().Where(environment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvironmentDeleteOne{builder}
}

// Query returns a query builder for Environment.
func (c *EnvironmentClient) Query() *EnvironmentQuery {
	return &EnvironmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnvironment},
		inters: c.Interceptors(),
	}
}

// Get returns a Environment entity by its id.
func (c *EnvironmentClient) Get(ctx context.Context, id uuid.UUID) (*Environment, error) {
	return c.Query().Where(environment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvironmentClient) GetX(ctx context.Context, id uuid.UUID) *Environment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a Environment.
func (c *EnvironmentClient) QueryIncidents(e *Environment) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, environment.IncidentsTable, environment.IncidentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvironmentClient) Hooks() []Hook {
	hooks := c.hooks.Environment
	return append(hooks[:len(hooks):len(hooks)], environment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EnvironmentClient) Interceptors() []Interceptor {
	inters := c.inters.Environment
	return append(inters[:len(inters):len(inters)], environment.Interceptors[:]...)
}

func (c *EnvironmentClient) mutate(ctx context.Context, m *EnvironmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Environment mutation op: %q", m.Op())
	}
}

// FunctionalityClient is a client for the Functionality schema.
type FunctionalityClient struct {
	config
}

// NewFunctionalityClient returns a client for the Functionality from the given config.
func NewFunctionalityClient(c config) *FunctionalityClient {
	return &FunctionalityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `functionality.Hooks(f(g(h())))`.
func (c *FunctionalityClient) Use(hooks ...Hook) {
	c.hooks.Functionality = append(c.hooks.Functionality, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `functionality.Intercept(f(g(h())))`.
func (c *FunctionalityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Functionality = append(c.inters.Functionality, interceptors...)
}

// Create returns a builder for creating a Functionality entity.
func (c *FunctionalityClient) Create() *FunctionalityCreate {
	mutation := newFunctionalityMutation(c.config, OpCreate)
	return &FunctionalityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Functionality entities.
func (c *FunctionalityClient) CreateBulk(builders ...*FunctionalityCreate) *FunctionalityCreateBulk {
	return &FunctionalityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FunctionalityClient) MapCreateBulk(slice any, setFunc func(*FunctionalityCreate, int)) *FunctionalityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FunctionalityCreateBulk{err: fmt.Errorf("calling to FunctionalityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FunctionalityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FunctionalityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Functionality.
func (c *FunctionalityClient) Update() *FunctionalityUpdate {
	mutation := newFunctionalityMutation(c.config, OpUpdate)
	return &FunctionalityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FunctionalityClient) UpdateOne(f *Functionality) *FunctionalityUpdateOne {
	mutation := newFunctionalityMutation(c.config, OpUpdateOne, withFunctionality(f))
	return &FunctionalityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FunctionalityClient) UpdateOneID(id uuid.UUID) *FunctionalityUpdateOne {
	mutation := newFunctionalityMutation(c.config, OpUpdateOne, withFunctionalityID(id))
	return &FunctionalityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Functionality.
func (c *FunctionalityClient) Delete() *FunctionalityDelete {
	mutation := newFunctionalityMutation(c.config, OpDelete)
	return &FunctionalityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FunctionalityClient) DeleteOne(f *Functionality) *FunctionalityDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FunctionalityClient) DeleteOneID(id uuid.UUID) *FunctionalityDeleteOne {
	builder := c.Delete().Where(functionality.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FunctionalityDeleteOne{builder}
}

// Query returns a query builder for Functionality.
func (c *FunctionalityClient) Query() *FunctionalityQuery {
	return &FunctionalityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFunctionality},
		inters: c.Interceptors(),
	}
}

// Get returns a Functionality entity by its id.
func (c *FunctionalityClient) Get(ctx context.Context, id uuid.UUID) (*Functionality, error) {
	return c.Query().Where(functionality.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FunctionalityClient) GetX(ctx context.Context, id uuid.UUID) *Functionality {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FunctionalityClient) Hooks() []Hook {
	hooks := c.hooks.Functionality
	return append(hooks[:len(hooks):len(hooks)], functionality.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FunctionalityClient) Interceptors() []Interceptor {
	return c.inters.Functionality
}

func (c *FunctionalityClient) mutate(ctx context.Context, m *FunctionalityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FunctionalityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FunctionalityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FunctionalityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FunctionalityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Functionality mutation op: %q", m.Op())
	}
}

// IncidentClient is a client for the Incident schema.
type IncidentClient struct {
	config
}

// NewIncidentClient returns a client for the Incident from the given config.
func NewIncidentClient(c config) *IncidentClient {
	return &IncidentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incident.Hooks(f(g(h())))`.
func (c *IncidentClient) Use(hooks ...Hook) {
	c.hooks.Incident = append(c.hooks.Incident, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incident.Intercept(f(g(h())))`.
func (c *IncidentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Incident = append(c.inters.Incident, interceptors...)
}

// Create returns a builder for creating a Incident entity.
func (c *IncidentClient) Create() *IncidentCreate {
	mutation := newIncidentMutation(c.config, OpCreate)
	return &IncidentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Incident entities.
func (c *IncidentClient) CreateBulk(builders ...*IncidentCreate) *IncidentCreateBulk {
	return &IncidentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentClient) MapCreateBulk(slice any, setFunc func(*IncidentCreate, int)) *IncidentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentCreateBulk{err: fmt.Errorf("calling to IncidentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Incident.
func (c *IncidentClient) Update() *IncidentUpdate {
	mutation := newIncidentMutation(c.config, OpUpdate)
	return &IncidentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentClient) UpdateOne(i *Incident) *IncidentUpdateOne {
	mutation := newIncidentMutation(c.config, OpUpdateOne, withIncident(i))
	return &IncidentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentClient) UpdateOneID(id uuid.UUID) *IncidentUpdateOne {
	mutation := newIncidentMutation(c.config, OpUpdateOne, withIncidentID(id))
	return &IncidentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Incident.
func (c *IncidentClient) Delete() *IncidentDelete {
	mutation := newIncidentMutation(c.config, OpDelete)
	return &IncidentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentClient) DeleteOne(i *Incident) *IncidentDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentClient) DeleteOneID(id uuid.UUID) *IncidentDeleteOne {
	builder := c.Delete().Where(incident.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentDeleteOne{builder}
}

// Query returns a query builder for Incident.
func (c *IncidentClient) Query() *IncidentQuery {
	return &IncidentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncident},
		inters: c.Interceptors(),
	}
}

// Get returns a Incident entity by its id.
func (c *IncidentClient) Get(ctx context.Context, id uuid.UUID) (*Incident, error) {
	return c.Query().Where(incident.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentClient) GetX(ctx context.Context, id uuid.UUID) *Incident {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironments queries the environments edge of a Incident.
func (c *IncidentClient) QueryEnvironments(i *Incident) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incident.EnvironmentsTable, incident.EnvironmentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeverity queries the severity edge of a Incident.
func (c *IncidentClient) QuerySeverity(i *Incident) *IncidentSeverityQuery {
	query := (&IncidentSeverityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentseverity.Table, incidentseverity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incident.SeverityTable, incident.SeverityColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryType queries the type edge of a Incident.
func (c *IncidentClient) QueryType(i *Incident) *IncidentTypeQuery {
	query := (&IncidentTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidenttype.Table, incidenttype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incident.TypeTable, incident.TypeColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeamAssignments queries the team_assignments edge of a Incident.
func (c *IncidentClient) QueryTeamAssignments(i *Incident) *IncidentTeamAssignmentQuery {
	query := (&IncidentTeamAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentteamassignment.Table, incidentteamassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incident.TeamAssignmentsTable, incident.TeamAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoleAssignments queries the role_assignments edge of a Incident.
func (c *IncidentClient) QueryRoleAssignments(i *Incident) *IncidentRoleAssignmentQuery {
	query := (&IncidentRoleAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentroleassignment.Table, incidentroleassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incident.RoleAssignmentsTable, incident.RoleAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMilestones queries the milestones edge of a Incident.
func (c *IncidentClient) QueryMilestones(i *Incident) *IncidentMilestoneQuery {
	query := (&IncidentMilestoneClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentmilestone.Table, incidentmilestone.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incident.MilestonesTable, incident.MilestonesColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Incident.
func (c *IncidentClient) QueryEvents(i *Incident) *IncidentEventQuery {
	query := (&IncidentEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentevent.Table, incidentevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incident.EventsTable, incident.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRetrospective queries the retrospective edge of a Incident.
func (c *IncidentClient) QueryRetrospective(i *Incident) *RetrospectiveQuery {
	query := (&RetrospectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(retrospective.Table, retrospective.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incident.RetrospectiveTable, incident.RetrospectiveColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLinkedIncidents queries the linked_incidents edge of a Incident.
func (c *IncidentClient) QueryLinkedIncidents(i *Incident) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incident.LinkedIncidentsTable, incident.LinkedIncidentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFieldSelections queries the field_selections edge of a Incident.
func (c *IncidentClient) QueryFieldSelections(i *Incident) *IncidentFieldOptionQuery {
	query := (&IncidentFieldOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentfieldoption.Table, incidentfieldoption.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incident.FieldSelectionsTable, incident.FieldSelectionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Incident.
func (c *IncidentClient) QueryTasks(i *Incident) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incident.TasksTable, incident.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTagAssignments queries the tag_assignments edge of a Incident.
func (c *IncidentClient) QueryTagAssignments(i *Incident) *IncidentTagQuery {
	query := (&IncidentTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidenttag.Table, incidenttag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incident.TagAssignmentsTable, incident.TagAssignmentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefs queries the debriefs edge of a Incident.
func (c *IncidentClient) QueryDebriefs(i *Incident) *IncidentDebriefQuery {
	query := (&IncidentDebriefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentdebrief.Table, incidentdebrief.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incident.DebriefsTable, incident.DebriefsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviewSessions queries the review_sessions edge of a Incident.
func (c *IncidentClient) QueryReviewSessions(i *Incident) *MeetingSessionQuery {
	query := (&MeetingSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(meetingsession.Table, meetingsession.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incident.ReviewSessionsTable, incident.ReviewSessionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentLinks queries the incident_links edge of a Incident.
func (c *IncidentClient) QueryIncidentLinks(i *Incident) *IncidentLinkQuery {
	query := (&IncidentLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentlink.Table, incidentlink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incident.IncidentLinksTable, incident.IncidentLinksColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentClient) Hooks() []Hook {
	hooks := c.hooks.Incident
	return append(hooks[:len(hooks):len(hooks)], incident.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentClient) Interceptors() []Interceptor {
	return c.inters.Incident
}

func (c *IncidentClient) mutate(ctx context.Context, m *IncidentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Incident mutation op: %q", m.Op())
	}
}

// IncidentDebriefClient is a client for the IncidentDebrief schema.
type IncidentDebriefClient struct {
	config
}

// NewIncidentDebriefClient returns a client for the IncidentDebrief from the given config.
func NewIncidentDebriefClient(c config) *IncidentDebriefClient {
	return &IncidentDebriefClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentdebrief.Hooks(f(g(h())))`.
func (c *IncidentDebriefClient) Use(hooks ...Hook) {
	c.hooks.IncidentDebrief = append(c.hooks.IncidentDebrief, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentdebrief.Intercept(f(g(h())))`.
func (c *IncidentDebriefClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentDebrief = append(c.inters.IncidentDebrief, interceptors...)
}

// Create returns a builder for creating a IncidentDebrief entity.
func (c *IncidentDebriefClient) Create() *IncidentDebriefCreate {
	mutation := newIncidentDebriefMutation(c.config, OpCreate)
	return &IncidentDebriefCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentDebrief entities.
func (c *IncidentDebriefClient) CreateBulk(builders ...*IncidentDebriefCreate) *IncidentDebriefCreateBulk {
	return &IncidentDebriefCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentDebriefClient) MapCreateBulk(slice any, setFunc func(*IncidentDebriefCreate, int)) *IncidentDebriefCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentDebriefCreateBulk{err: fmt.Errorf("calling to IncidentDebriefClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentDebriefCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentDebriefCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentDebrief.
func (c *IncidentDebriefClient) Update() *IncidentDebriefUpdate {
	mutation := newIncidentDebriefMutation(c.config, OpUpdate)
	return &IncidentDebriefUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentDebriefClient) UpdateOne(id *IncidentDebrief) *IncidentDebriefUpdateOne {
	mutation := newIncidentDebriefMutation(c.config, OpUpdateOne, withIncidentDebrief(id))
	return &IncidentDebriefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentDebriefClient) UpdateOneID(id uuid.UUID) *IncidentDebriefUpdateOne {
	mutation := newIncidentDebriefMutation(c.config, OpUpdateOne, withIncidentDebriefID(id))
	return &IncidentDebriefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentDebrief.
func (c *IncidentDebriefClient) Delete() *IncidentDebriefDelete {
	mutation := newIncidentDebriefMutation(c.config, OpDelete)
	return &IncidentDebriefDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentDebriefClient) DeleteOne(id *IncidentDebrief) *IncidentDebriefDeleteOne {
	return c.DeleteOneID(id.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentDebriefClient) DeleteOneID(id uuid.UUID) *IncidentDebriefDeleteOne {
	builder := c.Delete().Where(incidentdebrief.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentDebriefDeleteOne{builder}
}

// Query returns a query builder for IncidentDebrief.
func (c *IncidentDebriefClient) Query() *IncidentDebriefQuery {
	return &IncidentDebriefQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentDebrief},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentDebrief entity by its id.
func (c *IncidentDebriefClient) Get(ctx context.Context, id uuid.UUID) (*IncidentDebrief, error) {
	return c.Query().Where(incidentdebrief.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentDebriefClient) GetX(ctx context.Context, id uuid.UUID) *IncidentDebrief {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a IncidentDebrief.
func (c *IncidentDebriefClient) QueryIncident(node *IncidentDebrief) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := node.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebrief.Table, incidentdebrief.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentdebrief.IncidentTable, incidentdebrief.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(node.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a IncidentDebrief.
func (c *IncidentDebriefClient) QueryUser(node *IncidentDebrief) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := node.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebrief.Table, incidentdebrief.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentdebrief.UserTable, incidentdebrief.UserColumn),
		)
		fromV = sqlgraph.Neighbors(node.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a IncidentDebrief.
func (c *IncidentDebriefClient) QueryMessages(node *IncidentDebrief) *IncidentDebriefMessageQuery {
	query := (&IncidentDebriefMessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := node.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebrief.Table, incidentdebrief.FieldID, id),
			sqlgraph.To(incidentdebriefmessage.Table, incidentdebriefmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incidentdebrief.MessagesTable, incidentdebrief.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(node.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySuggestions queries the suggestions edge of a IncidentDebrief.
func (c *IncidentDebriefClient) QuerySuggestions(node *IncidentDebrief) *IncidentDebriefSuggestionQuery {
	query := (&IncidentDebriefSuggestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := node.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebrief.Table, incidentdebrief.FieldID, id),
			sqlgraph.To(incidentdebriefsuggestion.Table, incidentdebriefsuggestion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incidentdebrief.SuggestionsTable, incidentdebrief.SuggestionsColumn),
		)
		fromV = sqlgraph.Neighbors(node.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentDebriefClient) Hooks() []Hook {
	hooks := c.hooks.IncidentDebrief
	return append(hooks[:len(hooks):len(hooks)], incidentdebrief.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentDebriefClient) Interceptors() []Interceptor {
	return c.inters.IncidentDebrief
}

func (c *IncidentDebriefClient) mutate(ctx context.Context, m *IncidentDebriefMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentDebriefCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentDebriefUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentDebriefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentDebriefDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentDebrief mutation op: %q", m.Op())
	}
}

// IncidentDebriefMessageClient is a client for the IncidentDebriefMessage schema.
type IncidentDebriefMessageClient struct {
	config
}

// NewIncidentDebriefMessageClient returns a client for the IncidentDebriefMessage from the given config.
func NewIncidentDebriefMessageClient(c config) *IncidentDebriefMessageClient {
	return &IncidentDebriefMessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentdebriefmessage.Hooks(f(g(h())))`.
func (c *IncidentDebriefMessageClient) Use(hooks ...Hook) {
	c.hooks.IncidentDebriefMessage = append(c.hooks.IncidentDebriefMessage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentdebriefmessage.Intercept(f(g(h())))`.
func (c *IncidentDebriefMessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentDebriefMessage = append(c.inters.IncidentDebriefMessage, interceptors...)
}

// Create returns a builder for creating a IncidentDebriefMessage entity.
func (c *IncidentDebriefMessageClient) Create() *IncidentDebriefMessageCreate {
	mutation := newIncidentDebriefMessageMutation(c.config, OpCreate)
	return &IncidentDebriefMessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentDebriefMessage entities.
func (c *IncidentDebriefMessageClient) CreateBulk(builders ...*IncidentDebriefMessageCreate) *IncidentDebriefMessageCreateBulk {
	return &IncidentDebriefMessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentDebriefMessageClient) MapCreateBulk(slice any, setFunc func(*IncidentDebriefMessageCreate, int)) *IncidentDebriefMessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentDebriefMessageCreateBulk{err: fmt.Errorf("calling to IncidentDebriefMessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentDebriefMessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentDebriefMessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentDebriefMessage.
func (c *IncidentDebriefMessageClient) Update() *IncidentDebriefMessageUpdate {
	mutation := newIncidentDebriefMessageMutation(c.config, OpUpdate)
	return &IncidentDebriefMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentDebriefMessageClient) UpdateOne(idm *IncidentDebriefMessage) *IncidentDebriefMessageUpdateOne {
	mutation := newIncidentDebriefMessageMutation(c.config, OpUpdateOne, withIncidentDebriefMessage(idm))
	return &IncidentDebriefMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentDebriefMessageClient) UpdateOneID(id uuid.UUID) *IncidentDebriefMessageUpdateOne {
	mutation := newIncidentDebriefMessageMutation(c.config, OpUpdateOne, withIncidentDebriefMessageID(id))
	return &IncidentDebriefMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentDebriefMessage.
func (c *IncidentDebriefMessageClient) Delete() *IncidentDebriefMessageDelete {
	mutation := newIncidentDebriefMessageMutation(c.config, OpDelete)
	return &IncidentDebriefMessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentDebriefMessageClient) DeleteOne(idm *IncidentDebriefMessage) *IncidentDebriefMessageDeleteOne {
	return c.DeleteOneID(idm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentDebriefMessageClient) DeleteOneID(id uuid.UUID) *IncidentDebriefMessageDeleteOne {
	builder := c.Delete().Where(incidentdebriefmessage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentDebriefMessageDeleteOne{builder}
}

// Query returns a query builder for IncidentDebriefMessage.
func (c *IncidentDebriefMessageClient) Query() *IncidentDebriefMessageQuery {
	return &IncidentDebriefMessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentDebriefMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentDebriefMessage entity by its id.
func (c *IncidentDebriefMessageClient) Get(ctx context.Context, id uuid.UUID) (*IncidentDebriefMessage, error) {
	return c.Query().Where(incidentdebriefmessage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentDebriefMessageClient) GetX(ctx context.Context, id uuid.UUID) *IncidentDebriefMessage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDebrief queries the debrief edge of a IncidentDebriefMessage.
func (c *IncidentDebriefMessageClient) QueryDebrief(idm *IncidentDebriefMessage) *IncidentDebriefQuery {
	query := (&IncidentDebriefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefmessage.Table, incidentdebriefmessage.FieldID, id),
			sqlgraph.To(incidentdebrief.Table, incidentdebrief.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentdebriefmessage.DebriefTable, incidentdebriefmessage.DebriefColumn),
		)
		fromV = sqlgraph.Neighbors(idm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFromQuestion queries the from_question edge of a IncidentDebriefMessage.
func (c *IncidentDebriefMessageClient) QueryFromQuestion(idm *IncidentDebriefMessage) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefmessage.Table, incidentdebriefmessage.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentdebriefmessage.FromQuestionTable, incidentdebriefmessage.FromQuestionColumn),
		)
		fromV = sqlgraph.Neighbors(idm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentDebriefMessageClient) Hooks() []Hook {
	hooks := c.hooks.IncidentDebriefMessage
	return append(hooks[:len(hooks):len(hooks)], incidentdebriefmessage.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentDebriefMessageClient) Interceptors() []Interceptor {
	return c.inters.IncidentDebriefMessage
}

func (c *IncidentDebriefMessageClient) mutate(ctx context.Context, m *IncidentDebriefMessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentDebriefMessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentDebriefMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentDebriefMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentDebriefMessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentDebriefMessage mutation op: %q", m.Op())
	}
}

// IncidentDebriefQuestionClient is a client for the IncidentDebriefQuestion schema.
type IncidentDebriefQuestionClient struct {
	config
}

// NewIncidentDebriefQuestionClient returns a client for the IncidentDebriefQuestion from the given config.
func NewIncidentDebriefQuestionClient(c config) *IncidentDebriefQuestionClient {
	return &IncidentDebriefQuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentdebriefquestion.Hooks(f(g(h())))`.
func (c *IncidentDebriefQuestionClient) Use(hooks ...Hook) {
	c.hooks.IncidentDebriefQuestion = append(c.hooks.IncidentDebriefQuestion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentdebriefquestion.Intercept(f(g(h())))`.
func (c *IncidentDebriefQuestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentDebriefQuestion = append(c.inters.IncidentDebriefQuestion, interceptors...)
}

// Create returns a builder for creating a IncidentDebriefQuestion entity.
func (c *IncidentDebriefQuestionClient) Create() *IncidentDebriefQuestionCreate {
	mutation := newIncidentDebriefQuestionMutation(c.config, OpCreate)
	return &IncidentDebriefQuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentDebriefQuestion entities.
func (c *IncidentDebriefQuestionClient) CreateBulk(builders ...*IncidentDebriefQuestionCreate) *IncidentDebriefQuestionCreateBulk {
	return &IncidentDebriefQuestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentDebriefQuestionClient) MapCreateBulk(slice any, setFunc func(*IncidentDebriefQuestionCreate, int)) *IncidentDebriefQuestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentDebriefQuestionCreateBulk{err: fmt.Errorf("calling to IncidentDebriefQuestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentDebriefQuestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentDebriefQuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) Update() *IncidentDebriefQuestionUpdate {
	mutation := newIncidentDebriefQuestionMutation(c.config, OpUpdate)
	return &IncidentDebriefQuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentDebriefQuestionClient) UpdateOne(idq *IncidentDebriefQuestion) *IncidentDebriefQuestionUpdateOne {
	mutation := newIncidentDebriefQuestionMutation(c.config, OpUpdateOne, withIncidentDebriefQuestion(idq))
	return &IncidentDebriefQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentDebriefQuestionClient) UpdateOneID(id uuid.UUID) *IncidentDebriefQuestionUpdateOne {
	mutation := newIncidentDebriefQuestionMutation(c.config, OpUpdateOne, withIncidentDebriefQuestionID(id))
	return &IncidentDebriefQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) Delete() *IncidentDebriefQuestionDelete {
	mutation := newIncidentDebriefQuestionMutation(c.config, OpDelete)
	return &IncidentDebriefQuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentDebriefQuestionClient) DeleteOne(idq *IncidentDebriefQuestion) *IncidentDebriefQuestionDeleteOne {
	return c.DeleteOneID(idq.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentDebriefQuestionClient) DeleteOneID(id uuid.UUID) *IncidentDebriefQuestionDeleteOne {
	builder := c.Delete().Where(incidentdebriefquestion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentDebriefQuestionDeleteOne{builder}
}

// Query returns a query builder for IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) Query() *IncidentDebriefQuestionQuery {
	return &IncidentDebriefQuestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentDebriefQuestion},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentDebriefQuestion entity by its id.
func (c *IncidentDebriefQuestionClient) Get(ctx context.Context, id uuid.UUID) (*IncidentDebriefQuestion, error) {
	return c.Query().Where(incidentdebriefquestion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentDebriefQuestionClient) GetX(ctx context.Context, id uuid.UUID) *IncidentDebriefQuestion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMessages queries the messages edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryMessages(idq *IncidentDebriefQuestion) *IncidentDebriefMessageQuery {
	query := (&IncidentDebriefMessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidentdebriefmessage.Table, incidentdebriefmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incidentdebriefquestion.MessagesTable, incidentdebriefquestion.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentFields queries the incident_fields edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryIncidentFields(idq *IncidentDebriefQuestion) *IncidentFieldQuery {
	query := (&IncidentFieldClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidentfield.Table, incidentfield.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incidentdebriefquestion.IncidentFieldsTable, incidentdebriefquestion.IncidentFieldsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentRoles queries the incident_roles edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryIncidentRoles(idq *IncidentDebriefQuestion) *IncidentRoleQuery {
	query := (&IncidentRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidentrole.Table, incidentrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incidentdebriefquestion.IncidentRolesTable, incidentdebriefquestion.IncidentRolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentSeverities queries the incident_severities edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryIncidentSeverities(idq *IncidentDebriefQuestion) *IncidentSeverityQuery {
	query := (&IncidentSeverityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidentseverity.Table, incidentseverity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incidentdebriefquestion.IncidentSeveritiesTable, incidentdebriefquestion.IncidentSeveritiesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentTags queries the incident_tags edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryIncidentTags(idq *IncidentDebriefQuestion) *IncidentTagQuery {
	query := (&IncidentTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidenttag.Table, incidenttag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incidentdebriefquestion.IncidentTagsTable, incidentdebriefquestion.IncidentTagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentTypes queries the incident_types edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryIncidentTypes(idq *IncidentDebriefQuestion) *IncidentTypeQuery {
	query := (&IncidentTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidenttype.Table, incidenttype.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incidentdebriefquestion.IncidentTypesTable, incidentdebriefquestion.IncidentTypesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentDebriefQuestionClient) Hooks() []Hook {
	hooks := c.hooks.IncidentDebriefQuestion
	return append(hooks[:len(hooks):len(hooks)], incidentdebriefquestion.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentDebriefQuestionClient) Interceptors() []Interceptor {
	return c.inters.IncidentDebriefQuestion
}

func (c *IncidentDebriefQuestionClient) mutate(ctx context.Context, m *IncidentDebriefQuestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentDebriefQuestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentDebriefQuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentDebriefQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentDebriefQuestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentDebriefQuestion mutation op: %q", m.Op())
	}
}

// IncidentDebriefSuggestionClient is a client for the IncidentDebriefSuggestion schema.
type IncidentDebriefSuggestionClient struct {
	config
}

// NewIncidentDebriefSuggestionClient returns a client for the IncidentDebriefSuggestion from the given config.
func NewIncidentDebriefSuggestionClient(c config) *IncidentDebriefSuggestionClient {
	return &IncidentDebriefSuggestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentdebriefsuggestion.Hooks(f(g(h())))`.
func (c *IncidentDebriefSuggestionClient) Use(hooks ...Hook) {
	c.hooks.IncidentDebriefSuggestion = append(c.hooks.IncidentDebriefSuggestion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentdebriefsuggestion.Intercept(f(g(h())))`.
func (c *IncidentDebriefSuggestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentDebriefSuggestion = append(c.inters.IncidentDebriefSuggestion, interceptors...)
}

// Create returns a builder for creating a IncidentDebriefSuggestion entity.
func (c *IncidentDebriefSuggestionClient) Create() *IncidentDebriefSuggestionCreate {
	mutation := newIncidentDebriefSuggestionMutation(c.config, OpCreate)
	return &IncidentDebriefSuggestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentDebriefSuggestion entities.
func (c *IncidentDebriefSuggestionClient) CreateBulk(builders ...*IncidentDebriefSuggestionCreate) *IncidentDebriefSuggestionCreateBulk {
	return &IncidentDebriefSuggestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentDebriefSuggestionClient) MapCreateBulk(slice any, setFunc func(*IncidentDebriefSuggestionCreate, int)) *IncidentDebriefSuggestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentDebriefSuggestionCreateBulk{err: fmt.Errorf("calling to IncidentDebriefSuggestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentDebriefSuggestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentDebriefSuggestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentDebriefSuggestion.
func (c *IncidentDebriefSuggestionClient) Update() *IncidentDebriefSuggestionUpdate {
	mutation := newIncidentDebriefSuggestionMutation(c.config, OpUpdate)
	return &IncidentDebriefSuggestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentDebriefSuggestionClient) UpdateOne(ids *IncidentDebriefSuggestion) *IncidentDebriefSuggestionUpdateOne {
	mutation := newIncidentDebriefSuggestionMutation(c.config, OpUpdateOne, withIncidentDebriefSuggestion(ids))
	return &IncidentDebriefSuggestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentDebriefSuggestionClient) UpdateOneID(id uuid.UUID) *IncidentDebriefSuggestionUpdateOne {
	mutation := newIncidentDebriefSuggestionMutation(c.config, OpUpdateOne, withIncidentDebriefSuggestionID(id))
	return &IncidentDebriefSuggestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentDebriefSuggestion.
func (c *IncidentDebriefSuggestionClient) Delete() *IncidentDebriefSuggestionDelete {
	mutation := newIncidentDebriefSuggestionMutation(c.config, OpDelete)
	return &IncidentDebriefSuggestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentDebriefSuggestionClient) DeleteOne(ids *IncidentDebriefSuggestion) *IncidentDebriefSuggestionDeleteOne {
	return c.DeleteOneID(ids.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentDebriefSuggestionClient) DeleteOneID(id uuid.UUID) *IncidentDebriefSuggestionDeleteOne {
	builder := c.Delete().Where(incidentdebriefsuggestion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentDebriefSuggestionDeleteOne{builder}
}

// Query returns a query builder for IncidentDebriefSuggestion.
func (c *IncidentDebriefSuggestionClient) Query() *IncidentDebriefSuggestionQuery {
	return &IncidentDebriefSuggestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentDebriefSuggestion},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentDebriefSuggestion entity by its id.
func (c *IncidentDebriefSuggestionClient) Get(ctx context.Context, id uuid.UUID) (*IncidentDebriefSuggestion, error) {
	return c.Query().Where(incidentdebriefsuggestion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentDebriefSuggestionClient) GetX(ctx context.Context, id uuid.UUID) *IncidentDebriefSuggestion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDebrief queries the debrief edge of a IncidentDebriefSuggestion.
func (c *IncidentDebriefSuggestionClient) QueryDebrief(ids *IncidentDebriefSuggestion) *IncidentDebriefQuery {
	query := (&IncidentDebriefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ids.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefsuggestion.Table, incidentdebriefsuggestion.FieldID, id),
			sqlgraph.To(incidentdebrief.Table, incidentdebrief.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentdebriefsuggestion.DebriefTable, incidentdebriefsuggestion.DebriefColumn),
		)
		fromV = sqlgraph.Neighbors(ids.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentDebriefSuggestionClient) Hooks() []Hook {
	hooks := c.hooks.IncidentDebriefSuggestion
	return append(hooks[:len(hooks):len(hooks)], incidentdebriefsuggestion.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentDebriefSuggestionClient) Interceptors() []Interceptor {
	return c.inters.IncidentDebriefSuggestion
}

func (c *IncidentDebriefSuggestionClient) mutate(ctx context.Context, m *IncidentDebriefSuggestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentDebriefSuggestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentDebriefSuggestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentDebriefSuggestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentDebriefSuggestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentDebriefSuggestion mutation op: %q", m.Op())
	}
}

// IncidentEventClient is a client for the IncidentEvent schema.
type IncidentEventClient struct {
	config
}

// NewIncidentEventClient returns a client for the IncidentEvent from the given config.
func NewIncidentEventClient(c config) *IncidentEventClient {
	return &IncidentEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentevent.Hooks(f(g(h())))`.
func (c *IncidentEventClient) Use(hooks ...Hook) {
	c.hooks.IncidentEvent = append(c.hooks.IncidentEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentevent.Intercept(f(g(h())))`.
func (c *IncidentEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentEvent = append(c.inters.IncidentEvent, interceptors...)
}

// Create returns a builder for creating a IncidentEvent entity.
func (c *IncidentEventClient) Create() *IncidentEventCreate {
	mutation := newIncidentEventMutation(c.config, OpCreate)
	return &IncidentEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentEvent entities.
func (c *IncidentEventClient) CreateBulk(builders ...*IncidentEventCreate) *IncidentEventCreateBulk {
	return &IncidentEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentEventClient) MapCreateBulk(slice any, setFunc func(*IncidentEventCreate, int)) *IncidentEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentEventCreateBulk{err: fmt.Errorf("calling to IncidentEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentEvent.
func (c *IncidentEventClient) Update() *IncidentEventUpdate {
	mutation := newIncidentEventMutation(c.config, OpUpdate)
	return &IncidentEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentEventClient) UpdateOne(ie *IncidentEvent) *IncidentEventUpdateOne {
	mutation := newIncidentEventMutation(c.config, OpUpdateOne, withIncidentEvent(ie))
	return &IncidentEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentEventClient) UpdateOneID(id uuid.UUID) *IncidentEventUpdateOne {
	mutation := newIncidentEventMutation(c.config, OpUpdateOne, withIncidentEventID(id))
	return &IncidentEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentEvent.
func (c *IncidentEventClient) Delete() *IncidentEventDelete {
	mutation := newIncidentEventMutation(c.config, OpDelete)
	return &IncidentEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentEventClient) DeleteOne(ie *IncidentEvent) *IncidentEventDeleteOne {
	return c.DeleteOneID(ie.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentEventClient) DeleteOneID(id uuid.UUID) *IncidentEventDeleteOne {
	builder := c.Delete().Where(incidentevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentEventDeleteOne{builder}
}

// Query returns a query builder for IncidentEvent.
func (c *IncidentEventClient) Query() *IncidentEventQuery {
	return &IncidentEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentEvent entity by its id.
func (c *IncidentEventClient) Get(ctx context.Context, id uuid.UUID) (*IncidentEvent, error) {
	return c.Query().Where(incidentevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentEventClient) GetX(ctx context.Context, id uuid.UUID) *IncidentEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a IncidentEvent.
func (c *IncidentEventClient) QueryIncident(ie *IncidentEvent) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ie.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentevent.Table, incidentevent.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentevent.IncidentTable, incidentevent.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(ie.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContext queries the context edge of a IncidentEvent.
func (c *IncidentEventClient) QueryContext(ie *IncidentEvent) *IncidentEventContextQuery {
	query := (&IncidentEventContextClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ie.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentevent.Table, incidentevent.FieldID, id),
			sqlgraph.To(incidenteventcontext.Table, incidenteventcontext.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, incidentevent.ContextTable, incidentevent.ContextColumn),
		)
		fromV = sqlgraph.Neighbors(ie.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFactors queries the factors edge of a IncidentEvent.
func (c *IncidentEventClient) QueryFactors(ie *IncidentEvent) *IncidentEventContributingFactorQuery {
	query := (&IncidentEventContributingFactorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ie.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentevent.Table, incidentevent.FieldID, id),
			sqlgraph.To(incidenteventcontributingfactor.Table, incidenteventcontributingfactor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incidentevent.FactorsTable, incidentevent.FactorsColumn),
		)
		fromV = sqlgraph.Neighbors(ie.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvidence queries the evidence edge of a IncidentEvent.
func (c *IncidentEventClient) QueryEvidence(ie *IncidentEvent) *IncidentEventEvidenceQuery {
	query := (&IncidentEventEvidenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ie.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentevent.Table, incidentevent.FieldID, id),
			sqlgraph.To(incidenteventevidence.Table, incidenteventevidence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incidentevent.EvidenceTable, incidentevent.EvidenceColumn),
		)
		fromV = sqlgraph.Neighbors(ie.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySystemComponents queries the system_components edge of a IncidentEvent.
func (c *IncidentEventClient) QuerySystemComponents(ie *IncidentEvent) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ie.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentevent.Table, incidentevent.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incidentevent.SystemComponentsTable, incidentevent.SystemComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ie.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventComponents queries the event_components edge of a IncidentEvent.
func (c *IncidentEventClient) QueryEventComponents(ie *IncidentEvent) *IncidentEventSystemComponentQuery {
	query := (&IncidentEventSystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ie.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentevent.Table, incidentevent.FieldID, id),
			sqlgraph.To(incidenteventsystemcomponent.Table, incidenteventsystemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incidentevent.EventComponentsTable, incidentevent.EventComponentsColumn),
		)
		fromV = sqlgraph.Neighbors(ie.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentEventClient) Hooks() []Hook {
	hooks := c.hooks.IncidentEvent
	return append(hooks[:len(hooks):len(hooks)], incidentevent.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentEventClient) Interceptors() []Interceptor {
	return c.inters.IncidentEvent
}

func (c *IncidentEventClient) mutate(ctx context.Context, m *IncidentEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentEvent mutation op: %q", m.Op())
	}
}

// IncidentEventContextClient is a client for the IncidentEventContext schema.
type IncidentEventContextClient struct {
	config
}

// NewIncidentEventContextClient returns a client for the IncidentEventContext from the given config.
func NewIncidentEventContextClient(c config) *IncidentEventContextClient {
	return &IncidentEventContextClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidenteventcontext.Hooks(f(g(h())))`.
func (c *IncidentEventContextClient) Use(hooks ...Hook) {
	c.hooks.IncidentEventContext = append(c.hooks.IncidentEventContext, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidenteventcontext.Intercept(f(g(h())))`.
func (c *IncidentEventContextClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentEventContext = append(c.inters.IncidentEventContext, interceptors...)
}

// Create returns a builder for creating a IncidentEventContext entity.
func (c *IncidentEventContextClient) Create() *IncidentEventContextCreate {
	mutation := newIncidentEventContextMutation(c.config, OpCreate)
	return &IncidentEventContextCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentEventContext entities.
func (c *IncidentEventContextClient) CreateBulk(builders ...*IncidentEventContextCreate) *IncidentEventContextCreateBulk {
	return &IncidentEventContextCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentEventContextClient) MapCreateBulk(slice any, setFunc func(*IncidentEventContextCreate, int)) *IncidentEventContextCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentEventContextCreateBulk{err: fmt.Errorf("calling to IncidentEventContextClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentEventContextCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentEventContextCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentEventContext.
func (c *IncidentEventContextClient) Update() *IncidentEventContextUpdate {
	mutation := newIncidentEventContextMutation(c.config, OpUpdate)
	return &IncidentEventContextUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentEventContextClient) UpdateOne(iec *IncidentEventContext) *IncidentEventContextUpdateOne {
	mutation := newIncidentEventContextMutation(c.config, OpUpdateOne, withIncidentEventContext(iec))
	return &IncidentEventContextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentEventContextClient) UpdateOneID(id uuid.UUID) *IncidentEventContextUpdateOne {
	mutation := newIncidentEventContextMutation(c.config, OpUpdateOne, withIncidentEventContextID(id))
	return &IncidentEventContextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentEventContext.
func (c *IncidentEventContextClient) Delete() *IncidentEventContextDelete {
	mutation := newIncidentEventContextMutation(c.config, OpDelete)
	return &IncidentEventContextDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentEventContextClient) DeleteOne(iec *IncidentEventContext) *IncidentEventContextDeleteOne {
	return c.DeleteOneID(iec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentEventContextClient) DeleteOneID(id uuid.UUID) *IncidentEventContextDeleteOne {
	builder := c.Delete().Where(incidenteventcontext.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentEventContextDeleteOne{builder}
}

// Query returns a query builder for IncidentEventContext.
func (c *IncidentEventContextClient) Query() *IncidentEventContextQuery {
	return &IncidentEventContextQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentEventContext},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentEventContext entity by its id.
func (c *IncidentEventContextClient) Get(ctx context.Context, id uuid.UUID) (*IncidentEventContext, error) {
	return c.Query().Where(incidenteventcontext.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentEventContextClient) GetX(ctx context.Context, id uuid.UUID) *IncidentEventContext {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a IncidentEventContext.
func (c *IncidentEventContextClient) QueryEvent(iec *IncidentEventContext) *IncidentEventQuery {
	query := (&IncidentEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenteventcontext.Table, incidenteventcontext.FieldID, id),
			sqlgraph.To(incidentevent.Table, incidentevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, incidenteventcontext.EventTable, incidenteventcontext.EventColumn),
		)
		fromV = sqlgraph.Neighbors(iec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentEventContextClient) Hooks() []Hook {
	hooks := c.hooks.IncidentEventContext
	return append(hooks[:len(hooks):len(hooks)], incidenteventcontext.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentEventContextClient) Interceptors() []Interceptor {
	return c.inters.IncidentEventContext
}

func (c *IncidentEventContextClient) mutate(ctx context.Context, m *IncidentEventContextMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentEventContextCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentEventContextUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentEventContextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentEventContextDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentEventContext mutation op: %q", m.Op())
	}
}

// IncidentEventContributingFactorClient is a client for the IncidentEventContributingFactor schema.
type IncidentEventContributingFactorClient struct {
	config
}

// NewIncidentEventContributingFactorClient returns a client for the IncidentEventContributingFactor from the given config.
func NewIncidentEventContributingFactorClient(c config) *IncidentEventContributingFactorClient {
	return &IncidentEventContributingFactorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidenteventcontributingfactor.Hooks(f(g(h())))`.
func (c *IncidentEventContributingFactorClient) Use(hooks ...Hook) {
	c.hooks.IncidentEventContributingFactor = append(c.hooks.IncidentEventContributingFactor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidenteventcontributingfactor.Intercept(f(g(h())))`.
func (c *IncidentEventContributingFactorClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentEventContributingFactor = append(c.inters.IncidentEventContributingFactor, interceptors...)
}

// Create returns a builder for creating a IncidentEventContributingFactor entity.
func (c *IncidentEventContributingFactorClient) Create() *IncidentEventContributingFactorCreate {
	mutation := newIncidentEventContributingFactorMutation(c.config, OpCreate)
	return &IncidentEventContributingFactorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentEventContributingFactor entities.
func (c *IncidentEventContributingFactorClient) CreateBulk(builders ...*IncidentEventContributingFactorCreate) *IncidentEventContributingFactorCreateBulk {
	return &IncidentEventContributingFactorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentEventContributingFactorClient) MapCreateBulk(slice any, setFunc func(*IncidentEventContributingFactorCreate, int)) *IncidentEventContributingFactorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentEventContributingFactorCreateBulk{err: fmt.Errorf("calling to IncidentEventContributingFactorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentEventContributingFactorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentEventContributingFactorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentEventContributingFactor.
func (c *IncidentEventContributingFactorClient) Update() *IncidentEventContributingFactorUpdate {
	mutation := newIncidentEventContributingFactorMutation(c.config, OpUpdate)
	return &IncidentEventContributingFactorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentEventContributingFactorClient) UpdateOne(iecf *IncidentEventContributingFactor) *IncidentEventContributingFactorUpdateOne {
	mutation := newIncidentEventContributingFactorMutation(c.config, OpUpdateOne, withIncidentEventContributingFactor(iecf))
	return &IncidentEventContributingFactorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentEventContributingFactorClient) UpdateOneID(id uuid.UUID) *IncidentEventContributingFactorUpdateOne {
	mutation := newIncidentEventContributingFactorMutation(c.config, OpUpdateOne, withIncidentEventContributingFactorID(id))
	return &IncidentEventContributingFactorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentEventContributingFactor.
func (c *IncidentEventContributingFactorClient) Delete() *IncidentEventContributingFactorDelete {
	mutation := newIncidentEventContributingFactorMutation(c.config, OpDelete)
	return &IncidentEventContributingFactorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentEventContributingFactorClient) DeleteOne(iecf *IncidentEventContributingFactor) *IncidentEventContributingFactorDeleteOne {
	return c.DeleteOneID(iecf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentEventContributingFactorClient) DeleteOneID(id uuid.UUID) *IncidentEventContributingFactorDeleteOne {
	builder := c.Delete().Where(incidenteventcontributingfactor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentEventContributingFactorDeleteOne{builder}
}

// Query returns a query builder for IncidentEventContributingFactor.
func (c *IncidentEventContributingFactorClient) Query() *IncidentEventContributingFactorQuery {
	return &IncidentEventContributingFactorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentEventContributingFactor},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentEventContributingFactor entity by its id.
func (c *IncidentEventContributingFactorClient) Get(ctx context.Context, id uuid.UUID) (*IncidentEventContributingFactor, error) {
	return c.Query().Where(incidenteventcontributingfactor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentEventContributingFactorClient) GetX(ctx context.Context, id uuid.UUID) *IncidentEventContributingFactor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a IncidentEventContributingFactor.
func (c *IncidentEventContributingFactorClient) QueryEvent(iecf *IncidentEventContributingFactor) *IncidentEventQuery {
	query := (&IncidentEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iecf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenteventcontributingfactor.Table, incidenteventcontributingfactor.FieldID, id),
			sqlgraph.To(incidentevent.Table, incidentevent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidenteventcontributingfactor.EventTable, incidenteventcontributingfactor.EventColumn),
		)
		fromV = sqlgraph.Neighbors(iecf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentEventContributingFactorClient) Hooks() []Hook {
	hooks := c.hooks.IncidentEventContributingFactor
	return append(hooks[:len(hooks):len(hooks)], incidenteventcontributingfactor.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentEventContributingFactorClient) Interceptors() []Interceptor {
	return c.inters.IncidentEventContributingFactor
}

func (c *IncidentEventContributingFactorClient) mutate(ctx context.Context, m *IncidentEventContributingFactorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentEventContributingFactorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentEventContributingFactorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentEventContributingFactorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentEventContributingFactorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentEventContributingFactor mutation op: %q", m.Op())
	}
}

// IncidentEventEvidenceClient is a client for the IncidentEventEvidence schema.
type IncidentEventEvidenceClient struct {
	config
}

// NewIncidentEventEvidenceClient returns a client for the IncidentEventEvidence from the given config.
func NewIncidentEventEvidenceClient(c config) *IncidentEventEvidenceClient {
	return &IncidentEventEvidenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidenteventevidence.Hooks(f(g(h())))`.
func (c *IncidentEventEvidenceClient) Use(hooks ...Hook) {
	c.hooks.IncidentEventEvidence = append(c.hooks.IncidentEventEvidence, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidenteventevidence.Intercept(f(g(h())))`.
func (c *IncidentEventEvidenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentEventEvidence = append(c.inters.IncidentEventEvidence, interceptors...)
}

// Create returns a builder for creating a IncidentEventEvidence entity.
func (c *IncidentEventEvidenceClient) Create() *IncidentEventEvidenceCreate {
	mutation := newIncidentEventEvidenceMutation(c.config, OpCreate)
	return &IncidentEventEvidenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentEventEvidence entities.
func (c *IncidentEventEvidenceClient) CreateBulk(builders ...*IncidentEventEvidenceCreate) *IncidentEventEvidenceCreateBulk {
	return &IncidentEventEvidenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentEventEvidenceClient) MapCreateBulk(slice any, setFunc func(*IncidentEventEvidenceCreate, int)) *IncidentEventEvidenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentEventEvidenceCreateBulk{err: fmt.Errorf("calling to IncidentEventEvidenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentEventEvidenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentEventEvidenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentEventEvidence.
func (c *IncidentEventEvidenceClient) Update() *IncidentEventEvidenceUpdate {
	mutation := newIncidentEventEvidenceMutation(c.config, OpUpdate)
	return &IncidentEventEvidenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentEventEvidenceClient) UpdateOne(iee *IncidentEventEvidence) *IncidentEventEvidenceUpdateOne {
	mutation := newIncidentEventEvidenceMutation(c.config, OpUpdateOne, withIncidentEventEvidence(iee))
	return &IncidentEventEvidenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentEventEvidenceClient) UpdateOneID(id uuid.UUID) *IncidentEventEvidenceUpdateOne {
	mutation := newIncidentEventEvidenceMutation(c.config, OpUpdateOne, withIncidentEventEvidenceID(id))
	return &IncidentEventEvidenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentEventEvidence.
func (c *IncidentEventEvidenceClient) Delete() *IncidentEventEvidenceDelete {
	mutation := newIncidentEventEvidenceMutation(c.config, OpDelete)
	return &IncidentEventEvidenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentEventEvidenceClient) DeleteOne(iee *IncidentEventEvidence) *IncidentEventEvidenceDeleteOne {
	return c.DeleteOneID(iee.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentEventEvidenceClient) DeleteOneID(id uuid.UUID) *IncidentEventEvidenceDeleteOne {
	builder := c.Delete().Where(incidenteventevidence.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentEventEvidenceDeleteOne{builder}
}

// Query returns a query builder for IncidentEventEvidence.
func (c *IncidentEventEvidenceClient) Query() *IncidentEventEvidenceQuery {
	return &IncidentEventEvidenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentEventEvidence},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentEventEvidence entity by its id.
func (c *IncidentEventEvidenceClient) Get(ctx context.Context, id uuid.UUID) (*IncidentEventEvidence, error) {
	return c.Query().Where(incidenteventevidence.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentEventEvidenceClient) GetX(ctx context.Context, id uuid.UUID) *IncidentEventEvidence {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a IncidentEventEvidence.
func (c *IncidentEventEvidenceClient) QueryEvent(iee *IncidentEventEvidence) *IncidentEventQuery {
	query := (&IncidentEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iee.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenteventevidence.Table, incidenteventevidence.FieldID, id),
			sqlgraph.To(incidentevent.Table, incidentevent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidenteventevidence.EventTable, incidenteventevidence.EventColumn),
		)
		fromV = sqlgraph.Neighbors(iee.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentEventEvidenceClient) Hooks() []Hook {
	hooks := c.hooks.IncidentEventEvidence
	return append(hooks[:len(hooks):len(hooks)], incidenteventevidence.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentEventEvidenceClient) Interceptors() []Interceptor {
	return c.inters.IncidentEventEvidence
}

func (c *IncidentEventEvidenceClient) mutate(ctx context.Context, m *IncidentEventEvidenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentEventEvidenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentEventEvidenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentEventEvidenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentEventEvidenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentEventEvidence mutation op: %q", m.Op())
	}
}

// IncidentEventSystemComponentClient is a client for the IncidentEventSystemComponent schema.
type IncidentEventSystemComponentClient struct {
	config
}

// NewIncidentEventSystemComponentClient returns a client for the IncidentEventSystemComponent from the given config.
func NewIncidentEventSystemComponentClient(c config) *IncidentEventSystemComponentClient {
	return &IncidentEventSystemComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidenteventsystemcomponent.Hooks(f(g(h())))`.
func (c *IncidentEventSystemComponentClient) Use(hooks ...Hook) {
	c.hooks.IncidentEventSystemComponent = append(c.hooks.IncidentEventSystemComponent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidenteventsystemcomponent.Intercept(f(g(h())))`.
func (c *IncidentEventSystemComponentClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentEventSystemComponent = append(c.inters.IncidentEventSystemComponent, interceptors...)
}

// Create returns a builder for creating a IncidentEventSystemComponent entity.
func (c *IncidentEventSystemComponentClient) Create() *IncidentEventSystemComponentCreate {
	mutation := newIncidentEventSystemComponentMutation(c.config, OpCreate)
	return &IncidentEventSystemComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentEventSystemComponent entities.
func (c *IncidentEventSystemComponentClient) CreateBulk(builders ...*IncidentEventSystemComponentCreate) *IncidentEventSystemComponentCreateBulk {
	return &IncidentEventSystemComponentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentEventSystemComponentClient) MapCreateBulk(slice any, setFunc func(*IncidentEventSystemComponentCreate, int)) *IncidentEventSystemComponentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentEventSystemComponentCreateBulk{err: fmt.Errorf("calling to IncidentEventSystemComponentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentEventSystemComponentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentEventSystemComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentEventSystemComponent.
func (c *IncidentEventSystemComponentClient) Update() *IncidentEventSystemComponentUpdate {
	mutation := newIncidentEventSystemComponentMutation(c.config, OpUpdate)
	return &IncidentEventSystemComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentEventSystemComponentClient) UpdateOne(iesc *IncidentEventSystemComponent) *IncidentEventSystemComponentUpdateOne {
	mutation := newIncidentEventSystemComponentMutation(c.config, OpUpdateOne, withIncidentEventSystemComponent(iesc))
	return &IncidentEventSystemComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentEventSystemComponentClient) UpdateOneID(id uuid.UUID) *IncidentEventSystemComponentUpdateOne {
	mutation := newIncidentEventSystemComponentMutation(c.config, OpUpdateOne, withIncidentEventSystemComponentID(id))
	return &IncidentEventSystemComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentEventSystemComponent.
func (c *IncidentEventSystemComponentClient) Delete() *IncidentEventSystemComponentDelete {
	mutation := newIncidentEventSystemComponentMutation(c.config, OpDelete)
	return &IncidentEventSystemComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentEventSystemComponentClient) DeleteOne(iesc *IncidentEventSystemComponent) *IncidentEventSystemComponentDeleteOne {
	return c.DeleteOneID(iesc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentEventSystemComponentClient) DeleteOneID(id uuid.UUID) *IncidentEventSystemComponentDeleteOne {
	builder := c.Delete().Where(incidenteventsystemcomponent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentEventSystemComponentDeleteOne{builder}
}

// Query returns a query builder for IncidentEventSystemComponent.
func (c *IncidentEventSystemComponentClient) Query() *IncidentEventSystemComponentQuery {
	return &IncidentEventSystemComponentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentEventSystemComponent},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentEventSystemComponent entity by its id.
func (c *IncidentEventSystemComponentClient) Get(ctx context.Context, id uuid.UUID) (*IncidentEventSystemComponent, error) {
	return c.Query().Where(incidenteventsystemcomponent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentEventSystemComponentClient) GetX(ctx context.Context, id uuid.UUID) *IncidentEventSystemComponent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a IncidentEventSystemComponent.
func (c *IncidentEventSystemComponentClient) QueryEvent(iesc *IncidentEventSystemComponent) *IncidentEventSystemComponentQuery {
	query := (&IncidentEventSystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iesc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenteventsystemcomponent.Table, incidenteventsystemcomponent.FieldID, id),
			sqlgraph.To(incidenteventsystemcomponent.Table, incidenteventsystemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, incidenteventsystemcomponent.EventTable, incidenteventsystemcomponent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(iesc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySystemComponent queries the system_component edge of a IncidentEventSystemComponent.
func (c *IncidentEventSystemComponentClient) QuerySystemComponent(iesc *IncidentEventSystemComponent) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iesc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenteventsystemcomponent.Table, incidenteventsystemcomponent.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidenteventsystemcomponent.SystemComponentTable, incidenteventsystemcomponent.SystemComponentColumn),
		)
		fromV = sqlgraph.Neighbors(iesc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentEventSystemComponentClient) Hooks() []Hook {
	hooks := c.hooks.IncidentEventSystemComponent
	return append(hooks[:len(hooks):len(hooks)], incidenteventsystemcomponent.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentEventSystemComponentClient) Interceptors() []Interceptor {
	return c.inters.IncidentEventSystemComponent
}

func (c *IncidentEventSystemComponentClient) mutate(ctx context.Context, m *IncidentEventSystemComponentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentEventSystemComponentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentEventSystemComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentEventSystemComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentEventSystemComponentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentEventSystemComponent mutation op: %q", m.Op())
	}
}

// IncidentFieldClient is a client for the IncidentField schema.
type IncidentFieldClient struct {
	config
}

// NewIncidentFieldClient returns a client for the IncidentField from the given config.
func NewIncidentFieldClient(c config) *IncidentFieldClient {
	return &IncidentFieldClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentfield.Hooks(f(g(h())))`.
func (c *IncidentFieldClient) Use(hooks ...Hook) {
	c.hooks.IncidentField = append(c.hooks.IncidentField, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentfield.Intercept(f(g(h())))`.
func (c *IncidentFieldClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentField = append(c.inters.IncidentField, interceptors...)
}

// Create returns a builder for creating a IncidentField entity.
func (c *IncidentFieldClient) Create() *IncidentFieldCreate {
	mutation := newIncidentFieldMutation(c.config, OpCreate)
	return &IncidentFieldCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentField entities.
func (c *IncidentFieldClient) CreateBulk(builders ...*IncidentFieldCreate) *IncidentFieldCreateBulk {
	return &IncidentFieldCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentFieldClient) MapCreateBulk(slice any, setFunc func(*IncidentFieldCreate, int)) *IncidentFieldCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentFieldCreateBulk{err: fmt.Errorf("calling to IncidentFieldClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentFieldCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentFieldCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentField.
func (c *IncidentFieldClient) Update() *IncidentFieldUpdate {
	mutation := newIncidentFieldMutation(c.config, OpUpdate)
	return &IncidentFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentFieldClient) UpdateOne(_if *IncidentField) *IncidentFieldUpdateOne {
	mutation := newIncidentFieldMutation(c.config, OpUpdateOne, withIncidentField(_if))
	return &IncidentFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentFieldClient) UpdateOneID(id uuid.UUID) *IncidentFieldUpdateOne {
	mutation := newIncidentFieldMutation(c.config, OpUpdateOne, withIncidentFieldID(id))
	return &IncidentFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentField.
func (c *IncidentFieldClient) Delete() *IncidentFieldDelete {
	mutation := newIncidentFieldMutation(c.config, OpDelete)
	return &IncidentFieldDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentFieldClient) DeleteOne(_if *IncidentField) *IncidentFieldDeleteOne {
	return c.DeleteOneID(_if.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentFieldClient) DeleteOneID(id uuid.UUID) *IncidentFieldDeleteOne {
	builder := c.Delete().Where(incidentfield.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentFieldDeleteOne{builder}
}

// Query returns a query builder for IncidentField.
func (c *IncidentFieldClient) Query() *IncidentFieldQuery {
	return &IncidentFieldQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentField},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentField entity by its id.
func (c *IncidentFieldClient) Get(ctx context.Context, id uuid.UUID) (*IncidentField, error) {
	return c.Query().Where(incidentfield.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentFieldClient) GetX(ctx context.Context, id uuid.UUID) *IncidentField {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOptions queries the options edge of a IncidentField.
func (c *IncidentFieldClient) QueryOptions(_if *IncidentField) *IncidentFieldOptionQuery {
	query := (&IncidentFieldOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _if.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentfield.Table, incidentfield.FieldID, id),
			sqlgraph.To(incidentfieldoption.Table, incidentfieldoption.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incidentfield.OptionsTable, incidentfield.OptionsColumn),
		)
		fromV = sqlgraph.Neighbors(_if.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefQuestions queries the debrief_questions edge of a IncidentField.
func (c *IncidentFieldClient) QueryDebriefQuestions(_if *IncidentField) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _if.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentfield.Table, incidentfield.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidentfield.DebriefQuestionsTable, incidentfield.DebriefQuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_if.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentFieldClient) Hooks() []Hook {
	hooks := c.hooks.IncidentField
	return append(hooks[:len(hooks):len(hooks)], incidentfield.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentFieldClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentField
	return append(inters[:len(inters):len(inters)], incidentfield.Interceptors[:]...)
}

func (c *IncidentFieldClient) mutate(ctx context.Context, m *IncidentFieldMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentFieldCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentFieldDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentField mutation op: %q", m.Op())
	}
}

// IncidentFieldOptionClient is a client for the IncidentFieldOption schema.
type IncidentFieldOptionClient struct {
	config
}

// NewIncidentFieldOptionClient returns a client for the IncidentFieldOption from the given config.
func NewIncidentFieldOptionClient(c config) *IncidentFieldOptionClient {
	return &IncidentFieldOptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentfieldoption.Hooks(f(g(h())))`.
func (c *IncidentFieldOptionClient) Use(hooks ...Hook) {
	c.hooks.IncidentFieldOption = append(c.hooks.IncidentFieldOption, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentfieldoption.Intercept(f(g(h())))`.
func (c *IncidentFieldOptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentFieldOption = append(c.inters.IncidentFieldOption, interceptors...)
}

// Create returns a builder for creating a IncidentFieldOption entity.
func (c *IncidentFieldOptionClient) Create() *IncidentFieldOptionCreate {
	mutation := newIncidentFieldOptionMutation(c.config, OpCreate)
	return &IncidentFieldOptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentFieldOption entities.
func (c *IncidentFieldOptionClient) CreateBulk(builders ...*IncidentFieldOptionCreate) *IncidentFieldOptionCreateBulk {
	return &IncidentFieldOptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentFieldOptionClient) MapCreateBulk(slice any, setFunc func(*IncidentFieldOptionCreate, int)) *IncidentFieldOptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentFieldOptionCreateBulk{err: fmt.Errorf("calling to IncidentFieldOptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentFieldOptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentFieldOptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentFieldOption.
func (c *IncidentFieldOptionClient) Update() *IncidentFieldOptionUpdate {
	mutation := newIncidentFieldOptionMutation(c.config, OpUpdate)
	return &IncidentFieldOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentFieldOptionClient) UpdateOne(ifo *IncidentFieldOption) *IncidentFieldOptionUpdateOne {
	mutation := newIncidentFieldOptionMutation(c.config, OpUpdateOne, withIncidentFieldOption(ifo))
	return &IncidentFieldOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentFieldOptionClient) UpdateOneID(id uuid.UUID) *IncidentFieldOptionUpdateOne {
	mutation := newIncidentFieldOptionMutation(c.config, OpUpdateOne, withIncidentFieldOptionID(id))
	return &IncidentFieldOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentFieldOption.
func (c *IncidentFieldOptionClient) Delete() *IncidentFieldOptionDelete {
	mutation := newIncidentFieldOptionMutation(c.config, OpDelete)
	return &IncidentFieldOptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentFieldOptionClient) DeleteOne(ifo *IncidentFieldOption) *IncidentFieldOptionDeleteOne {
	return c.DeleteOneID(ifo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentFieldOptionClient) DeleteOneID(id uuid.UUID) *IncidentFieldOptionDeleteOne {
	builder := c.Delete().Where(incidentfieldoption.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentFieldOptionDeleteOne{builder}
}

// Query returns a query builder for IncidentFieldOption.
func (c *IncidentFieldOptionClient) Query() *IncidentFieldOptionQuery {
	return &IncidentFieldOptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentFieldOption},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentFieldOption entity by its id.
func (c *IncidentFieldOptionClient) Get(ctx context.Context, id uuid.UUID) (*IncidentFieldOption, error) {
	return c.Query().Where(incidentfieldoption.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentFieldOptionClient) GetX(ctx context.Context, id uuid.UUID) *IncidentFieldOption {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidentField queries the incident_field edge of a IncidentFieldOption.
func (c *IncidentFieldOptionClient) QueryIncidentField(ifo *IncidentFieldOption) *IncidentFieldQuery {
	query := (&IncidentFieldClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ifo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentfieldoption.Table, incidentfieldoption.FieldID, id),
			sqlgraph.To(incidentfield.Table, incidentfield.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentfieldoption.IncidentFieldTable, incidentfieldoption.IncidentFieldColumn),
		)
		fromV = sqlgraph.Neighbors(ifo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidents queries the incidents edge of a IncidentFieldOption.
func (c *IncidentFieldOptionClient) QueryIncidents(ifo *IncidentFieldOption) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ifo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentfieldoption.Table, incidentfieldoption.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidentfieldoption.IncidentsTable, incidentfieldoption.IncidentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ifo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentFieldOptionClient) Hooks() []Hook {
	hooks := c.hooks.IncidentFieldOption
	return append(hooks[:len(hooks):len(hooks)], incidentfieldoption.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentFieldOptionClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentFieldOption
	return append(inters[:len(inters):len(inters)], incidentfieldoption.Interceptors[:]...)
}

func (c *IncidentFieldOptionClient) mutate(ctx context.Context, m *IncidentFieldOptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentFieldOptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentFieldOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentFieldOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentFieldOptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentFieldOption mutation op: %q", m.Op())
	}
}

// IncidentLinkClient is a client for the IncidentLink schema.
type IncidentLinkClient struct {
	config
}

// NewIncidentLinkClient returns a client for the IncidentLink from the given config.
func NewIncidentLinkClient(c config) *IncidentLinkClient {
	return &IncidentLinkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentlink.Hooks(f(g(h())))`.
func (c *IncidentLinkClient) Use(hooks ...Hook) {
	c.hooks.IncidentLink = append(c.hooks.IncidentLink, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentlink.Intercept(f(g(h())))`.
func (c *IncidentLinkClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentLink = append(c.inters.IncidentLink, interceptors...)
}

// Create returns a builder for creating a IncidentLink entity.
func (c *IncidentLinkClient) Create() *IncidentLinkCreate {
	mutation := newIncidentLinkMutation(c.config, OpCreate)
	return &IncidentLinkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentLink entities.
func (c *IncidentLinkClient) CreateBulk(builders ...*IncidentLinkCreate) *IncidentLinkCreateBulk {
	return &IncidentLinkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentLinkClient) MapCreateBulk(slice any, setFunc func(*IncidentLinkCreate, int)) *IncidentLinkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentLinkCreateBulk{err: fmt.Errorf("calling to IncidentLinkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentLinkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentLinkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentLink.
func (c *IncidentLinkClient) Update() *IncidentLinkUpdate {
	mutation := newIncidentLinkMutation(c.config, OpUpdate)
	return &IncidentLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentLinkClient) UpdateOne(il *IncidentLink) *IncidentLinkUpdateOne {
	mutation := newIncidentLinkMutation(c.config, OpUpdateOne, withIncidentLink(il))
	return &IncidentLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentLinkClient) UpdateOneID(id int) *IncidentLinkUpdateOne {
	mutation := newIncidentLinkMutation(c.config, OpUpdateOne, withIncidentLinkID(id))
	return &IncidentLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentLink.
func (c *IncidentLinkClient) Delete() *IncidentLinkDelete {
	mutation := newIncidentLinkMutation(c.config, OpDelete)
	return &IncidentLinkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentLinkClient) DeleteOne(il *IncidentLink) *IncidentLinkDeleteOne {
	return c.DeleteOneID(il.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentLinkClient) DeleteOneID(id int) *IncidentLinkDeleteOne {
	builder := c.Delete().Where(incidentlink.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentLinkDeleteOne{builder}
}

// Query returns a query builder for IncidentLink.
func (c *IncidentLinkClient) Query() *IncidentLinkQuery {
	return &IncidentLinkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentLink},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentLink entity by its id.
func (c *IncidentLinkClient) Get(ctx context.Context, id int) (*IncidentLink, error) {
	return c.Query().Where(incidentlink.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentLinkClient) GetX(ctx context.Context, id int) *IncidentLink {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a IncidentLink.
func (c *IncidentLinkClient) QueryIncident(il *IncidentLink) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := il.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentlink.Table, incidentlink.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentlink.IncidentTable, incidentlink.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(il.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLinkedIncident queries the linked_incident edge of a IncidentLink.
func (c *IncidentLinkClient) QueryLinkedIncident(il *IncidentLink) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := il.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentlink.Table, incidentlink.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentlink.LinkedIncidentTable, incidentlink.LinkedIncidentColumn),
		)
		fromV = sqlgraph.Neighbors(il.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentLinkClient) Hooks() []Hook {
	hooks := c.hooks.IncidentLink
	return append(hooks[:len(hooks):len(hooks)], incidentlink.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentLinkClient) Interceptors() []Interceptor {
	return c.inters.IncidentLink
}

func (c *IncidentLinkClient) mutate(ctx context.Context, m *IncidentLinkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentLinkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentLinkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentLink mutation op: %q", m.Op())
	}
}

// IncidentMilestoneClient is a client for the IncidentMilestone schema.
type IncidentMilestoneClient struct {
	config
}

// NewIncidentMilestoneClient returns a client for the IncidentMilestone from the given config.
func NewIncidentMilestoneClient(c config) *IncidentMilestoneClient {
	return &IncidentMilestoneClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentmilestone.Hooks(f(g(h())))`.
func (c *IncidentMilestoneClient) Use(hooks ...Hook) {
	c.hooks.IncidentMilestone = append(c.hooks.IncidentMilestone, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentmilestone.Intercept(f(g(h())))`.
func (c *IncidentMilestoneClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentMilestone = append(c.inters.IncidentMilestone, interceptors...)
}

// Create returns a builder for creating a IncidentMilestone entity.
func (c *IncidentMilestoneClient) Create() *IncidentMilestoneCreate {
	mutation := newIncidentMilestoneMutation(c.config, OpCreate)
	return &IncidentMilestoneCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentMilestone entities.
func (c *IncidentMilestoneClient) CreateBulk(builders ...*IncidentMilestoneCreate) *IncidentMilestoneCreateBulk {
	return &IncidentMilestoneCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentMilestoneClient) MapCreateBulk(slice any, setFunc func(*IncidentMilestoneCreate, int)) *IncidentMilestoneCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentMilestoneCreateBulk{err: fmt.Errorf("calling to IncidentMilestoneClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentMilestoneCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentMilestoneCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentMilestone.
func (c *IncidentMilestoneClient) Update() *IncidentMilestoneUpdate {
	mutation := newIncidentMilestoneMutation(c.config, OpUpdate)
	return &IncidentMilestoneUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentMilestoneClient) UpdateOne(im *IncidentMilestone) *IncidentMilestoneUpdateOne {
	mutation := newIncidentMilestoneMutation(c.config, OpUpdateOne, withIncidentMilestone(im))
	return &IncidentMilestoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentMilestoneClient) UpdateOneID(id uuid.UUID) *IncidentMilestoneUpdateOne {
	mutation := newIncidentMilestoneMutation(c.config, OpUpdateOne, withIncidentMilestoneID(id))
	return &IncidentMilestoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentMilestone.
func (c *IncidentMilestoneClient) Delete() *IncidentMilestoneDelete {
	mutation := newIncidentMilestoneMutation(c.config, OpDelete)
	return &IncidentMilestoneDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentMilestoneClient) DeleteOne(im *IncidentMilestone) *IncidentMilestoneDeleteOne {
	return c.DeleteOneID(im.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentMilestoneClient) DeleteOneID(id uuid.UUID) *IncidentMilestoneDeleteOne {
	builder := c.Delete().Where(incidentmilestone.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentMilestoneDeleteOne{builder}
}

// Query returns a query builder for IncidentMilestone.
func (c *IncidentMilestoneClient) Query() *IncidentMilestoneQuery {
	return &IncidentMilestoneQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentMilestone},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentMilestone entity by its id.
func (c *IncidentMilestoneClient) Get(ctx context.Context, id uuid.UUID) (*IncidentMilestone, error) {
	return c.Query().Where(incidentmilestone.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentMilestoneClient) GetX(ctx context.Context, id uuid.UUID) *IncidentMilestone {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a IncidentMilestone.
func (c *IncidentMilestoneClient) QueryIncident(im *IncidentMilestone) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := im.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentmilestone.Table, incidentmilestone.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentmilestone.IncidentTable, incidentmilestone.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(im.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentMilestoneClient) Hooks() []Hook {
	hooks := c.hooks.IncidentMilestone
	return append(hooks[:len(hooks):len(hooks)], incidentmilestone.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentMilestoneClient) Interceptors() []Interceptor {
	return c.inters.IncidentMilestone
}

func (c *IncidentMilestoneClient) mutate(ctx context.Context, m *IncidentMilestoneMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentMilestoneCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentMilestoneUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentMilestoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentMilestoneDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentMilestone mutation op: %q", m.Op())
	}
}

// IncidentRoleClient is a client for the IncidentRole schema.
type IncidentRoleClient struct {
	config
}

// NewIncidentRoleClient returns a client for the IncidentRole from the given config.
func NewIncidentRoleClient(c config) *IncidentRoleClient {
	return &IncidentRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentrole.Hooks(f(g(h())))`.
func (c *IncidentRoleClient) Use(hooks ...Hook) {
	c.hooks.IncidentRole = append(c.hooks.IncidentRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentrole.Intercept(f(g(h())))`.
func (c *IncidentRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentRole = append(c.inters.IncidentRole, interceptors...)
}

// Create returns a builder for creating a IncidentRole entity.
func (c *IncidentRoleClient) Create() *IncidentRoleCreate {
	mutation := newIncidentRoleMutation(c.config, OpCreate)
	return &IncidentRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentRole entities.
func (c *IncidentRoleClient) CreateBulk(builders ...*IncidentRoleCreate) *IncidentRoleCreateBulk {
	return &IncidentRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentRoleClient) MapCreateBulk(slice any, setFunc func(*IncidentRoleCreate, int)) *IncidentRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentRoleCreateBulk{err: fmt.Errorf("calling to IncidentRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentRole.
func (c *IncidentRoleClient) Update() *IncidentRoleUpdate {
	mutation := newIncidentRoleMutation(c.config, OpUpdate)
	return &IncidentRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentRoleClient) UpdateOne(ir *IncidentRole) *IncidentRoleUpdateOne {
	mutation := newIncidentRoleMutation(c.config, OpUpdateOne, withIncidentRole(ir))
	return &IncidentRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentRoleClient) UpdateOneID(id uuid.UUID) *IncidentRoleUpdateOne {
	mutation := newIncidentRoleMutation(c.config, OpUpdateOne, withIncidentRoleID(id))
	return &IncidentRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentRole.
func (c *IncidentRoleClient) Delete() *IncidentRoleDelete {
	mutation := newIncidentRoleMutation(c.config, OpDelete)
	return &IncidentRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentRoleClient) DeleteOne(ir *IncidentRole) *IncidentRoleDeleteOne {
	return c.DeleteOneID(ir.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentRoleClient) DeleteOneID(id uuid.UUID) *IncidentRoleDeleteOne {
	builder := c.Delete().Where(incidentrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentRoleDeleteOne{builder}
}

// Query returns a query builder for IncidentRole.
func (c *IncidentRoleClient) Query() *IncidentRoleQuery {
	return &IncidentRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentRole},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentRole entity by its id.
func (c *IncidentRoleClient) Get(ctx context.Context, id uuid.UUID) (*IncidentRole, error) {
	return c.Query().Where(incidentrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentRoleClient) GetX(ctx context.Context, id uuid.UUID) *IncidentRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAssignments queries the assignments edge of a IncidentRole.
func (c *IncidentRoleClient) QueryAssignments(ir *IncidentRole) *IncidentRoleAssignmentQuery {
	query := (&IncidentRoleAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ir.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentrole.Table, incidentrole.FieldID, id),
			sqlgraph.To(incidentroleassignment.Table, incidentroleassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incidentrole.AssignmentsTable, incidentrole.AssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(ir.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefQuestions queries the debrief_questions edge of a IncidentRole.
func (c *IncidentRoleClient) QueryDebriefQuestions(ir *IncidentRole) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ir.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentrole.Table, incidentrole.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidentrole.DebriefQuestionsTable, incidentrole.DebriefQuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ir.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentRoleClient) Hooks() []Hook {
	hooks := c.hooks.IncidentRole
	return append(hooks[:len(hooks):len(hooks)], incidentrole.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentRoleClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentRole
	return append(inters[:len(inters):len(inters)], incidentrole.Interceptors[:]...)
}

func (c *IncidentRoleClient) mutate(ctx context.Context, m *IncidentRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentRole mutation op: %q", m.Op())
	}
}

// IncidentRoleAssignmentClient is a client for the IncidentRoleAssignment schema.
type IncidentRoleAssignmentClient struct {
	config
}

// NewIncidentRoleAssignmentClient returns a client for the IncidentRoleAssignment from the given config.
func NewIncidentRoleAssignmentClient(c config) *IncidentRoleAssignmentClient {
	return &IncidentRoleAssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentroleassignment.Hooks(f(g(h())))`.
func (c *IncidentRoleAssignmentClient) Use(hooks ...Hook) {
	c.hooks.IncidentRoleAssignment = append(c.hooks.IncidentRoleAssignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentroleassignment.Intercept(f(g(h())))`.
func (c *IncidentRoleAssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentRoleAssignment = append(c.inters.IncidentRoleAssignment, interceptors...)
}

// Create returns a builder for creating a IncidentRoleAssignment entity.
func (c *IncidentRoleAssignmentClient) Create() *IncidentRoleAssignmentCreate {
	mutation := newIncidentRoleAssignmentMutation(c.config, OpCreate)
	return &IncidentRoleAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentRoleAssignment entities.
func (c *IncidentRoleAssignmentClient) CreateBulk(builders ...*IncidentRoleAssignmentCreate) *IncidentRoleAssignmentCreateBulk {
	return &IncidentRoleAssignmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentRoleAssignmentClient) MapCreateBulk(slice any, setFunc func(*IncidentRoleAssignmentCreate, int)) *IncidentRoleAssignmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentRoleAssignmentCreateBulk{err: fmt.Errorf("calling to IncidentRoleAssignmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentRoleAssignmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentRoleAssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) Update() *IncidentRoleAssignmentUpdate {
	mutation := newIncidentRoleAssignmentMutation(c.config, OpUpdate)
	return &IncidentRoleAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentRoleAssignmentClient) UpdateOne(ira *IncidentRoleAssignment) *IncidentRoleAssignmentUpdateOne {
	mutation := newIncidentRoleAssignmentMutation(c.config, OpUpdateOne, withIncidentRoleAssignment(ira))
	return &IncidentRoleAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentRoleAssignmentClient) UpdateOneID(id uuid.UUID) *IncidentRoleAssignmentUpdateOne {
	mutation := newIncidentRoleAssignmentMutation(c.config, OpUpdateOne, withIncidentRoleAssignmentID(id))
	return &IncidentRoleAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) Delete() *IncidentRoleAssignmentDelete {
	mutation := newIncidentRoleAssignmentMutation(c.config, OpDelete)
	return &IncidentRoleAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentRoleAssignmentClient) DeleteOne(ira *IncidentRoleAssignment) *IncidentRoleAssignmentDeleteOne {
	return c.DeleteOneID(ira.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentRoleAssignmentClient) DeleteOneID(id uuid.UUID) *IncidentRoleAssignmentDeleteOne {
	builder := c.Delete().Where(incidentroleassignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentRoleAssignmentDeleteOne{builder}
}

// Query returns a query builder for IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) Query() *IncidentRoleAssignmentQuery {
	return &IncidentRoleAssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentRoleAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentRoleAssignment entity by its id.
func (c *IncidentRoleAssignmentClient) Get(ctx context.Context, id uuid.UUID) (*IncidentRoleAssignment, error) {
	return c.Query().Where(incidentroleassignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentRoleAssignmentClient) GetX(ctx context.Context, id uuid.UUID) *IncidentRoleAssignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRole queries the role edge of a IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) QueryRole(ira *IncidentRoleAssignment) *IncidentRoleQuery {
	query := (&IncidentRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ira.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentroleassignment.Table, incidentroleassignment.FieldID, id),
			sqlgraph.To(incidentrole.Table, incidentrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentroleassignment.RoleTable, incidentroleassignment.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(ira.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncident queries the incident edge of a IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) QueryIncident(ira *IncidentRoleAssignment) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ira.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentroleassignment.Table, incidentroleassignment.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentroleassignment.IncidentTable, incidentroleassignment.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(ira.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) QueryUser(ira *IncidentRoleAssignment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ira.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentroleassignment.Table, incidentroleassignment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentroleassignment.UserTable, incidentroleassignment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ira.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentRoleAssignmentClient) Hooks() []Hook {
	hooks := c.hooks.IncidentRoleAssignment
	return append(hooks[:len(hooks):len(hooks)], incidentroleassignment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentRoleAssignmentClient) Interceptors() []Interceptor {
	return c.inters.IncidentRoleAssignment
}

func (c *IncidentRoleAssignmentClient) mutate(ctx context.Context, m *IncidentRoleAssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentRoleAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentRoleAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentRoleAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentRoleAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentRoleAssignment mutation op: %q", m.Op())
	}
}

// IncidentSeverityClient is a client for the IncidentSeverity schema.
type IncidentSeverityClient struct {
	config
}

// NewIncidentSeverityClient returns a client for the IncidentSeverity from the given config.
func NewIncidentSeverityClient(c config) *IncidentSeverityClient {
	return &IncidentSeverityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentseverity.Hooks(f(g(h())))`.
func (c *IncidentSeverityClient) Use(hooks ...Hook) {
	c.hooks.IncidentSeverity = append(c.hooks.IncidentSeverity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentseverity.Intercept(f(g(h())))`.
func (c *IncidentSeverityClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentSeverity = append(c.inters.IncidentSeverity, interceptors...)
}

// Create returns a builder for creating a IncidentSeverity entity.
func (c *IncidentSeverityClient) Create() *IncidentSeverityCreate {
	mutation := newIncidentSeverityMutation(c.config, OpCreate)
	return &IncidentSeverityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentSeverity entities.
func (c *IncidentSeverityClient) CreateBulk(builders ...*IncidentSeverityCreate) *IncidentSeverityCreateBulk {
	return &IncidentSeverityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentSeverityClient) MapCreateBulk(slice any, setFunc func(*IncidentSeverityCreate, int)) *IncidentSeverityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentSeverityCreateBulk{err: fmt.Errorf("calling to IncidentSeverityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentSeverityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentSeverityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentSeverity.
func (c *IncidentSeverityClient) Update() *IncidentSeverityUpdate {
	mutation := newIncidentSeverityMutation(c.config, OpUpdate)
	return &IncidentSeverityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentSeverityClient) UpdateOne(is *IncidentSeverity) *IncidentSeverityUpdateOne {
	mutation := newIncidentSeverityMutation(c.config, OpUpdateOne, withIncidentSeverity(is))
	return &IncidentSeverityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentSeverityClient) UpdateOneID(id uuid.UUID) *IncidentSeverityUpdateOne {
	mutation := newIncidentSeverityMutation(c.config, OpUpdateOne, withIncidentSeverityID(id))
	return &IncidentSeverityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentSeverity.
func (c *IncidentSeverityClient) Delete() *IncidentSeverityDelete {
	mutation := newIncidentSeverityMutation(c.config, OpDelete)
	return &IncidentSeverityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentSeverityClient) DeleteOne(is *IncidentSeverity) *IncidentSeverityDeleteOne {
	return c.DeleteOneID(is.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentSeverityClient) DeleteOneID(id uuid.UUID) *IncidentSeverityDeleteOne {
	builder := c.Delete().Where(incidentseverity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentSeverityDeleteOne{builder}
}

// Query returns a query builder for IncidentSeverity.
func (c *IncidentSeverityClient) Query() *IncidentSeverityQuery {
	return &IncidentSeverityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentSeverity},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentSeverity entity by its id.
func (c *IncidentSeverityClient) Get(ctx context.Context, id uuid.UUID) (*IncidentSeverity, error) {
	return c.Query().Where(incidentseverity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentSeverityClient) GetX(ctx context.Context, id uuid.UUID) *IncidentSeverity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a IncidentSeverity.
func (c *IncidentSeverityClient) QueryIncidents(is *IncidentSeverity) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := is.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentseverity.Table, incidentseverity.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incidentseverity.IncidentsTable, incidentseverity.IncidentsColumn),
		)
		fromV = sqlgraph.Neighbors(is.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefQuestions queries the debrief_questions edge of a IncidentSeverity.
func (c *IncidentSeverityClient) QueryDebriefQuestions(is *IncidentSeverity) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := is.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentseverity.Table, incidentseverity.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidentseverity.DebriefQuestionsTable, incidentseverity.DebriefQuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(is.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentSeverityClient) Hooks() []Hook {
	hooks := c.hooks.IncidentSeverity
	return append(hooks[:len(hooks):len(hooks)], incidentseverity.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentSeverityClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentSeverity
	return append(inters[:len(inters):len(inters)], incidentseverity.Interceptors[:]...)
}

func (c *IncidentSeverityClient) mutate(ctx context.Context, m *IncidentSeverityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentSeverityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentSeverityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentSeverityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentSeverityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentSeverity mutation op: %q", m.Op())
	}
}

// IncidentTagClient is a client for the IncidentTag schema.
type IncidentTagClient struct {
	config
}

// NewIncidentTagClient returns a client for the IncidentTag from the given config.
func NewIncidentTagClient(c config) *IncidentTagClient {
	return &IncidentTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidenttag.Hooks(f(g(h())))`.
func (c *IncidentTagClient) Use(hooks ...Hook) {
	c.hooks.IncidentTag = append(c.hooks.IncidentTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidenttag.Intercept(f(g(h())))`.
func (c *IncidentTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentTag = append(c.inters.IncidentTag, interceptors...)
}

// Create returns a builder for creating a IncidentTag entity.
func (c *IncidentTagClient) Create() *IncidentTagCreate {
	mutation := newIncidentTagMutation(c.config, OpCreate)
	return &IncidentTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentTag entities.
func (c *IncidentTagClient) CreateBulk(builders ...*IncidentTagCreate) *IncidentTagCreateBulk {
	return &IncidentTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentTagClient) MapCreateBulk(slice any, setFunc func(*IncidentTagCreate, int)) *IncidentTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentTagCreateBulk{err: fmt.Errorf("calling to IncidentTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentTag.
func (c *IncidentTagClient) Update() *IncidentTagUpdate {
	mutation := newIncidentTagMutation(c.config, OpUpdate)
	return &IncidentTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentTagClient) UpdateOne(it *IncidentTag) *IncidentTagUpdateOne {
	mutation := newIncidentTagMutation(c.config, OpUpdateOne, withIncidentTag(it))
	return &IncidentTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentTagClient) UpdateOneID(id uuid.UUID) *IncidentTagUpdateOne {
	mutation := newIncidentTagMutation(c.config, OpUpdateOne, withIncidentTagID(id))
	return &IncidentTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentTag.
func (c *IncidentTagClient) Delete() *IncidentTagDelete {
	mutation := newIncidentTagMutation(c.config, OpDelete)
	return &IncidentTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentTagClient) DeleteOne(it *IncidentTag) *IncidentTagDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentTagClient) DeleteOneID(id uuid.UUID) *IncidentTagDeleteOne {
	builder := c.Delete().Where(incidenttag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentTagDeleteOne{builder}
}

// Query returns a query builder for IncidentTag.
func (c *IncidentTagClient) Query() *IncidentTagQuery {
	return &IncidentTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentTag},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentTag entity by its id.
func (c *IncidentTagClient) Get(ctx context.Context, id uuid.UUID) (*IncidentTag, error) {
	return c.Query().Where(incidenttag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentTagClient) GetX(ctx context.Context, id uuid.UUID) *IncidentTag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a IncidentTag.
func (c *IncidentTagClient) QueryIncidents(it *IncidentTag) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenttag.Table, incidenttag.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidenttag.IncidentsTable, incidenttag.IncidentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefQuestions queries the debrief_questions edge of a IncidentTag.
func (c *IncidentTagClient) QueryDebriefQuestions(it *IncidentTag) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenttag.Table, incidenttag.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidenttag.DebriefQuestionsTable, incidenttag.DebriefQuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentTagClient) Hooks() []Hook {
	hooks := c.hooks.IncidentTag
	return append(hooks[:len(hooks):len(hooks)], incidenttag.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentTagClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentTag
	return append(inters[:len(inters):len(inters)], incidenttag.Interceptors[:]...)
}

func (c *IncidentTagClient) mutate(ctx context.Context, m *IncidentTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentTag mutation op: %q", m.Op())
	}
}

// IncidentTeamAssignmentClient is a client for the IncidentTeamAssignment schema.
type IncidentTeamAssignmentClient struct {
	config
}

// NewIncidentTeamAssignmentClient returns a client for the IncidentTeamAssignment from the given config.
func NewIncidentTeamAssignmentClient(c config) *IncidentTeamAssignmentClient {
	return &IncidentTeamAssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentteamassignment.Hooks(f(g(h())))`.
func (c *IncidentTeamAssignmentClient) Use(hooks ...Hook) {
	c.hooks.IncidentTeamAssignment = append(c.hooks.IncidentTeamAssignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentteamassignment.Intercept(f(g(h())))`.
func (c *IncidentTeamAssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentTeamAssignment = append(c.inters.IncidentTeamAssignment, interceptors...)
}

// Create returns a builder for creating a IncidentTeamAssignment entity.
func (c *IncidentTeamAssignmentClient) Create() *IncidentTeamAssignmentCreate {
	mutation := newIncidentTeamAssignmentMutation(c.config, OpCreate)
	return &IncidentTeamAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentTeamAssignment entities.
func (c *IncidentTeamAssignmentClient) CreateBulk(builders ...*IncidentTeamAssignmentCreate) *IncidentTeamAssignmentCreateBulk {
	return &IncidentTeamAssignmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentTeamAssignmentClient) MapCreateBulk(slice any, setFunc func(*IncidentTeamAssignmentCreate, int)) *IncidentTeamAssignmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentTeamAssignmentCreateBulk{err: fmt.Errorf("calling to IncidentTeamAssignmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentTeamAssignmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentTeamAssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentTeamAssignment.
func (c *IncidentTeamAssignmentClient) Update() *IncidentTeamAssignmentUpdate {
	mutation := newIncidentTeamAssignmentMutation(c.config, OpUpdate)
	return &IncidentTeamAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentTeamAssignmentClient) UpdateOne(ita *IncidentTeamAssignment) *IncidentTeamAssignmentUpdateOne {
	mutation := newIncidentTeamAssignmentMutation(c.config, OpUpdateOne, withIncidentTeamAssignment(ita))
	return &IncidentTeamAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentTeamAssignmentClient) UpdateOneID(id int) *IncidentTeamAssignmentUpdateOne {
	mutation := newIncidentTeamAssignmentMutation(c.config, OpUpdateOne, withIncidentTeamAssignmentID(id))
	return &IncidentTeamAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentTeamAssignment.
func (c *IncidentTeamAssignmentClient) Delete() *IncidentTeamAssignmentDelete {
	mutation := newIncidentTeamAssignmentMutation(c.config, OpDelete)
	return &IncidentTeamAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentTeamAssignmentClient) DeleteOne(ita *IncidentTeamAssignment) *IncidentTeamAssignmentDeleteOne {
	return c.DeleteOneID(ita.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentTeamAssignmentClient) DeleteOneID(id int) *IncidentTeamAssignmentDeleteOne {
	builder := c.Delete().Where(incidentteamassignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentTeamAssignmentDeleteOne{builder}
}

// Query returns a query builder for IncidentTeamAssignment.
func (c *IncidentTeamAssignmentClient) Query() *IncidentTeamAssignmentQuery {
	return &IncidentTeamAssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentTeamAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentTeamAssignment entity by its id.
func (c *IncidentTeamAssignmentClient) Get(ctx context.Context, id int) (*IncidentTeamAssignment, error) {
	return c.Query().Where(incidentteamassignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentTeamAssignmentClient) GetX(ctx context.Context, id int) *IncidentTeamAssignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a IncidentTeamAssignment.
func (c *IncidentTeamAssignmentClient) QueryIncident(ita *IncidentTeamAssignment) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ita.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentteamassignment.Table, incidentteamassignment.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentteamassignment.IncidentTable, incidentteamassignment.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(ita.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a IncidentTeamAssignment.
func (c *IncidentTeamAssignmentClient) QueryTeam(ita *IncidentTeamAssignment) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ita.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentteamassignment.Table, incidentteamassignment.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentteamassignment.TeamTable, incidentteamassignment.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(ita.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentTeamAssignmentClient) Hooks() []Hook {
	hooks := c.hooks.IncidentTeamAssignment
	return append(hooks[:len(hooks):len(hooks)], incidentteamassignment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentTeamAssignmentClient) Interceptors() []Interceptor {
	return c.inters.IncidentTeamAssignment
}

func (c *IncidentTeamAssignmentClient) mutate(ctx context.Context, m *IncidentTeamAssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentTeamAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentTeamAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentTeamAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentTeamAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentTeamAssignment mutation op: %q", m.Op())
	}
}

// IncidentTypeClient is a client for the IncidentType schema.
type IncidentTypeClient struct {
	config
}

// NewIncidentTypeClient returns a client for the IncidentType from the given config.
func NewIncidentTypeClient(c config) *IncidentTypeClient {
	return &IncidentTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidenttype.Hooks(f(g(h())))`.
func (c *IncidentTypeClient) Use(hooks ...Hook) {
	c.hooks.IncidentType = append(c.hooks.IncidentType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidenttype.Intercept(f(g(h())))`.
func (c *IncidentTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentType = append(c.inters.IncidentType, interceptors...)
}

// Create returns a builder for creating a IncidentType entity.
func (c *IncidentTypeClient) Create() *IncidentTypeCreate {
	mutation := newIncidentTypeMutation(c.config, OpCreate)
	return &IncidentTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentType entities.
func (c *IncidentTypeClient) CreateBulk(builders ...*IncidentTypeCreate) *IncidentTypeCreateBulk {
	return &IncidentTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentTypeClient) MapCreateBulk(slice any, setFunc func(*IncidentTypeCreate, int)) *IncidentTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentTypeCreateBulk{err: fmt.Errorf("calling to IncidentTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentType.
func (c *IncidentTypeClient) Update() *IncidentTypeUpdate {
	mutation := newIncidentTypeMutation(c.config, OpUpdate)
	return &IncidentTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentTypeClient) UpdateOne(it *IncidentType) *IncidentTypeUpdateOne {
	mutation := newIncidentTypeMutation(c.config, OpUpdateOne, withIncidentType(it))
	return &IncidentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentTypeClient) UpdateOneID(id uuid.UUID) *IncidentTypeUpdateOne {
	mutation := newIncidentTypeMutation(c.config, OpUpdateOne, withIncidentTypeID(id))
	return &IncidentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentType.
func (c *IncidentTypeClient) Delete() *IncidentTypeDelete {
	mutation := newIncidentTypeMutation(c.config, OpDelete)
	return &IncidentTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentTypeClient) DeleteOne(it *IncidentType) *IncidentTypeDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentTypeClient) DeleteOneID(id uuid.UUID) *IncidentTypeDeleteOne {
	builder := c.Delete().Where(incidenttype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentTypeDeleteOne{builder}
}

// Query returns a query builder for IncidentType.
func (c *IncidentTypeClient) Query() *IncidentTypeQuery {
	return &IncidentTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentType},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentType entity by its id.
func (c *IncidentTypeClient) Get(ctx context.Context, id uuid.UUID) (*IncidentType, error) {
	return c.Query().Where(incidenttype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentTypeClient) GetX(ctx context.Context, id uuid.UUID) *IncidentType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a IncidentType.
func (c *IncidentTypeClient) QueryIncidents(it *IncidentType) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenttype.Table, incidenttype.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incidenttype.IncidentsTable, incidenttype.IncidentsColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefQuestions queries the debrief_questions edge of a IncidentType.
func (c *IncidentTypeClient) QueryDebriefQuestions(it *IncidentType) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenttype.Table, incidenttype.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidenttype.DebriefQuestionsTable, incidenttype.DebriefQuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentTypeClient) Hooks() []Hook {
	hooks := c.hooks.IncidentType
	return append(hooks[:len(hooks):len(hooks)], incidenttype.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentTypeClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentType
	return append(inters[:len(inters):len(inters)], incidenttype.Interceptors[:]...)
}

func (c *IncidentTypeClient) mutate(ctx context.Context, m *IncidentTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentType mutation op: %q", m.Op())
	}
}

// MeetingScheduleClient is a client for the MeetingSchedule schema.
type MeetingScheduleClient struct {
	config
}

// NewMeetingScheduleClient returns a client for the MeetingSchedule from the given config.
func NewMeetingScheduleClient(c config) *MeetingScheduleClient {
	return &MeetingScheduleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `meetingschedule.Hooks(f(g(h())))`.
func (c *MeetingScheduleClient) Use(hooks ...Hook) {
	c.hooks.MeetingSchedule = append(c.hooks.MeetingSchedule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `meetingschedule.Intercept(f(g(h())))`.
func (c *MeetingScheduleClient) Intercept(interceptors ...Interceptor) {
	c.inters.MeetingSchedule = append(c.inters.MeetingSchedule, interceptors...)
}

// Create returns a builder for creating a MeetingSchedule entity.
func (c *MeetingScheduleClient) Create() *MeetingScheduleCreate {
	mutation := newMeetingScheduleMutation(c.config, OpCreate)
	return &MeetingScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MeetingSchedule entities.
func (c *MeetingScheduleClient) CreateBulk(builders ...*MeetingScheduleCreate) *MeetingScheduleCreateBulk {
	return &MeetingScheduleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MeetingScheduleClient) MapCreateBulk(slice any, setFunc func(*MeetingScheduleCreate, int)) *MeetingScheduleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MeetingScheduleCreateBulk{err: fmt.Errorf("calling to MeetingScheduleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MeetingScheduleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MeetingScheduleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MeetingSchedule.
func (c *MeetingScheduleClient) Update() *MeetingScheduleUpdate {
	mutation := newMeetingScheduleMutation(c.config, OpUpdate)
	return &MeetingScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MeetingScheduleClient) UpdateOne(ms *MeetingSchedule) *MeetingScheduleUpdateOne {
	mutation := newMeetingScheduleMutation(c.config, OpUpdateOne, withMeetingSchedule(ms))
	return &MeetingScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MeetingScheduleClient) UpdateOneID(id uuid.UUID) *MeetingScheduleUpdateOne {
	mutation := newMeetingScheduleMutation(c.config, OpUpdateOne, withMeetingScheduleID(id))
	return &MeetingScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MeetingSchedule.
func (c *MeetingScheduleClient) Delete() *MeetingScheduleDelete {
	mutation := newMeetingScheduleMutation(c.config, OpDelete)
	return &MeetingScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MeetingScheduleClient) DeleteOne(ms *MeetingSchedule) *MeetingScheduleDeleteOne {
	return c.DeleteOneID(ms.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MeetingScheduleClient) DeleteOneID(id uuid.UUID) *MeetingScheduleDeleteOne {
	builder := c.Delete().Where(meetingschedule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MeetingScheduleDeleteOne{builder}
}

// Query returns a query builder for MeetingSchedule.
func (c *MeetingScheduleClient) Query() *MeetingScheduleQuery {
	return &MeetingScheduleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMeetingSchedule},
		inters: c.Interceptors(),
	}
}

// Get returns a MeetingSchedule entity by its id.
func (c *MeetingScheduleClient) Get(ctx context.Context, id uuid.UUID) (*MeetingSchedule, error) {
	return c.Query().Where(meetingschedule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MeetingScheduleClient) GetX(ctx context.Context, id uuid.UUID) *MeetingSchedule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a MeetingSchedule.
func (c *MeetingScheduleClient) QuerySessions(ms *MeetingSchedule) *MeetingSessionQuery {
	query := (&MeetingSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ms.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(meetingschedule.Table, meetingschedule.FieldID, id),
			sqlgraph.To(meetingsession.Table, meetingsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, meetingschedule.SessionsTable, meetingschedule.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(ms.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwningTeam queries the owning_team edge of a MeetingSchedule.
func (c *MeetingScheduleClient) QueryOwningTeam(ms *MeetingSchedule) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ms.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(meetingschedule.Table, meetingschedule.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, meetingschedule.OwningTeamTable, meetingschedule.OwningTeamPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ms.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MeetingScheduleClient) Hooks() []Hook {
	hooks := c.hooks.MeetingSchedule
	return append(hooks[:len(hooks):len(hooks)], meetingschedule.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MeetingScheduleClient) Interceptors() []Interceptor {
	inters := c.inters.MeetingSchedule
	return append(inters[:len(inters):len(inters)], meetingschedule.Interceptors[:]...)
}

func (c *MeetingScheduleClient) mutate(ctx context.Context, m *MeetingScheduleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MeetingScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MeetingScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MeetingScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MeetingScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MeetingSchedule mutation op: %q", m.Op())
	}
}

// MeetingSessionClient is a client for the MeetingSession schema.
type MeetingSessionClient struct {
	config
}

// NewMeetingSessionClient returns a client for the MeetingSession from the given config.
func NewMeetingSessionClient(c config) *MeetingSessionClient {
	return &MeetingSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `meetingsession.Hooks(f(g(h())))`.
func (c *MeetingSessionClient) Use(hooks ...Hook) {
	c.hooks.MeetingSession = append(c.hooks.MeetingSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `meetingsession.Intercept(f(g(h())))`.
func (c *MeetingSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MeetingSession = append(c.inters.MeetingSession, interceptors...)
}

// Create returns a builder for creating a MeetingSession entity.
func (c *MeetingSessionClient) Create() *MeetingSessionCreate {
	mutation := newMeetingSessionMutation(c.config, OpCreate)
	return &MeetingSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MeetingSession entities.
func (c *MeetingSessionClient) CreateBulk(builders ...*MeetingSessionCreate) *MeetingSessionCreateBulk {
	return &MeetingSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MeetingSessionClient) MapCreateBulk(slice any, setFunc func(*MeetingSessionCreate, int)) *MeetingSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MeetingSessionCreateBulk{err: fmt.Errorf("calling to MeetingSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MeetingSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MeetingSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MeetingSession.
func (c *MeetingSessionClient) Update() *MeetingSessionUpdate {
	mutation := newMeetingSessionMutation(c.config, OpUpdate)
	return &MeetingSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MeetingSessionClient) UpdateOne(ms *MeetingSession) *MeetingSessionUpdateOne {
	mutation := newMeetingSessionMutation(c.config, OpUpdateOne, withMeetingSession(ms))
	return &MeetingSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MeetingSessionClient) UpdateOneID(id uuid.UUID) *MeetingSessionUpdateOne {
	mutation := newMeetingSessionMutation(c.config, OpUpdateOne, withMeetingSessionID(id))
	return &MeetingSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MeetingSession.
func (c *MeetingSessionClient) Delete() *MeetingSessionDelete {
	mutation := newMeetingSessionMutation(c.config, OpDelete)
	return &MeetingSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MeetingSessionClient) DeleteOne(ms *MeetingSession) *MeetingSessionDeleteOne {
	return c.DeleteOneID(ms.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MeetingSessionClient) DeleteOneID(id uuid.UUID) *MeetingSessionDeleteOne {
	builder := c.Delete().Where(meetingsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MeetingSessionDeleteOne{builder}
}

// Query returns a query builder for MeetingSession.
func (c *MeetingSessionClient) Query() *MeetingSessionQuery {
	return &MeetingSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMeetingSession},
		inters: c.Interceptors(),
	}
}

// Get returns a MeetingSession entity by its id.
func (c *MeetingSessionClient) Get(ctx context.Context, id uuid.UUID) (*MeetingSession, error) {
	return c.Query().Where(meetingsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MeetingSessionClient) GetX(ctx context.Context, id uuid.UUID) *MeetingSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a MeetingSession.
func (c *MeetingSessionClient) QueryIncidents(ms *MeetingSession) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ms.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(meetingsession.Table, meetingsession.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, meetingsession.IncidentsTable, meetingsession.IncidentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ms.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MeetingSessionClient) Hooks() []Hook {
	hooks := c.hooks.MeetingSession
	return append(hooks[:len(hooks):len(hooks)], meetingsession.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MeetingSessionClient) Interceptors() []Interceptor {
	return c.inters.MeetingSession
}

func (c *MeetingSessionClient) mutate(ctx context.Context, m *MeetingSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MeetingSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MeetingSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MeetingSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MeetingSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MeetingSession mutation op: %q", m.Op())
	}
}

// OncallAnnotationClient is a client for the OncallAnnotation schema.
type OncallAnnotationClient struct {
	config
}

// NewOncallAnnotationClient returns a client for the OncallAnnotation from the given config.
func NewOncallAnnotationClient(c config) *OncallAnnotationClient {
	return &OncallAnnotationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallannotation.Hooks(f(g(h())))`.
func (c *OncallAnnotationClient) Use(hooks ...Hook) {
	c.hooks.OncallAnnotation = append(c.hooks.OncallAnnotation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallannotation.Intercept(f(g(h())))`.
func (c *OncallAnnotationClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallAnnotation = append(c.inters.OncallAnnotation, interceptors...)
}

// Create returns a builder for creating a OncallAnnotation entity.
func (c *OncallAnnotationClient) Create() *OncallAnnotationCreate {
	mutation := newOncallAnnotationMutation(c.config, OpCreate)
	return &OncallAnnotationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallAnnotation entities.
func (c *OncallAnnotationClient) CreateBulk(builders ...*OncallAnnotationCreate) *OncallAnnotationCreateBulk {
	return &OncallAnnotationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallAnnotationClient) MapCreateBulk(slice any, setFunc func(*OncallAnnotationCreate, int)) *OncallAnnotationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallAnnotationCreateBulk{err: fmt.Errorf("calling to OncallAnnotationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallAnnotationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallAnnotationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallAnnotation.
func (c *OncallAnnotationClient) Update() *OncallAnnotationUpdate {
	mutation := newOncallAnnotationMutation(c.config, OpUpdate)
	return &OncallAnnotationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallAnnotationClient) UpdateOne(oa *OncallAnnotation) *OncallAnnotationUpdateOne {
	mutation := newOncallAnnotationMutation(c.config, OpUpdateOne, withOncallAnnotation(oa))
	return &OncallAnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallAnnotationClient) UpdateOneID(id uuid.UUID) *OncallAnnotationUpdateOne {
	mutation := newOncallAnnotationMutation(c.config, OpUpdateOne, withOncallAnnotationID(id))
	return &OncallAnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallAnnotation.
func (c *OncallAnnotationClient) Delete() *OncallAnnotationDelete {
	mutation := newOncallAnnotationMutation(c.config, OpDelete)
	return &OncallAnnotationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallAnnotationClient) DeleteOne(oa *OncallAnnotation) *OncallAnnotationDeleteOne {
	return c.DeleteOneID(oa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallAnnotationClient) DeleteOneID(id uuid.UUID) *OncallAnnotationDeleteOne {
	builder := c.Delete().Where(oncallannotation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallAnnotationDeleteOne{builder}
}

// Query returns a query builder for OncallAnnotation.
func (c *OncallAnnotationClient) Query() *OncallAnnotationQuery {
	return &OncallAnnotationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallAnnotation},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallAnnotation entity by its id.
func (c *OncallAnnotationClient) Get(ctx context.Context, id uuid.UUID) (*OncallAnnotation, error) {
	return c.Query().Where(oncallannotation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallAnnotationClient) GetX(ctx context.Context, id uuid.UUID) *OncallAnnotation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a OncallAnnotation.
func (c *OncallAnnotationClient) QueryEvent(oa *OncallAnnotation) *OncallEventQuery {
	query := (&OncallEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallannotation.Table, oncallannotation.FieldID, id),
			sqlgraph.To(oncallevent.Table, oncallevent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallannotation.EventTable, oncallannotation.EventColumn),
		)
		fromV = sqlgraph.Neighbors(oa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoster queries the roster edge of a OncallAnnotation.
func (c *OncallAnnotationClient) QueryRoster(oa *OncallAnnotation) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallannotation.Table, oncallannotation.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallannotation.RosterTable, oncallannotation.RosterColumn),
		)
		fromV = sqlgraph.Neighbors(oa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a OncallAnnotation.
func (c *OncallAnnotationClient) QueryCreator(oa *OncallAnnotation) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallannotation.Table, oncallannotation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallannotation.CreatorTable, oncallannotation.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(oa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlertFeedback queries the alert_feedback edge of a OncallAnnotation.
func (c *OncallAnnotationClient) QueryAlertFeedback(oa *OncallAnnotation) *OncallAnnotationAlertFeedbackQuery {
	query := (&OncallAnnotationAlertFeedbackClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallannotation.Table, oncallannotation.FieldID, id),
			sqlgraph.To(oncallannotationalertfeedback.Table, oncallannotationalertfeedback.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oncallannotation.AlertFeedbackTable, oncallannotation.AlertFeedbackColumn),
		)
		fromV = sqlgraph.Neighbors(oa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHandovers queries the handovers edge of a OncallAnnotation.
func (c *OncallAnnotationClient) QueryHandovers(oa *OncallAnnotation) *OncallUserShiftHandoverQuery {
	query := (&OncallUserShiftHandoverClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallannotation.Table, oncallannotation.FieldID, id),
			sqlgraph.To(oncallusershifthandover.Table, oncallusershifthandover.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, oncallannotation.HandoversTable, oncallannotation.HandoversPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(oa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallAnnotationClient) Hooks() []Hook {
	hooks := c.hooks.OncallAnnotation
	return append(hooks[:len(hooks):len(hooks)], oncallannotation.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallAnnotationClient) Interceptors() []Interceptor {
	return c.inters.OncallAnnotation
}

func (c *OncallAnnotationClient) mutate(ctx context.Context, m *OncallAnnotationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallAnnotationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallAnnotationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallAnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallAnnotationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallAnnotation mutation op: %q", m.Op())
	}
}

// OncallAnnotationAlertFeedbackClient is a client for the OncallAnnotationAlertFeedback schema.
type OncallAnnotationAlertFeedbackClient struct {
	config
}

// NewOncallAnnotationAlertFeedbackClient returns a client for the OncallAnnotationAlertFeedback from the given config.
func NewOncallAnnotationAlertFeedbackClient(c config) *OncallAnnotationAlertFeedbackClient {
	return &OncallAnnotationAlertFeedbackClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallannotationalertfeedback.Hooks(f(g(h())))`.
func (c *OncallAnnotationAlertFeedbackClient) Use(hooks ...Hook) {
	c.hooks.OncallAnnotationAlertFeedback = append(c.hooks.OncallAnnotationAlertFeedback, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallannotationalertfeedback.Intercept(f(g(h())))`.
func (c *OncallAnnotationAlertFeedbackClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallAnnotationAlertFeedback = append(c.inters.OncallAnnotationAlertFeedback, interceptors...)
}

// Create returns a builder for creating a OncallAnnotationAlertFeedback entity.
func (c *OncallAnnotationAlertFeedbackClient) Create() *OncallAnnotationAlertFeedbackCreate {
	mutation := newOncallAnnotationAlertFeedbackMutation(c.config, OpCreate)
	return &OncallAnnotationAlertFeedbackCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallAnnotationAlertFeedback entities.
func (c *OncallAnnotationAlertFeedbackClient) CreateBulk(builders ...*OncallAnnotationAlertFeedbackCreate) *OncallAnnotationAlertFeedbackCreateBulk {
	return &OncallAnnotationAlertFeedbackCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallAnnotationAlertFeedbackClient) MapCreateBulk(slice any, setFunc func(*OncallAnnotationAlertFeedbackCreate, int)) *OncallAnnotationAlertFeedbackCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallAnnotationAlertFeedbackCreateBulk{err: fmt.Errorf("calling to OncallAnnotationAlertFeedbackClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallAnnotationAlertFeedbackCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallAnnotationAlertFeedbackCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallAnnotationAlertFeedback.
func (c *OncallAnnotationAlertFeedbackClient) Update() *OncallAnnotationAlertFeedbackUpdate {
	mutation := newOncallAnnotationAlertFeedbackMutation(c.config, OpUpdate)
	return &OncallAnnotationAlertFeedbackUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallAnnotationAlertFeedbackClient) UpdateOne(oaaf *OncallAnnotationAlertFeedback) *OncallAnnotationAlertFeedbackUpdateOne {
	mutation := newOncallAnnotationAlertFeedbackMutation(c.config, OpUpdateOne, withOncallAnnotationAlertFeedback(oaaf))
	return &OncallAnnotationAlertFeedbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallAnnotationAlertFeedbackClient) UpdateOneID(id uuid.UUID) *OncallAnnotationAlertFeedbackUpdateOne {
	mutation := newOncallAnnotationAlertFeedbackMutation(c.config, OpUpdateOne, withOncallAnnotationAlertFeedbackID(id))
	return &OncallAnnotationAlertFeedbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallAnnotationAlertFeedback.
func (c *OncallAnnotationAlertFeedbackClient) Delete() *OncallAnnotationAlertFeedbackDelete {
	mutation := newOncallAnnotationAlertFeedbackMutation(c.config, OpDelete)
	return &OncallAnnotationAlertFeedbackDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallAnnotationAlertFeedbackClient) DeleteOne(oaaf *OncallAnnotationAlertFeedback) *OncallAnnotationAlertFeedbackDeleteOne {
	return c.DeleteOneID(oaaf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallAnnotationAlertFeedbackClient) DeleteOneID(id uuid.UUID) *OncallAnnotationAlertFeedbackDeleteOne {
	builder := c.Delete().Where(oncallannotationalertfeedback.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallAnnotationAlertFeedbackDeleteOne{builder}
}

// Query returns a query builder for OncallAnnotationAlertFeedback.
func (c *OncallAnnotationAlertFeedbackClient) Query() *OncallAnnotationAlertFeedbackQuery {
	return &OncallAnnotationAlertFeedbackQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallAnnotationAlertFeedback},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallAnnotationAlertFeedback entity by its id.
func (c *OncallAnnotationAlertFeedbackClient) Get(ctx context.Context, id uuid.UUID) (*OncallAnnotationAlertFeedback, error) {
	return c.Query().Where(oncallannotationalertfeedback.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallAnnotationAlertFeedbackClient) GetX(ctx context.Context, id uuid.UUID) *OncallAnnotationAlertFeedback {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAnnotation queries the annotation edge of a OncallAnnotationAlertFeedback.
func (c *OncallAnnotationAlertFeedbackClient) QueryAnnotation(oaaf *OncallAnnotationAlertFeedback) *OncallAnnotationQuery {
	query := (&OncallAnnotationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oaaf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallannotationalertfeedback.Table, oncallannotationalertfeedback.FieldID, id),
			sqlgraph.To(oncallannotation.Table, oncallannotation.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, oncallannotationalertfeedback.AnnotationTable, oncallannotationalertfeedback.AnnotationColumn),
		)
		fromV = sqlgraph.Neighbors(oaaf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallAnnotationAlertFeedbackClient) Hooks() []Hook {
	hooks := c.hooks.OncallAnnotationAlertFeedback
	return append(hooks[:len(hooks):len(hooks)], oncallannotationalertfeedback.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallAnnotationAlertFeedbackClient) Interceptors() []Interceptor {
	return c.inters.OncallAnnotationAlertFeedback
}

func (c *OncallAnnotationAlertFeedbackClient) mutate(ctx context.Context, m *OncallAnnotationAlertFeedbackMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallAnnotationAlertFeedbackCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallAnnotationAlertFeedbackUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallAnnotationAlertFeedbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallAnnotationAlertFeedbackDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallAnnotationAlertFeedback mutation op: %q", m.Op())
	}
}

// OncallEventClient is a client for the OncallEvent schema.
type OncallEventClient struct {
	config
}

// NewOncallEventClient returns a client for the OncallEvent from the given config.
func NewOncallEventClient(c config) *OncallEventClient {
	return &OncallEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallevent.Hooks(f(g(h())))`.
func (c *OncallEventClient) Use(hooks ...Hook) {
	c.hooks.OncallEvent = append(c.hooks.OncallEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallevent.Intercept(f(g(h())))`.
func (c *OncallEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallEvent = append(c.inters.OncallEvent, interceptors...)
}

// Create returns a builder for creating a OncallEvent entity.
func (c *OncallEventClient) Create() *OncallEventCreate {
	mutation := newOncallEventMutation(c.config, OpCreate)
	return &OncallEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallEvent entities.
func (c *OncallEventClient) CreateBulk(builders ...*OncallEventCreate) *OncallEventCreateBulk {
	return &OncallEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallEventClient) MapCreateBulk(slice any, setFunc func(*OncallEventCreate, int)) *OncallEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallEventCreateBulk{err: fmt.Errorf("calling to OncallEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallEvent.
func (c *OncallEventClient) Update() *OncallEventUpdate {
	mutation := newOncallEventMutation(c.config, OpUpdate)
	return &OncallEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallEventClient) UpdateOne(oe *OncallEvent) *OncallEventUpdateOne {
	mutation := newOncallEventMutation(c.config, OpUpdateOne, withOncallEvent(oe))
	return &OncallEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallEventClient) UpdateOneID(id uuid.UUID) *OncallEventUpdateOne {
	mutation := newOncallEventMutation(c.config, OpUpdateOne, withOncallEventID(id))
	return &OncallEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallEvent.
func (c *OncallEventClient) Delete() *OncallEventDelete {
	mutation := newOncallEventMutation(c.config, OpDelete)
	return &OncallEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallEventClient) DeleteOne(oe *OncallEvent) *OncallEventDeleteOne {
	return c.DeleteOneID(oe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallEventClient) DeleteOneID(id uuid.UUID) *OncallEventDeleteOne {
	builder := c.Delete().Where(oncallevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallEventDeleteOne{builder}
}

// Query returns a query builder for OncallEvent.
func (c *OncallEventClient) Query() *OncallEventQuery {
	return &OncallEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallEvent entity by its id.
func (c *OncallEventClient) Get(ctx context.Context, id uuid.UUID) (*OncallEvent, error) {
	return c.Query().Where(oncallevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallEventClient) GetX(ctx context.Context, id uuid.UUID) *OncallEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoster queries the roster edge of a OncallEvent.
func (c *OncallEventClient) QueryRoster(oe *OncallEvent) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallevent.Table, oncallevent.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallevent.RosterTable, oncallevent.RosterColumn),
		)
		fromV = sqlgraph.Neighbors(oe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlert queries the alert edge of a OncallEvent.
func (c *OncallEventClient) QueryAlert(oe *OncallEvent) *AlertQuery {
	query := (&AlertClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallevent.Table, oncallevent.FieldID, id),
			sqlgraph.To(alert.Table, alert.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallevent.AlertTable, oncallevent.AlertColumn),
		)
		fromV = sqlgraph.Neighbors(oe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnnotations queries the annotations edge of a OncallEvent.
func (c *OncallEventClient) QueryAnnotations(oe *OncallEvent) *OncallAnnotationQuery {
	query := (&OncallAnnotationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallevent.Table, oncallevent.FieldID, id),
			sqlgraph.To(oncallannotation.Table, oncallannotation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, oncallevent.AnnotationsTable, oncallevent.AnnotationsColumn),
		)
		fromV = sqlgraph.Neighbors(oe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallEventClient) Hooks() []Hook {
	hooks := c.hooks.OncallEvent
	return append(hooks[:len(hooks):len(hooks)], oncallevent.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallEventClient) Interceptors() []Interceptor {
	return c.inters.OncallEvent
}

func (c *OncallEventClient) mutate(ctx context.Context, m *OncallEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallEvent mutation op: %q", m.Op())
	}
}

// OncallHandoverTemplateClient is a client for the OncallHandoverTemplate schema.
type OncallHandoverTemplateClient struct {
	config
}

// NewOncallHandoverTemplateClient returns a client for the OncallHandoverTemplate from the given config.
func NewOncallHandoverTemplateClient(c config) *OncallHandoverTemplateClient {
	return &OncallHandoverTemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallhandovertemplate.Hooks(f(g(h())))`.
func (c *OncallHandoverTemplateClient) Use(hooks ...Hook) {
	c.hooks.OncallHandoverTemplate = append(c.hooks.OncallHandoverTemplate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallhandovertemplate.Intercept(f(g(h())))`.
func (c *OncallHandoverTemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallHandoverTemplate = append(c.inters.OncallHandoverTemplate, interceptors...)
}

// Create returns a builder for creating a OncallHandoverTemplate entity.
func (c *OncallHandoverTemplateClient) Create() *OncallHandoverTemplateCreate {
	mutation := newOncallHandoverTemplateMutation(c.config, OpCreate)
	return &OncallHandoverTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallHandoverTemplate entities.
func (c *OncallHandoverTemplateClient) CreateBulk(builders ...*OncallHandoverTemplateCreate) *OncallHandoverTemplateCreateBulk {
	return &OncallHandoverTemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallHandoverTemplateClient) MapCreateBulk(slice any, setFunc func(*OncallHandoverTemplateCreate, int)) *OncallHandoverTemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallHandoverTemplateCreateBulk{err: fmt.Errorf("calling to OncallHandoverTemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallHandoverTemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallHandoverTemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallHandoverTemplate.
func (c *OncallHandoverTemplateClient) Update() *OncallHandoverTemplateUpdate {
	mutation := newOncallHandoverTemplateMutation(c.config, OpUpdate)
	return &OncallHandoverTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallHandoverTemplateClient) UpdateOne(oht *OncallHandoverTemplate) *OncallHandoverTemplateUpdateOne {
	mutation := newOncallHandoverTemplateMutation(c.config, OpUpdateOne, withOncallHandoverTemplate(oht))
	return &OncallHandoverTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallHandoverTemplateClient) UpdateOneID(id uuid.UUID) *OncallHandoverTemplateUpdateOne {
	mutation := newOncallHandoverTemplateMutation(c.config, OpUpdateOne, withOncallHandoverTemplateID(id))
	return &OncallHandoverTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallHandoverTemplate.
func (c *OncallHandoverTemplateClient) Delete() *OncallHandoverTemplateDelete {
	mutation := newOncallHandoverTemplateMutation(c.config, OpDelete)
	return &OncallHandoverTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallHandoverTemplateClient) DeleteOne(oht *OncallHandoverTemplate) *OncallHandoverTemplateDeleteOne {
	return c.DeleteOneID(oht.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallHandoverTemplateClient) DeleteOneID(id uuid.UUID) *OncallHandoverTemplateDeleteOne {
	builder := c.Delete().Where(oncallhandovertemplate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallHandoverTemplateDeleteOne{builder}
}

// Query returns a query builder for OncallHandoverTemplate.
func (c *OncallHandoverTemplateClient) Query() *OncallHandoverTemplateQuery {
	return &OncallHandoverTemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallHandoverTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallHandoverTemplate entity by its id.
func (c *OncallHandoverTemplateClient) Get(ctx context.Context, id uuid.UUID) (*OncallHandoverTemplate, error) {
	return c.Query().Where(oncallhandovertemplate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallHandoverTemplateClient) GetX(ctx context.Context, id uuid.UUID) *OncallHandoverTemplate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoster queries the roster edge of a OncallHandoverTemplate.
func (c *OncallHandoverTemplateClient) QueryRoster(oht *OncallHandoverTemplate) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oht.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallhandovertemplate.Table, oncallhandovertemplate.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oncallhandovertemplate.RosterTable, oncallhandovertemplate.RosterColumn),
		)
		fromV = sqlgraph.Neighbors(oht.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallHandoverTemplateClient) Hooks() []Hook {
	hooks := c.hooks.OncallHandoverTemplate
	return append(hooks[:len(hooks):len(hooks)], oncallhandovertemplate.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallHandoverTemplateClient) Interceptors() []Interceptor {
	return c.inters.OncallHandoverTemplate
}

func (c *OncallHandoverTemplateClient) mutate(ctx context.Context, m *OncallHandoverTemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallHandoverTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallHandoverTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallHandoverTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallHandoverTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallHandoverTemplate mutation op: %q", m.Op())
	}
}

// OncallRosterClient is a client for the OncallRoster schema.
type OncallRosterClient struct {
	config
}

// NewOncallRosterClient returns a client for the OncallRoster from the given config.
func NewOncallRosterClient(c config) *OncallRosterClient {
	return &OncallRosterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallroster.Hooks(f(g(h())))`.
func (c *OncallRosterClient) Use(hooks ...Hook) {
	c.hooks.OncallRoster = append(c.hooks.OncallRoster, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallroster.Intercept(f(g(h())))`.
func (c *OncallRosterClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallRoster = append(c.inters.OncallRoster, interceptors...)
}

// Create returns a builder for creating a OncallRoster entity.
func (c *OncallRosterClient) Create() *OncallRosterCreate {
	mutation := newOncallRosterMutation(c.config, OpCreate)
	return &OncallRosterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallRoster entities.
func (c *OncallRosterClient) CreateBulk(builders ...*OncallRosterCreate) *OncallRosterCreateBulk {
	return &OncallRosterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallRosterClient) MapCreateBulk(slice any, setFunc func(*OncallRosterCreate, int)) *OncallRosterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallRosterCreateBulk{err: fmt.Errorf("calling to OncallRosterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallRosterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallRosterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallRoster.
func (c *OncallRosterClient) Update() *OncallRosterUpdate {
	mutation := newOncallRosterMutation(c.config, OpUpdate)
	return &OncallRosterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallRosterClient) UpdateOne(or *OncallRoster) *OncallRosterUpdateOne {
	mutation := newOncallRosterMutation(c.config, OpUpdateOne, withOncallRoster(or))
	return &OncallRosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallRosterClient) UpdateOneID(id uuid.UUID) *OncallRosterUpdateOne {
	mutation := newOncallRosterMutation(c.config, OpUpdateOne, withOncallRosterID(id))
	return &OncallRosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallRoster.
func (c *OncallRosterClient) Delete() *OncallRosterDelete {
	mutation := newOncallRosterMutation(c.config, OpDelete)
	return &OncallRosterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallRosterClient) DeleteOne(or *OncallRoster) *OncallRosterDeleteOne {
	return c.DeleteOneID(or.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallRosterClient) DeleteOneID(id uuid.UUID) *OncallRosterDeleteOne {
	builder := c.Delete().Where(oncallroster.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallRosterDeleteOne{builder}
}

// Query returns a query builder for OncallRoster.
func (c *OncallRosterClient) Query() *OncallRosterQuery {
	return &OncallRosterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallRoster},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallRoster entity by its id.
func (c *OncallRosterClient) Get(ctx context.Context, id uuid.UUID) (*OncallRoster, error) {
	return c.Query().Where(oncallroster.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallRosterClient) GetX(ctx context.Context, id uuid.UUID) *OncallRoster {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySchedules queries the schedules edge of a OncallRoster.
func (c *OncallRosterClient) QuerySchedules(or *OncallRoster) *OncallScheduleQuery {
	query := (&OncallScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(oncallschedule.Table, oncallschedule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oncallroster.SchedulesTable, oncallroster.SchedulesColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHandoverTemplate queries the handover_template edge of a OncallRoster.
func (c *OncallRosterClient) QueryHandoverTemplate(or *OncallRoster) *OncallHandoverTemplateQuery {
	query := (&OncallHandoverTemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(oncallhandovertemplate.Table, oncallhandovertemplate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oncallroster.HandoverTemplateTable, oncallroster.HandoverTemplateColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a OncallRoster.
func (c *OncallRosterClient) QueryEvents(or *OncallRoster) *OncallEventQuery {
	query := (&OncallEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(oncallevent.Table, oncallevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, oncallroster.EventsTable, oncallroster.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnnotations queries the annotations edge of a OncallRoster.
func (c *OncallRosterClient) QueryAnnotations(or *OncallRoster) *OncallAnnotationQuery {
	query := (&OncallAnnotationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(oncallannotation.Table, oncallannotation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, oncallroster.AnnotationsTable, oncallroster.AnnotationsColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the teams edge of a OncallRoster.
func (c *OncallRosterClient) QueryTeams(or *OncallRoster) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, oncallroster.TeamsTable, oncallroster.TeamsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShifts queries the shifts edge of a OncallRoster.
func (c *OncallRosterClient) QueryShifts(or *OncallRoster) *OncallUserShiftQuery {
	query := (&OncallUserShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(oncallusershift.Table, oncallusershift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, oncallroster.ShiftsTable, oncallroster.ShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserWatchers queries the user_watchers edge of a OncallRoster.
func (c *OncallRosterClient) QueryUserWatchers(or *OncallRoster) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, oncallroster.UserWatchersTable, oncallroster.UserWatchersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetrics queries the metrics edge of a OncallRoster.
func (c *OncallRosterClient) QueryMetrics(or *OncallRoster) *OncallRosterMetricsQuery {
	query := (&OncallRosterMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(oncallrostermetrics.Table, oncallrostermetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, oncallroster.MetricsTable, oncallroster.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallRosterClient) Hooks() []Hook {
	hooks := c.hooks.OncallRoster
	return append(hooks[:len(hooks):len(hooks)], oncallroster.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallRosterClient) Interceptors() []Interceptor {
	inters := c.inters.OncallRoster
	return append(inters[:len(inters):len(inters)], oncallroster.Interceptors[:]...)
}

func (c *OncallRosterClient) mutate(ctx context.Context, m *OncallRosterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallRosterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallRosterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallRosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallRosterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallRoster mutation op: %q", m.Op())
	}
}

// OncallRosterMetricsClient is a client for the OncallRosterMetrics schema.
type OncallRosterMetricsClient struct {
	config
}

// NewOncallRosterMetricsClient returns a client for the OncallRosterMetrics from the given config.
func NewOncallRosterMetricsClient(c config) *OncallRosterMetricsClient {
	return &OncallRosterMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallrostermetrics.Hooks(f(g(h())))`.
func (c *OncallRosterMetricsClient) Use(hooks ...Hook) {
	c.hooks.OncallRosterMetrics = append(c.hooks.OncallRosterMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallrostermetrics.Intercept(f(g(h())))`.
func (c *OncallRosterMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallRosterMetrics = append(c.inters.OncallRosterMetrics, interceptors...)
}

// Create returns a builder for creating a OncallRosterMetrics entity.
func (c *OncallRosterMetricsClient) Create() *OncallRosterMetricsCreate {
	mutation := newOncallRosterMetricsMutation(c.config, OpCreate)
	return &OncallRosterMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallRosterMetrics entities.
func (c *OncallRosterMetricsClient) CreateBulk(builders ...*OncallRosterMetricsCreate) *OncallRosterMetricsCreateBulk {
	return &OncallRosterMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallRosterMetricsClient) MapCreateBulk(slice any, setFunc func(*OncallRosterMetricsCreate, int)) *OncallRosterMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallRosterMetricsCreateBulk{err: fmt.Errorf("calling to OncallRosterMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallRosterMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallRosterMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallRosterMetrics.
func (c *OncallRosterMetricsClient) Update() *OncallRosterMetricsUpdate {
	mutation := newOncallRosterMetricsMutation(c.config, OpUpdate)
	return &OncallRosterMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallRosterMetricsClient) UpdateOne(orm *OncallRosterMetrics) *OncallRosterMetricsUpdateOne {
	mutation := newOncallRosterMetricsMutation(c.config, OpUpdateOne, withOncallRosterMetrics(orm))
	return &OncallRosterMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallRosterMetricsClient) UpdateOneID(id uuid.UUID) *OncallRosterMetricsUpdateOne {
	mutation := newOncallRosterMetricsMutation(c.config, OpUpdateOne, withOncallRosterMetricsID(id))
	return &OncallRosterMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallRosterMetrics.
func (c *OncallRosterMetricsClient) Delete() *OncallRosterMetricsDelete {
	mutation := newOncallRosterMetricsMutation(c.config, OpDelete)
	return &OncallRosterMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallRosterMetricsClient) DeleteOne(orm *OncallRosterMetrics) *OncallRosterMetricsDeleteOne {
	return c.DeleteOneID(orm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallRosterMetricsClient) DeleteOneID(id uuid.UUID) *OncallRosterMetricsDeleteOne {
	builder := c.Delete().Where(oncallrostermetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallRosterMetricsDeleteOne{builder}
}

// Query returns a query builder for OncallRosterMetrics.
func (c *OncallRosterMetricsClient) Query() *OncallRosterMetricsQuery {
	return &OncallRosterMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallRosterMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallRosterMetrics entity by its id.
func (c *OncallRosterMetricsClient) Get(ctx context.Context, id uuid.UUID) (*OncallRosterMetrics, error) {
	return c.Query().Where(oncallrostermetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallRosterMetricsClient) GetX(ctx context.Context, id uuid.UUID) *OncallRosterMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoster queries the roster edge of a OncallRosterMetrics.
func (c *OncallRosterMetricsClient) QueryRoster(orm *OncallRosterMetrics) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := orm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallrostermetrics.Table, oncallrostermetrics.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallrostermetrics.RosterTable, oncallrostermetrics.RosterColumn),
		)
		fromV = sqlgraph.Neighbors(orm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallRosterMetricsClient) Hooks() []Hook {
	hooks := c.hooks.OncallRosterMetrics
	return append(hooks[:len(hooks):len(hooks)], oncallrostermetrics.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallRosterMetricsClient) Interceptors() []Interceptor {
	return c.inters.OncallRosterMetrics
}

func (c *OncallRosterMetricsClient) mutate(ctx context.Context, m *OncallRosterMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallRosterMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallRosterMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallRosterMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallRosterMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallRosterMetrics mutation op: %q", m.Op())
	}
}

// OncallScheduleClient is a client for the OncallSchedule schema.
type OncallScheduleClient struct {
	config
}

// NewOncallScheduleClient returns a client for the OncallSchedule from the given config.
func NewOncallScheduleClient(c config) *OncallScheduleClient {
	return &OncallScheduleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallschedule.Hooks(f(g(h())))`.
func (c *OncallScheduleClient) Use(hooks ...Hook) {
	c.hooks.OncallSchedule = append(c.hooks.OncallSchedule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallschedule.Intercept(f(g(h())))`.
func (c *OncallScheduleClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallSchedule = append(c.inters.OncallSchedule, interceptors...)
}

// Create returns a builder for creating a OncallSchedule entity.
func (c *OncallScheduleClient) Create() *OncallScheduleCreate {
	mutation := newOncallScheduleMutation(c.config, OpCreate)
	return &OncallScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallSchedule entities.
func (c *OncallScheduleClient) CreateBulk(builders ...*OncallScheduleCreate) *OncallScheduleCreateBulk {
	return &OncallScheduleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallScheduleClient) MapCreateBulk(slice any, setFunc func(*OncallScheduleCreate, int)) *OncallScheduleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallScheduleCreateBulk{err: fmt.Errorf("calling to OncallScheduleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallScheduleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallScheduleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallSchedule.
func (c *OncallScheduleClient) Update() *OncallScheduleUpdate {
	mutation := newOncallScheduleMutation(c.config, OpUpdate)
	return &OncallScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallScheduleClient) UpdateOne(os *OncallSchedule) *OncallScheduleUpdateOne {
	mutation := newOncallScheduleMutation(c.config, OpUpdateOne, withOncallSchedule(os))
	return &OncallScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallScheduleClient) UpdateOneID(id uuid.UUID) *OncallScheduleUpdateOne {
	mutation := newOncallScheduleMutation(c.config, OpUpdateOne, withOncallScheduleID(id))
	return &OncallScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallSchedule.
func (c *OncallScheduleClient) Delete() *OncallScheduleDelete {
	mutation := newOncallScheduleMutation(c.config, OpDelete)
	return &OncallScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallScheduleClient) DeleteOne(os *OncallSchedule) *OncallScheduleDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallScheduleClient) DeleteOneID(id uuid.UUID) *OncallScheduleDeleteOne {
	builder := c.Delete().Where(oncallschedule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallScheduleDeleteOne{builder}
}

// Query returns a query builder for OncallSchedule.
func (c *OncallScheduleClient) Query() *OncallScheduleQuery {
	return &OncallScheduleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallSchedule},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallSchedule entity by its id.
func (c *OncallScheduleClient) Get(ctx context.Context, id uuid.UUID) (*OncallSchedule, error) {
	return c.Query().Where(oncallschedule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallScheduleClient) GetX(ctx context.Context, id uuid.UUID) *OncallSchedule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParticipants queries the participants edge of a OncallSchedule.
func (c *OncallScheduleClient) QueryParticipants(os *OncallSchedule) *OncallScheduleParticipantQuery {
	query := (&OncallScheduleParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallschedule.Table, oncallschedule.FieldID, id),
			sqlgraph.To(oncallscheduleparticipant.Table, oncallscheduleparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oncallschedule.ParticipantsTable, oncallschedule.ParticipantsColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoster queries the roster edge of a OncallSchedule.
func (c *OncallScheduleClient) QueryRoster(os *OncallSchedule) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallschedule.Table, oncallschedule.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oncallschedule.RosterTable, oncallschedule.RosterColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallScheduleClient) Hooks() []Hook {
	hooks := c.hooks.OncallSchedule
	return append(hooks[:len(hooks):len(hooks)], oncallschedule.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallScheduleClient) Interceptors() []Interceptor {
	inters := c.inters.OncallSchedule
	return append(inters[:len(inters):len(inters)], oncallschedule.Interceptors[:]...)
}

func (c *OncallScheduleClient) mutate(ctx context.Context, m *OncallScheduleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallSchedule mutation op: %q", m.Op())
	}
}

// OncallScheduleParticipantClient is a client for the OncallScheduleParticipant schema.
type OncallScheduleParticipantClient struct {
	config
}

// NewOncallScheduleParticipantClient returns a client for the OncallScheduleParticipant from the given config.
func NewOncallScheduleParticipantClient(c config) *OncallScheduleParticipantClient {
	return &OncallScheduleParticipantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallscheduleparticipant.Hooks(f(g(h())))`.
func (c *OncallScheduleParticipantClient) Use(hooks ...Hook) {
	c.hooks.OncallScheduleParticipant = append(c.hooks.OncallScheduleParticipant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallscheduleparticipant.Intercept(f(g(h())))`.
func (c *OncallScheduleParticipantClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallScheduleParticipant = append(c.inters.OncallScheduleParticipant, interceptors...)
}

// Create returns a builder for creating a OncallScheduleParticipant entity.
func (c *OncallScheduleParticipantClient) Create() *OncallScheduleParticipantCreate {
	mutation := newOncallScheduleParticipantMutation(c.config, OpCreate)
	return &OncallScheduleParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallScheduleParticipant entities.
func (c *OncallScheduleParticipantClient) CreateBulk(builders ...*OncallScheduleParticipantCreate) *OncallScheduleParticipantCreateBulk {
	return &OncallScheduleParticipantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallScheduleParticipantClient) MapCreateBulk(slice any, setFunc func(*OncallScheduleParticipantCreate, int)) *OncallScheduleParticipantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallScheduleParticipantCreateBulk{err: fmt.Errorf("calling to OncallScheduleParticipantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallScheduleParticipantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallScheduleParticipantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallScheduleParticipant.
func (c *OncallScheduleParticipantClient) Update() *OncallScheduleParticipantUpdate {
	mutation := newOncallScheduleParticipantMutation(c.config, OpUpdate)
	return &OncallScheduleParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallScheduleParticipantClient) UpdateOne(osp *OncallScheduleParticipant) *OncallScheduleParticipantUpdateOne {
	mutation := newOncallScheduleParticipantMutation(c.config, OpUpdateOne, withOncallScheduleParticipant(osp))
	return &OncallScheduleParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallScheduleParticipantClient) UpdateOneID(id uuid.UUID) *OncallScheduleParticipantUpdateOne {
	mutation := newOncallScheduleParticipantMutation(c.config, OpUpdateOne, withOncallScheduleParticipantID(id))
	return &OncallScheduleParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallScheduleParticipant.
func (c *OncallScheduleParticipantClient) Delete() *OncallScheduleParticipantDelete {
	mutation := newOncallScheduleParticipantMutation(c.config, OpDelete)
	return &OncallScheduleParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallScheduleParticipantClient) DeleteOne(osp *OncallScheduleParticipant) *OncallScheduleParticipantDeleteOne {
	return c.DeleteOneID(osp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallScheduleParticipantClient) DeleteOneID(id uuid.UUID) *OncallScheduleParticipantDeleteOne {
	builder := c.Delete().Where(oncallscheduleparticipant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallScheduleParticipantDeleteOne{builder}
}

// Query returns a query builder for OncallScheduleParticipant.
func (c *OncallScheduleParticipantClient) Query() *OncallScheduleParticipantQuery {
	return &OncallScheduleParticipantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallScheduleParticipant},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallScheduleParticipant entity by its id.
func (c *OncallScheduleParticipantClient) Get(ctx context.Context, id uuid.UUID) (*OncallScheduleParticipant, error) {
	return c.Query().Where(oncallscheduleparticipant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallScheduleParticipantClient) GetX(ctx context.Context, id uuid.UUID) *OncallScheduleParticipant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySchedule queries the schedule edge of a OncallScheduleParticipant.
func (c *OncallScheduleParticipantClient) QuerySchedule(osp *OncallScheduleParticipant) *OncallScheduleQuery {
	query := (&OncallScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := osp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallscheduleparticipant.Table, oncallscheduleparticipant.FieldID, id),
			sqlgraph.To(oncallschedule.Table, oncallschedule.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oncallscheduleparticipant.ScheduleTable, oncallscheduleparticipant.ScheduleColumn),
		)
		fromV = sqlgraph.Neighbors(osp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OncallScheduleParticipant.
func (c *OncallScheduleParticipantClient) QueryUser(osp *OncallScheduleParticipant) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := osp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallscheduleparticipant.Table, oncallscheduleparticipant.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallscheduleparticipant.UserTable, oncallscheduleparticipant.UserColumn),
		)
		fromV = sqlgraph.Neighbors(osp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallScheduleParticipantClient) Hooks() []Hook {
	hooks := c.hooks.OncallScheduleParticipant
	return append(hooks[:len(hooks):len(hooks)], oncallscheduleparticipant.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallScheduleParticipantClient) Interceptors() []Interceptor {
	return c.inters.OncallScheduleParticipant
}

func (c *OncallScheduleParticipantClient) mutate(ctx context.Context, m *OncallScheduleParticipantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallScheduleParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallScheduleParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallScheduleParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallScheduleParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallScheduleParticipant mutation op: %q", m.Op())
	}
}

// OncallUserShiftClient is a client for the OncallUserShift schema.
type OncallUserShiftClient struct {
	config
}

// NewOncallUserShiftClient returns a client for the OncallUserShift from the given config.
func NewOncallUserShiftClient(c config) *OncallUserShiftClient {
	return &OncallUserShiftClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallusershift.Hooks(f(g(h())))`.
func (c *OncallUserShiftClient) Use(hooks ...Hook) {
	c.hooks.OncallUserShift = append(c.hooks.OncallUserShift, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallusershift.Intercept(f(g(h())))`.
func (c *OncallUserShiftClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallUserShift = append(c.inters.OncallUserShift, interceptors...)
}

// Create returns a builder for creating a OncallUserShift entity.
func (c *OncallUserShiftClient) Create() *OncallUserShiftCreate {
	mutation := newOncallUserShiftMutation(c.config, OpCreate)
	return &OncallUserShiftCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallUserShift entities.
func (c *OncallUserShiftClient) CreateBulk(builders ...*OncallUserShiftCreate) *OncallUserShiftCreateBulk {
	return &OncallUserShiftCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallUserShiftClient) MapCreateBulk(slice any, setFunc func(*OncallUserShiftCreate, int)) *OncallUserShiftCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallUserShiftCreateBulk{err: fmt.Errorf("calling to OncallUserShiftClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallUserShiftCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallUserShiftCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallUserShift.
func (c *OncallUserShiftClient) Update() *OncallUserShiftUpdate {
	mutation := newOncallUserShiftMutation(c.config, OpUpdate)
	return &OncallUserShiftUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallUserShiftClient) UpdateOne(ous *OncallUserShift) *OncallUserShiftUpdateOne {
	mutation := newOncallUserShiftMutation(c.config, OpUpdateOne, withOncallUserShift(ous))
	return &OncallUserShiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallUserShiftClient) UpdateOneID(id uuid.UUID) *OncallUserShiftUpdateOne {
	mutation := newOncallUserShiftMutation(c.config, OpUpdateOne, withOncallUserShiftID(id))
	return &OncallUserShiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallUserShift.
func (c *OncallUserShiftClient) Delete() *OncallUserShiftDelete {
	mutation := newOncallUserShiftMutation(c.config, OpDelete)
	return &OncallUserShiftDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallUserShiftClient) DeleteOne(ous *OncallUserShift) *OncallUserShiftDeleteOne {
	return c.DeleteOneID(ous.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallUserShiftClient) DeleteOneID(id uuid.UUID) *OncallUserShiftDeleteOne {
	builder := c.Delete().Where(oncallusershift.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallUserShiftDeleteOne{builder}
}

// Query returns a query builder for OncallUserShift.
func (c *OncallUserShiftClient) Query() *OncallUserShiftQuery {
	return &OncallUserShiftQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallUserShift},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallUserShift entity by its id.
func (c *OncallUserShiftClient) Get(ctx context.Context, id uuid.UUID) (*OncallUserShift, error) {
	return c.Query().Where(oncallusershift.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallUserShiftClient) GetX(ctx context.Context, id uuid.UUID) *OncallUserShift {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a OncallUserShift.
func (c *OncallUserShiftClient) QueryUser(ous *OncallUserShift) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ous.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershift.Table, oncallusershift.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallusershift.UserTable, oncallusershift.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ous.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoster queries the roster edge of a OncallUserShift.
func (c *OncallUserShiftClient) QueryRoster(ous *OncallUserShift) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ous.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershift.Table, oncallusershift.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallusershift.RosterTable, oncallusershift.RosterColumn),
		)
		fromV = sqlgraph.Neighbors(ous.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrimaryShift queries the primary_shift edge of a OncallUserShift.
func (c *OncallUserShiftClient) QueryPrimaryShift(ous *OncallUserShift) *OncallUserShiftQuery {
	query := (&OncallUserShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ous.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershift.Table, oncallusershift.FieldID, id),
			sqlgraph.To(oncallusershift.Table, oncallusershift.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oncallusershift.PrimaryShiftTable, oncallusershift.PrimaryShiftColumn),
		)
		fromV = sqlgraph.Neighbors(ous.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHandover queries the handover edge of a OncallUserShift.
func (c *OncallUserShiftClient) QueryHandover(ous *OncallUserShift) *OncallUserShiftHandoverQuery {
	query := (&OncallUserShiftHandoverClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ous.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershift.Table, oncallusershift.FieldID, id),
			sqlgraph.To(oncallusershifthandover.Table, oncallusershifthandover.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oncallusershift.HandoverTable, oncallusershift.HandoverColumn),
		)
		fromV = sqlgraph.Neighbors(ous.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetrics queries the metrics edge of a OncallUserShift.
func (c *OncallUserShiftClient) QueryMetrics(ous *OncallUserShift) *OncallUserShiftMetricsQuery {
	query := (&OncallUserShiftMetricsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ous.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershift.Table, oncallusershift.FieldID, id),
			sqlgraph.To(oncallusershiftmetrics.Table, oncallusershiftmetrics.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oncallusershift.MetricsTable, oncallusershift.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(ous.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallUserShiftClient) Hooks() []Hook {
	hooks := c.hooks.OncallUserShift
	return append(hooks[:len(hooks):len(hooks)], oncallusershift.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallUserShiftClient) Interceptors() []Interceptor {
	return c.inters.OncallUserShift
}

func (c *OncallUserShiftClient) mutate(ctx context.Context, m *OncallUserShiftMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallUserShiftCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallUserShiftUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallUserShiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallUserShiftDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallUserShift mutation op: %q", m.Op())
	}
}

// OncallUserShiftHandoverClient is a client for the OncallUserShiftHandover schema.
type OncallUserShiftHandoverClient struct {
	config
}

// NewOncallUserShiftHandoverClient returns a client for the OncallUserShiftHandover from the given config.
func NewOncallUserShiftHandoverClient(c config) *OncallUserShiftHandoverClient {
	return &OncallUserShiftHandoverClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallusershifthandover.Hooks(f(g(h())))`.
func (c *OncallUserShiftHandoverClient) Use(hooks ...Hook) {
	c.hooks.OncallUserShiftHandover = append(c.hooks.OncallUserShiftHandover, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallusershifthandover.Intercept(f(g(h())))`.
func (c *OncallUserShiftHandoverClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallUserShiftHandover = append(c.inters.OncallUserShiftHandover, interceptors...)
}

// Create returns a builder for creating a OncallUserShiftHandover entity.
func (c *OncallUserShiftHandoverClient) Create() *OncallUserShiftHandoverCreate {
	mutation := newOncallUserShiftHandoverMutation(c.config, OpCreate)
	return &OncallUserShiftHandoverCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallUserShiftHandover entities.
func (c *OncallUserShiftHandoverClient) CreateBulk(builders ...*OncallUserShiftHandoverCreate) *OncallUserShiftHandoverCreateBulk {
	return &OncallUserShiftHandoverCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallUserShiftHandoverClient) MapCreateBulk(slice any, setFunc func(*OncallUserShiftHandoverCreate, int)) *OncallUserShiftHandoverCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallUserShiftHandoverCreateBulk{err: fmt.Errorf("calling to OncallUserShiftHandoverClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallUserShiftHandoverCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallUserShiftHandoverCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallUserShiftHandover.
func (c *OncallUserShiftHandoverClient) Update() *OncallUserShiftHandoverUpdate {
	mutation := newOncallUserShiftHandoverMutation(c.config, OpUpdate)
	return &OncallUserShiftHandoverUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallUserShiftHandoverClient) UpdateOne(oush *OncallUserShiftHandover) *OncallUserShiftHandoverUpdateOne {
	mutation := newOncallUserShiftHandoverMutation(c.config, OpUpdateOne, withOncallUserShiftHandover(oush))
	return &OncallUserShiftHandoverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallUserShiftHandoverClient) UpdateOneID(id uuid.UUID) *OncallUserShiftHandoverUpdateOne {
	mutation := newOncallUserShiftHandoverMutation(c.config, OpUpdateOne, withOncallUserShiftHandoverID(id))
	return &OncallUserShiftHandoverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallUserShiftHandover.
func (c *OncallUserShiftHandoverClient) Delete() *OncallUserShiftHandoverDelete {
	mutation := newOncallUserShiftHandoverMutation(c.config, OpDelete)
	return &OncallUserShiftHandoverDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallUserShiftHandoverClient) DeleteOne(oush *OncallUserShiftHandover) *OncallUserShiftHandoverDeleteOne {
	return c.DeleteOneID(oush.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallUserShiftHandoverClient) DeleteOneID(id uuid.UUID) *OncallUserShiftHandoverDeleteOne {
	builder := c.Delete().Where(oncallusershifthandover.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallUserShiftHandoverDeleteOne{builder}
}

// Query returns a query builder for OncallUserShiftHandover.
func (c *OncallUserShiftHandoverClient) Query() *OncallUserShiftHandoverQuery {
	return &OncallUserShiftHandoverQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallUserShiftHandover},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallUserShiftHandover entity by its id.
func (c *OncallUserShiftHandoverClient) Get(ctx context.Context, id uuid.UUID) (*OncallUserShiftHandover, error) {
	return c.Query().Where(oncallusershifthandover.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallUserShiftHandoverClient) GetX(ctx context.Context, id uuid.UUID) *OncallUserShiftHandover {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryShift queries the shift edge of a OncallUserShiftHandover.
func (c *OncallUserShiftHandoverClient) QueryShift(oush *OncallUserShiftHandover) *OncallUserShiftQuery {
	query := (&OncallUserShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oush.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershifthandover.Table, oncallusershifthandover.FieldID, id),
			sqlgraph.To(oncallusershift.Table, oncallusershift.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, oncallusershifthandover.ShiftTable, oncallusershifthandover.ShiftColumn),
		)
		fromV = sqlgraph.Neighbors(oush.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPinnedAnnotations queries the pinned_annotations edge of a OncallUserShiftHandover.
func (c *OncallUserShiftHandoverClient) QueryPinnedAnnotations(oush *OncallUserShiftHandover) *OncallAnnotationQuery {
	query := (&OncallAnnotationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oush.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershifthandover.Table, oncallusershifthandover.FieldID, id),
			sqlgraph.To(oncallannotation.Table, oncallannotation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, oncallusershifthandover.PinnedAnnotationsTable, oncallusershifthandover.PinnedAnnotationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(oush.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallUserShiftHandoverClient) Hooks() []Hook {
	hooks := c.hooks.OncallUserShiftHandover
	return append(hooks[:len(hooks):len(hooks)], oncallusershifthandover.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallUserShiftHandoverClient) Interceptors() []Interceptor {
	return c.inters.OncallUserShiftHandover
}

func (c *OncallUserShiftHandoverClient) mutate(ctx context.Context, m *OncallUserShiftHandoverMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallUserShiftHandoverCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallUserShiftHandoverUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallUserShiftHandoverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallUserShiftHandoverDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallUserShiftHandover mutation op: %q", m.Op())
	}
}

// OncallUserShiftMetricsClient is a client for the OncallUserShiftMetrics schema.
type OncallUserShiftMetricsClient struct {
	config
}

// NewOncallUserShiftMetricsClient returns a client for the OncallUserShiftMetrics from the given config.
func NewOncallUserShiftMetricsClient(c config) *OncallUserShiftMetricsClient {
	return &OncallUserShiftMetricsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallusershiftmetrics.Hooks(f(g(h())))`.
func (c *OncallUserShiftMetricsClient) Use(hooks ...Hook) {
	c.hooks.OncallUserShiftMetrics = append(c.hooks.OncallUserShiftMetrics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallusershiftmetrics.Intercept(f(g(h())))`.
func (c *OncallUserShiftMetricsClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallUserShiftMetrics = append(c.inters.OncallUserShiftMetrics, interceptors...)
}

// Create returns a builder for creating a OncallUserShiftMetrics entity.
func (c *OncallUserShiftMetricsClient) Create() *OncallUserShiftMetricsCreate {
	mutation := newOncallUserShiftMetricsMutation(c.config, OpCreate)
	return &OncallUserShiftMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallUserShiftMetrics entities.
func (c *OncallUserShiftMetricsClient) CreateBulk(builders ...*OncallUserShiftMetricsCreate) *OncallUserShiftMetricsCreateBulk {
	return &OncallUserShiftMetricsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallUserShiftMetricsClient) MapCreateBulk(slice any, setFunc func(*OncallUserShiftMetricsCreate, int)) *OncallUserShiftMetricsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallUserShiftMetricsCreateBulk{err: fmt.Errorf("calling to OncallUserShiftMetricsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallUserShiftMetricsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallUserShiftMetricsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallUserShiftMetrics.
func (c *OncallUserShiftMetricsClient) Update() *OncallUserShiftMetricsUpdate {
	mutation := newOncallUserShiftMetricsMutation(c.config, OpUpdate)
	return &OncallUserShiftMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallUserShiftMetricsClient) UpdateOne(ousm *OncallUserShiftMetrics) *OncallUserShiftMetricsUpdateOne {
	mutation := newOncallUserShiftMetricsMutation(c.config, OpUpdateOne, withOncallUserShiftMetrics(ousm))
	return &OncallUserShiftMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallUserShiftMetricsClient) UpdateOneID(id uuid.UUID) *OncallUserShiftMetricsUpdateOne {
	mutation := newOncallUserShiftMetricsMutation(c.config, OpUpdateOne, withOncallUserShiftMetricsID(id))
	return &OncallUserShiftMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallUserShiftMetrics.
func (c *OncallUserShiftMetricsClient) Delete() *OncallUserShiftMetricsDelete {
	mutation := newOncallUserShiftMetricsMutation(c.config, OpDelete)
	return &OncallUserShiftMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallUserShiftMetricsClient) DeleteOne(ousm *OncallUserShiftMetrics) *OncallUserShiftMetricsDeleteOne {
	return c.DeleteOneID(ousm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallUserShiftMetricsClient) DeleteOneID(id uuid.UUID) *OncallUserShiftMetricsDeleteOne {
	builder := c.Delete().Where(oncallusershiftmetrics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallUserShiftMetricsDeleteOne{builder}
}

// Query returns a query builder for OncallUserShiftMetrics.
func (c *OncallUserShiftMetricsClient) Query() *OncallUserShiftMetricsQuery {
	return &OncallUserShiftMetricsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallUserShiftMetrics},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallUserShiftMetrics entity by its id.
func (c *OncallUserShiftMetricsClient) Get(ctx context.Context, id uuid.UUID) (*OncallUserShiftMetrics, error) {
	return c.Query().Where(oncallusershiftmetrics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallUserShiftMetricsClient) GetX(ctx context.Context, id uuid.UUID) *OncallUserShiftMetrics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryShift queries the shift edge of a OncallUserShiftMetrics.
func (c *OncallUserShiftMetricsClient) QueryShift(ousm *OncallUserShiftMetrics) *OncallUserShiftQuery {
	query := (&OncallUserShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ousm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershiftmetrics.Table, oncallusershiftmetrics.FieldID, id),
			sqlgraph.To(oncallusershift.Table, oncallusershift.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, oncallusershiftmetrics.ShiftTable, oncallusershiftmetrics.ShiftColumn),
		)
		fromV = sqlgraph.Neighbors(ousm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallUserShiftMetricsClient) Hooks() []Hook {
	hooks := c.hooks.OncallUserShiftMetrics
	return append(hooks[:len(hooks):len(hooks)], oncallusershiftmetrics.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallUserShiftMetricsClient) Interceptors() []Interceptor {
	return c.inters.OncallUserShiftMetrics
}

func (c *OncallUserShiftMetricsClient) mutate(ctx context.Context, m *OncallUserShiftMetricsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallUserShiftMetricsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallUserShiftMetricsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallUserShiftMetricsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallUserShiftMetricsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallUserShiftMetrics mutation op: %q", m.Op())
	}
}

// PlaybookClient is a client for the Playbook schema.
type PlaybookClient struct {
	config
}

// NewPlaybookClient returns a client for the Playbook from the given config.
func NewPlaybookClient(c config) *PlaybookClient {
	return &PlaybookClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `playbook.Hooks(f(g(h())))`.
func (c *PlaybookClient) Use(hooks ...Hook) {
	c.hooks.Playbook = append(c.hooks.Playbook, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `playbook.Intercept(f(g(h())))`.
func (c *PlaybookClient) Intercept(interceptors ...Interceptor) {
	c.inters.Playbook = append(c.inters.Playbook, interceptors...)
}

// Create returns a builder for creating a Playbook entity.
func (c *PlaybookClient) Create() *PlaybookCreate {
	mutation := newPlaybookMutation(c.config, OpCreate)
	return &PlaybookCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Playbook entities.
func (c *PlaybookClient) CreateBulk(builders ...*PlaybookCreate) *PlaybookCreateBulk {
	return &PlaybookCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlaybookClient) MapCreateBulk(slice any, setFunc func(*PlaybookCreate, int)) *PlaybookCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlaybookCreateBulk{err: fmt.Errorf("calling to PlaybookClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlaybookCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlaybookCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Playbook.
func (c *PlaybookClient) Update() *PlaybookUpdate {
	mutation := newPlaybookMutation(c.config, OpUpdate)
	return &PlaybookUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlaybookClient) UpdateOne(pl *Playbook) *PlaybookUpdateOne {
	mutation := newPlaybookMutation(c.config, OpUpdateOne, withPlaybook(pl))
	return &PlaybookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlaybookClient) UpdateOneID(id uuid.UUID) *PlaybookUpdateOne {
	mutation := newPlaybookMutation(c.config, OpUpdateOne, withPlaybookID(id))
	return &PlaybookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Playbook.
func (c *PlaybookClient) Delete() *PlaybookDelete {
	mutation := newPlaybookMutation(c.config, OpDelete)
	return &PlaybookDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlaybookClient) DeleteOne(pl *Playbook) *PlaybookDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlaybookClient) DeleteOneID(id uuid.UUID) *PlaybookDeleteOne {
	builder := c.Delete().Where(playbook.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlaybookDeleteOne{builder}
}

// Query returns a query builder for Playbook.
func (c *PlaybookClient) Query() *PlaybookQuery {
	return &PlaybookQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlaybook},
		inters: c.Interceptors(),
	}
}

// Get returns a Playbook entity by its id.
func (c *PlaybookClient) Get(ctx context.Context, id uuid.UUID) (*Playbook, error) {
	return c.Query().Where(playbook.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlaybookClient) GetX(ctx context.Context, id uuid.UUID) *Playbook {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAlerts queries the alerts edge of a Playbook.
func (c *PlaybookClient) QueryAlerts(pl *Playbook) *AlertQuery {
	query := (&AlertClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playbook.Table, playbook.FieldID, id),
			sqlgraph.To(alert.Table, alert.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, playbook.AlertsTable, playbook.AlertsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlaybookClient) Hooks() []Hook {
	hooks := c.hooks.Playbook
	return append(hooks[:len(hooks):len(hooks)], playbook.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PlaybookClient) Interceptors() []Interceptor {
	return c.inters.Playbook
}

func (c *PlaybookClient) mutate(ctx context.Context, m *PlaybookMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlaybookCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlaybookUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlaybookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlaybookDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Playbook mutation op: %q", m.Op())
	}
}

// ProviderConfigClient is a client for the ProviderConfig schema.
type ProviderConfigClient struct {
	config
}

// NewProviderConfigClient returns a client for the ProviderConfig from the given config.
func NewProviderConfigClient(c config) *ProviderConfigClient {
	return &ProviderConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `providerconfig.Hooks(f(g(h())))`.
func (c *ProviderConfigClient) Use(hooks ...Hook) {
	c.hooks.ProviderConfig = append(c.hooks.ProviderConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `providerconfig.Intercept(f(g(h())))`.
func (c *ProviderConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProviderConfig = append(c.inters.ProviderConfig, interceptors...)
}

// Create returns a builder for creating a ProviderConfig entity.
func (c *ProviderConfigClient) Create() *ProviderConfigCreate {
	mutation := newProviderConfigMutation(c.config, OpCreate)
	return &ProviderConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProviderConfig entities.
func (c *ProviderConfigClient) CreateBulk(builders ...*ProviderConfigCreate) *ProviderConfigCreateBulk {
	return &ProviderConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProviderConfigClient) MapCreateBulk(slice any, setFunc func(*ProviderConfigCreate, int)) *ProviderConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProviderConfigCreateBulk{err: fmt.Errorf("calling to ProviderConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProviderConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProviderConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProviderConfig.
func (c *ProviderConfigClient) Update() *ProviderConfigUpdate {
	mutation := newProviderConfigMutation(c.config, OpUpdate)
	return &ProviderConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProviderConfigClient) UpdateOne(pc *ProviderConfig) *ProviderConfigUpdateOne {
	mutation := newProviderConfigMutation(c.config, OpUpdateOne, withProviderConfig(pc))
	return &ProviderConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProviderConfigClient) UpdateOneID(id uuid.UUID) *ProviderConfigUpdateOne {
	mutation := newProviderConfigMutation(c.config, OpUpdateOne, withProviderConfigID(id))
	return &ProviderConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProviderConfig.
func (c *ProviderConfigClient) Delete() *ProviderConfigDelete {
	mutation := newProviderConfigMutation(c.config, OpDelete)
	return &ProviderConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProviderConfigClient) DeleteOne(pc *ProviderConfig) *ProviderConfigDeleteOne {
	return c.DeleteOneID(pc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProviderConfigClient) DeleteOneID(id uuid.UUID) *ProviderConfigDeleteOne {
	builder := c.Delete().Where(providerconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProviderConfigDeleteOne{builder}
}

// Query returns a query builder for ProviderConfig.
func (c *ProviderConfigClient) Query() *ProviderConfigQuery {
	return &ProviderConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProviderConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a ProviderConfig entity by its id.
func (c *ProviderConfigClient) Get(ctx context.Context, id uuid.UUID) (*ProviderConfig, error) {
	return c.Query().Where(providerconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProviderConfigClient) GetX(ctx context.Context, id uuid.UUID) *ProviderConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProviderConfigClient) Hooks() []Hook {
	hooks := c.hooks.ProviderConfig
	return append(hooks[:len(hooks):len(hooks)], providerconfig.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProviderConfigClient) Interceptors() []Interceptor {
	return c.inters.ProviderConfig
}

func (c *ProviderConfigClient) mutate(ctx context.Context, m *ProviderConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProviderConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProviderConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProviderConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProviderConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProviderConfig mutation op: %q", m.Op())
	}
}

// ProviderSyncHistoryClient is a client for the ProviderSyncHistory schema.
type ProviderSyncHistoryClient struct {
	config
}

// NewProviderSyncHistoryClient returns a client for the ProviderSyncHistory from the given config.
func NewProviderSyncHistoryClient(c config) *ProviderSyncHistoryClient {
	return &ProviderSyncHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `providersynchistory.Hooks(f(g(h())))`.
func (c *ProviderSyncHistoryClient) Use(hooks ...Hook) {
	c.hooks.ProviderSyncHistory = append(c.hooks.ProviderSyncHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `providersynchistory.Intercept(f(g(h())))`.
func (c *ProviderSyncHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProviderSyncHistory = append(c.inters.ProviderSyncHistory, interceptors...)
}

// Create returns a builder for creating a ProviderSyncHistory entity.
func (c *ProviderSyncHistoryClient) Create() *ProviderSyncHistoryCreate {
	mutation := newProviderSyncHistoryMutation(c.config, OpCreate)
	return &ProviderSyncHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProviderSyncHistory entities.
func (c *ProviderSyncHistoryClient) CreateBulk(builders ...*ProviderSyncHistoryCreate) *ProviderSyncHistoryCreateBulk {
	return &ProviderSyncHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProviderSyncHistoryClient) MapCreateBulk(slice any, setFunc func(*ProviderSyncHistoryCreate, int)) *ProviderSyncHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProviderSyncHistoryCreateBulk{err: fmt.Errorf("calling to ProviderSyncHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProviderSyncHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProviderSyncHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProviderSyncHistory.
func (c *ProviderSyncHistoryClient) Update() *ProviderSyncHistoryUpdate {
	mutation := newProviderSyncHistoryMutation(c.config, OpUpdate)
	return &ProviderSyncHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProviderSyncHistoryClient) UpdateOne(psh *ProviderSyncHistory) *ProviderSyncHistoryUpdateOne {
	mutation := newProviderSyncHistoryMutation(c.config, OpUpdateOne, withProviderSyncHistory(psh))
	return &ProviderSyncHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProviderSyncHistoryClient) UpdateOneID(id uuid.UUID) *ProviderSyncHistoryUpdateOne {
	mutation := newProviderSyncHistoryMutation(c.config, OpUpdateOne, withProviderSyncHistoryID(id))
	return &ProviderSyncHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProviderSyncHistory.
func (c *ProviderSyncHistoryClient) Delete() *ProviderSyncHistoryDelete {
	mutation := newProviderSyncHistoryMutation(c.config, OpDelete)
	return &ProviderSyncHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProviderSyncHistoryClient) DeleteOne(psh *ProviderSyncHistory) *ProviderSyncHistoryDeleteOne {
	return c.DeleteOneID(psh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProviderSyncHistoryClient) DeleteOneID(id uuid.UUID) *ProviderSyncHistoryDeleteOne {
	builder := c.Delete().Where(providersynchistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProviderSyncHistoryDeleteOne{builder}
}

// Query returns a query builder for ProviderSyncHistory.
func (c *ProviderSyncHistoryClient) Query() *ProviderSyncHistoryQuery {
	return &ProviderSyncHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProviderSyncHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ProviderSyncHistory entity by its id.
func (c *ProviderSyncHistoryClient) Get(ctx context.Context, id uuid.UUID) (*ProviderSyncHistory, error) {
	return c.Query().Where(providersynchistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProviderSyncHistoryClient) GetX(ctx context.Context, id uuid.UUID) *ProviderSyncHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProviderSyncHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ProviderSyncHistory
	return append(hooks[:len(hooks):len(hooks)], providersynchistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProviderSyncHistoryClient) Interceptors() []Interceptor {
	return c.inters.ProviderSyncHistory
}

func (c *ProviderSyncHistoryClient) mutate(ctx context.Context, m *ProviderSyncHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProviderSyncHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProviderSyncHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProviderSyncHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProviderSyncHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProviderSyncHistory mutation op: %q", m.Op())
	}
}

// RetrospectiveClient is a client for the Retrospective schema.
type RetrospectiveClient struct {
	config
}

// NewRetrospectiveClient returns a client for the Retrospective from the given config.
func NewRetrospectiveClient(c config) *RetrospectiveClient {
	return &RetrospectiveClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `retrospective.Hooks(f(g(h())))`.
func (c *RetrospectiveClient) Use(hooks ...Hook) {
	c.hooks.Retrospective = append(c.hooks.Retrospective, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `retrospective.Intercept(f(g(h())))`.
func (c *RetrospectiveClient) Intercept(interceptors ...Interceptor) {
	c.inters.Retrospective = append(c.inters.Retrospective, interceptors...)
}

// Create returns a builder for creating a Retrospective entity.
func (c *RetrospectiveClient) Create() *RetrospectiveCreate {
	mutation := newRetrospectiveMutation(c.config, OpCreate)
	return &RetrospectiveCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Retrospective entities.
func (c *RetrospectiveClient) CreateBulk(builders ...*RetrospectiveCreate) *RetrospectiveCreateBulk {
	return &RetrospectiveCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RetrospectiveClient) MapCreateBulk(slice any, setFunc func(*RetrospectiveCreate, int)) *RetrospectiveCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RetrospectiveCreateBulk{err: fmt.Errorf("calling to RetrospectiveClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RetrospectiveCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RetrospectiveCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Retrospective.
func (c *RetrospectiveClient) Update() *RetrospectiveUpdate {
	mutation := newRetrospectiveMutation(c.config, OpUpdate)
	return &RetrospectiveUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RetrospectiveClient) UpdateOne(r *Retrospective) *RetrospectiveUpdateOne {
	mutation := newRetrospectiveMutation(c.config, OpUpdateOne, withRetrospective(r))
	return &RetrospectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RetrospectiveClient) UpdateOneID(id uuid.UUID) *RetrospectiveUpdateOne {
	mutation := newRetrospectiveMutation(c.config, OpUpdateOne, withRetrospectiveID(id))
	return &RetrospectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Retrospective.
func (c *RetrospectiveClient) Delete() *RetrospectiveDelete {
	mutation := newRetrospectiveMutation(c.config, OpDelete)
	return &RetrospectiveDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RetrospectiveClient) DeleteOne(r *Retrospective) *RetrospectiveDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RetrospectiveClient) DeleteOneID(id uuid.UUID) *RetrospectiveDeleteOne {
	builder := c.Delete().Where(retrospective.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RetrospectiveDeleteOne{builder}
}

// Query returns a query builder for Retrospective.
func (c *RetrospectiveClient) Query() *RetrospectiveQuery {
	return &RetrospectiveQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRetrospective},
		inters: c.Interceptors(),
	}
}

// Get returns a Retrospective entity by its id.
func (c *RetrospectiveClient) Get(ctx context.Context, id uuid.UUID) (*Retrospective, error) {
	return c.Query().Where(retrospective.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RetrospectiveClient) GetX(ctx context.Context, id uuid.UUID) *Retrospective {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a Retrospective.
func (c *RetrospectiveClient) QueryIncident(r *Retrospective) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospective.Table, retrospective.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospective.IncidentTable, retrospective.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscussions queries the discussions edge of a Retrospective.
func (c *RetrospectiveClient) QueryDiscussions(r *Retrospective) *RetrospectiveDiscussionQuery {
	query := (&RetrospectiveDiscussionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospective.Table, retrospective.FieldID, id),
			sqlgraph.To(retrospectivediscussion.Table, retrospectivediscussion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, retrospective.DiscussionsTable, retrospective.DiscussionsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySystemAnalysis queries the system_analysis edge of a Retrospective.
func (c *RetrospectiveClient) QuerySystemAnalysis(r *Retrospective) *SystemAnalysisQuery {
	query := (&SystemAnalysisClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospective.Table, retrospective.FieldID, id),
			sqlgraph.To(systemanalysis.Table, systemanalysis.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, retrospective.SystemAnalysisTable, retrospective.SystemAnalysisColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RetrospectiveClient) Hooks() []Hook {
	hooks := c.hooks.Retrospective
	return append(hooks[:len(hooks):len(hooks)], retrospective.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RetrospectiveClient) Interceptors() []Interceptor {
	return c.inters.Retrospective
}

func (c *RetrospectiveClient) mutate(ctx context.Context, m *RetrospectiveMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RetrospectiveCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RetrospectiveUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RetrospectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RetrospectiveDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Retrospective mutation op: %q", m.Op())
	}
}

// RetrospectiveDiscussionClient is a client for the RetrospectiveDiscussion schema.
type RetrospectiveDiscussionClient struct {
	config
}

// NewRetrospectiveDiscussionClient returns a client for the RetrospectiveDiscussion from the given config.
func NewRetrospectiveDiscussionClient(c config) *RetrospectiveDiscussionClient {
	return &RetrospectiveDiscussionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `retrospectivediscussion.Hooks(f(g(h())))`.
func (c *RetrospectiveDiscussionClient) Use(hooks ...Hook) {
	c.hooks.RetrospectiveDiscussion = append(c.hooks.RetrospectiveDiscussion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `retrospectivediscussion.Intercept(f(g(h())))`.
func (c *RetrospectiveDiscussionClient) Intercept(interceptors ...Interceptor) {
	c.inters.RetrospectiveDiscussion = append(c.inters.RetrospectiveDiscussion, interceptors...)
}

// Create returns a builder for creating a RetrospectiveDiscussion entity.
func (c *RetrospectiveDiscussionClient) Create() *RetrospectiveDiscussionCreate {
	mutation := newRetrospectiveDiscussionMutation(c.config, OpCreate)
	return &RetrospectiveDiscussionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RetrospectiveDiscussion entities.
func (c *RetrospectiveDiscussionClient) CreateBulk(builders ...*RetrospectiveDiscussionCreate) *RetrospectiveDiscussionCreateBulk {
	return &RetrospectiveDiscussionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RetrospectiveDiscussionClient) MapCreateBulk(slice any, setFunc func(*RetrospectiveDiscussionCreate, int)) *RetrospectiveDiscussionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RetrospectiveDiscussionCreateBulk{err: fmt.Errorf("calling to RetrospectiveDiscussionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RetrospectiveDiscussionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RetrospectiveDiscussionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) Update() *RetrospectiveDiscussionUpdate {
	mutation := newRetrospectiveDiscussionMutation(c.config, OpUpdate)
	return &RetrospectiveDiscussionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RetrospectiveDiscussionClient) UpdateOne(rd *RetrospectiveDiscussion) *RetrospectiveDiscussionUpdateOne {
	mutation := newRetrospectiveDiscussionMutation(c.config, OpUpdateOne, withRetrospectiveDiscussion(rd))
	return &RetrospectiveDiscussionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RetrospectiveDiscussionClient) UpdateOneID(id uuid.UUID) *RetrospectiveDiscussionUpdateOne {
	mutation := newRetrospectiveDiscussionMutation(c.config, OpUpdateOne, withRetrospectiveDiscussionID(id))
	return &RetrospectiveDiscussionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) Delete() *RetrospectiveDiscussionDelete {
	mutation := newRetrospectiveDiscussionMutation(c.config, OpDelete)
	return &RetrospectiveDiscussionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RetrospectiveDiscussionClient) DeleteOne(rd *RetrospectiveDiscussion) *RetrospectiveDiscussionDeleteOne {
	return c.DeleteOneID(rd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RetrospectiveDiscussionClient) DeleteOneID(id uuid.UUID) *RetrospectiveDiscussionDeleteOne {
	builder := c.Delete().Where(retrospectivediscussion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RetrospectiveDiscussionDeleteOne{builder}
}

// Query returns a query builder for RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) Query() *RetrospectiveDiscussionQuery {
	return &RetrospectiveDiscussionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRetrospectiveDiscussion},
		inters: c.Interceptors(),
	}
}

// Get returns a RetrospectiveDiscussion entity by its id.
func (c *RetrospectiveDiscussionClient) Get(ctx context.Context, id uuid.UUID) (*RetrospectiveDiscussion, error) {
	return c.Query().Where(retrospectivediscussion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RetrospectiveDiscussionClient) GetX(ctx context.Context, id uuid.UUID) *RetrospectiveDiscussion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRetrospective queries the retrospective edge of a RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) QueryRetrospective(rd *RetrospectiveDiscussion) *RetrospectiveQuery {
	query := (&RetrospectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussion.Table, retrospectivediscussion.FieldID, id),
			sqlgraph.To(retrospective.Table, retrospective.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivediscussion.RetrospectiveTable, retrospectivediscussion.RetrospectiveColumn),
		)
		fromV = sqlgraph.Neighbors(rd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReplies queries the replies edge of a RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) QueryReplies(rd *RetrospectiveDiscussion) *RetrospectiveDiscussionReplyQuery {
	query := (&RetrospectiveDiscussionReplyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussion.Table, retrospectivediscussion.FieldID, id),
			sqlgraph.To(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, retrospectivediscussion.RepliesTable, retrospectivediscussion.RepliesColumn),
		)
		fromV = sqlgraph.Neighbors(rd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReview queries the review edge of a RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) QueryReview(rd *RetrospectiveDiscussion) *RetrospectiveReviewQuery {
	query := (&RetrospectiveReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussion.Table, retrospectivediscussion.FieldID, id),
			sqlgraph.To(retrospectivereview.Table, retrospectivereview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, retrospectivediscussion.ReviewTable, retrospectivediscussion.ReviewColumn),
		)
		fromV = sqlgraph.Neighbors(rd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RetrospectiveDiscussionClient) Hooks() []Hook {
	hooks := c.hooks.RetrospectiveDiscussion
	return append(hooks[:len(hooks):len(hooks)], retrospectivediscussion.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RetrospectiveDiscussionClient) Interceptors() []Interceptor {
	return c.inters.RetrospectiveDiscussion
}

func (c *RetrospectiveDiscussionClient) mutate(ctx context.Context, m *RetrospectiveDiscussionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RetrospectiveDiscussionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RetrospectiveDiscussionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RetrospectiveDiscussionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RetrospectiveDiscussionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RetrospectiveDiscussion mutation op: %q", m.Op())
	}
}

// RetrospectiveDiscussionReplyClient is a client for the RetrospectiveDiscussionReply schema.
type RetrospectiveDiscussionReplyClient struct {
	config
}

// NewRetrospectiveDiscussionReplyClient returns a client for the RetrospectiveDiscussionReply from the given config.
func NewRetrospectiveDiscussionReplyClient(c config) *RetrospectiveDiscussionReplyClient {
	return &RetrospectiveDiscussionReplyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `retrospectivediscussionreply.Hooks(f(g(h())))`.
func (c *RetrospectiveDiscussionReplyClient) Use(hooks ...Hook) {
	c.hooks.RetrospectiveDiscussionReply = append(c.hooks.RetrospectiveDiscussionReply, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `retrospectivediscussionreply.Intercept(f(g(h())))`.
func (c *RetrospectiveDiscussionReplyClient) Intercept(interceptors ...Interceptor) {
	c.inters.RetrospectiveDiscussionReply = append(c.inters.RetrospectiveDiscussionReply, interceptors...)
}

// Create returns a builder for creating a RetrospectiveDiscussionReply entity.
func (c *RetrospectiveDiscussionReplyClient) Create() *RetrospectiveDiscussionReplyCreate {
	mutation := newRetrospectiveDiscussionReplyMutation(c.config, OpCreate)
	return &RetrospectiveDiscussionReplyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RetrospectiveDiscussionReply entities.
func (c *RetrospectiveDiscussionReplyClient) CreateBulk(builders ...*RetrospectiveDiscussionReplyCreate) *RetrospectiveDiscussionReplyCreateBulk {
	return &RetrospectiveDiscussionReplyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RetrospectiveDiscussionReplyClient) MapCreateBulk(slice any, setFunc func(*RetrospectiveDiscussionReplyCreate, int)) *RetrospectiveDiscussionReplyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RetrospectiveDiscussionReplyCreateBulk{err: fmt.Errorf("calling to RetrospectiveDiscussionReplyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RetrospectiveDiscussionReplyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RetrospectiveDiscussionReplyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) Update() *RetrospectiveDiscussionReplyUpdate {
	mutation := newRetrospectiveDiscussionReplyMutation(c.config, OpUpdate)
	return &RetrospectiveDiscussionReplyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RetrospectiveDiscussionReplyClient) UpdateOne(rdr *RetrospectiveDiscussionReply) *RetrospectiveDiscussionReplyUpdateOne {
	mutation := newRetrospectiveDiscussionReplyMutation(c.config, OpUpdateOne, withRetrospectiveDiscussionReply(rdr))
	return &RetrospectiveDiscussionReplyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RetrospectiveDiscussionReplyClient) UpdateOneID(id uuid.UUID) *RetrospectiveDiscussionReplyUpdateOne {
	mutation := newRetrospectiveDiscussionReplyMutation(c.config, OpUpdateOne, withRetrospectiveDiscussionReplyID(id))
	return &RetrospectiveDiscussionReplyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) Delete() *RetrospectiveDiscussionReplyDelete {
	mutation := newRetrospectiveDiscussionReplyMutation(c.config, OpDelete)
	return &RetrospectiveDiscussionReplyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RetrospectiveDiscussionReplyClient) DeleteOne(rdr *RetrospectiveDiscussionReply) *RetrospectiveDiscussionReplyDeleteOne {
	return c.DeleteOneID(rdr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RetrospectiveDiscussionReplyClient) DeleteOneID(id uuid.UUID) *RetrospectiveDiscussionReplyDeleteOne {
	builder := c.Delete().Where(retrospectivediscussionreply.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RetrospectiveDiscussionReplyDeleteOne{builder}
}

// Query returns a query builder for RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) Query() *RetrospectiveDiscussionReplyQuery {
	return &RetrospectiveDiscussionReplyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRetrospectiveDiscussionReply},
		inters: c.Interceptors(),
	}
}

// Get returns a RetrospectiveDiscussionReply entity by its id.
func (c *RetrospectiveDiscussionReplyClient) Get(ctx context.Context, id uuid.UUID) (*RetrospectiveDiscussionReply, error) {
	return c.Query().Where(retrospectivediscussionreply.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RetrospectiveDiscussionReplyClient) GetX(ctx context.Context, id uuid.UUID) *RetrospectiveDiscussionReply {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDiscussion queries the discussion edge of a RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) QueryDiscussion(rdr *RetrospectiveDiscussionReply) *RetrospectiveDiscussionQuery {
	query := (&RetrospectiveDiscussionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rdr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID, id),
			sqlgraph.To(retrospectivediscussion.Table, retrospectivediscussion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivediscussionreply.DiscussionTable, retrospectivediscussionreply.DiscussionColumn),
		)
		fromV = sqlgraph.Neighbors(rdr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentReply queries the parent_reply edge of a RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) QueryParentReply(rdr *RetrospectiveDiscussionReply) *RetrospectiveDiscussionReplyQuery {
	query := (&RetrospectiveDiscussionReplyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rdr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID, id),
			sqlgraph.To(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, retrospectivediscussionreply.ParentReplyTable, retrospectivediscussionreply.ParentReplyColumn),
		)
		fromV = sqlgraph.Neighbors(rdr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReplies queries the replies edge of a RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) QueryReplies(rdr *RetrospectiveDiscussionReply) *RetrospectiveDiscussionReplyQuery {
	query := (&RetrospectiveDiscussionReplyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rdr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID, id),
			sqlgraph.To(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, retrospectivediscussionreply.RepliesTable, retrospectivediscussionreply.RepliesColumn),
		)
		fromV = sqlgraph.Neighbors(rdr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RetrospectiveDiscussionReplyClient) Hooks() []Hook {
	hooks := c.hooks.RetrospectiveDiscussionReply
	return append(hooks[:len(hooks):len(hooks)], retrospectivediscussionreply.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RetrospectiveDiscussionReplyClient) Interceptors() []Interceptor {
	return c.inters.RetrospectiveDiscussionReply
}

func (c *RetrospectiveDiscussionReplyClient) mutate(ctx context.Context, m *RetrospectiveDiscussionReplyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RetrospectiveDiscussionReplyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RetrospectiveDiscussionReplyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RetrospectiveDiscussionReplyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RetrospectiveDiscussionReplyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RetrospectiveDiscussionReply mutation op: %q", m.Op())
	}
}

// RetrospectiveReviewClient is a client for the RetrospectiveReview schema.
type RetrospectiveReviewClient struct {
	config
}

// NewRetrospectiveReviewClient returns a client for the RetrospectiveReview from the given config.
func NewRetrospectiveReviewClient(c config) *RetrospectiveReviewClient {
	return &RetrospectiveReviewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `retrospectivereview.Hooks(f(g(h())))`.
func (c *RetrospectiveReviewClient) Use(hooks ...Hook) {
	c.hooks.RetrospectiveReview = append(c.hooks.RetrospectiveReview, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `retrospectivereview.Intercept(f(g(h())))`.
func (c *RetrospectiveReviewClient) Intercept(interceptors ...Interceptor) {
	c.inters.RetrospectiveReview = append(c.inters.RetrospectiveReview, interceptors...)
}

// Create returns a builder for creating a RetrospectiveReview entity.
func (c *RetrospectiveReviewClient) Create() *RetrospectiveReviewCreate {
	mutation := newRetrospectiveReviewMutation(c.config, OpCreate)
	return &RetrospectiveReviewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RetrospectiveReview entities.
func (c *RetrospectiveReviewClient) CreateBulk(builders ...*RetrospectiveReviewCreate) *RetrospectiveReviewCreateBulk {
	return &RetrospectiveReviewCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RetrospectiveReviewClient) MapCreateBulk(slice any, setFunc func(*RetrospectiveReviewCreate, int)) *RetrospectiveReviewCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RetrospectiveReviewCreateBulk{err: fmt.Errorf("calling to RetrospectiveReviewClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RetrospectiveReviewCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RetrospectiveReviewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RetrospectiveReview.
func (c *RetrospectiveReviewClient) Update() *RetrospectiveReviewUpdate {
	mutation := newRetrospectiveReviewMutation(c.config, OpUpdate)
	return &RetrospectiveReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RetrospectiveReviewClient) UpdateOne(rr *RetrospectiveReview) *RetrospectiveReviewUpdateOne {
	mutation := newRetrospectiveReviewMutation(c.config, OpUpdateOne, withRetrospectiveReview(rr))
	return &RetrospectiveReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RetrospectiveReviewClient) UpdateOneID(id uuid.UUID) *RetrospectiveReviewUpdateOne {
	mutation := newRetrospectiveReviewMutation(c.config, OpUpdateOne, withRetrospectiveReviewID(id))
	return &RetrospectiveReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RetrospectiveReview.
func (c *RetrospectiveReviewClient) Delete() *RetrospectiveReviewDelete {
	mutation := newRetrospectiveReviewMutation(c.config, OpDelete)
	return &RetrospectiveReviewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RetrospectiveReviewClient) DeleteOne(rr *RetrospectiveReview) *RetrospectiveReviewDeleteOne {
	return c.DeleteOneID(rr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RetrospectiveReviewClient) DeleteOneID(id uuid.UUID) *RetrospectiveReviewDeleteOne {
	builder := c.Delete().Where(retrospectivereview.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RetrospectiveReviewDeleteOne{builder}
}

// Query returns a query builder for RetrospectiveReview.
func (c *RetrospectiveReviewClient) Query() *RetrospectiveReviewQuery {
	return &RetrospectiveReviewQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRetrospectiveReview},
		inters: c.Interceptors(),
	}
}

// Get returns a RetrospectiveReview entity by its id.
func (c *RetrospectiveReviewClient) Get(ctx context.Context, id uuid.UUID) (*RetrospectiveReview, error) {
	return c.Query().Where(retrospectivereview.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RetrospectiveReviewClient) GetX(ctx context.Context, id uuid.UUID) *RetrospectiveReview {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRetrospective queries the retrospective edge of a RetrospectiveReview.
func (c *RetrospectiveReviewClient) QueryRetrospective(rr *RetrospectiveReview) *RetrospectiveQuery {
	query := (&RetrospectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivereview.Table, retrospectivereview.FieldID, id),
			sqlgraph.To(retrospective.Table, retrospective.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivereview.RetrospectiveTable, retrospectivereview.RetrospectiveColumn),
		)
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRequester queries the requester edge of a RetrospectiveReview.
func (c *RetrospectiveReviewClient) QueryRequester(rr *RetrospectiveReview) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivereview.Table, retrospectivereview.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivereview.RequesterTable, retrospectivereview.RequesterColumn),
		)
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviewer queries the reviewer edge of a RetrospectiveReview.
func (c *RetrospectiveReviewClient) QueryReviewer(rr *RetrospectiveReview) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivereview.Table, retrospectivereview.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivereview.ReviewerTable, retrospectivereview.ReviewerColumn),
		)
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscussion queries the discussion edge of a RetrospectiveReview.
func (c *RetrospectiveReviewClient) QueryDiscussion(rr *RetrospectiveReview) *RetrospectiveDiscussionQuery {
	query := (&RetrospectiveDiscussionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivereview.Table, retrospectivereview.FieldID, id),
			sqlgraph.To(retrospectivediscussion.Table, retrospectivediscussion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivereview.DiscussionTable, retrospectivereview.DiscussionColumn),
		)
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RetrospectiveReviewClient) Hooks() []Hook {
	hooks := c.hooks.RetrospectiveReview
	return append(hooks[:len(hooks):len(hooks)], retrospectivereview.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RetrospectiveReviewClient) Interceptors() []Interceptor {
	return c.inters.RetrospectiveReview
}

func (c *RetrospectiveReviewClient) mutate(ctx context.Context, m *RetrospectiveReviewMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RetrospectiveReviewCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RetrospectiveReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RetrospectiveReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RetrospectiveReviewDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RetrospectiveReview mutation op: %q", m.Op())
	}
}

// SystemAnalysisClient is a client for the SystemAnalysis schema.
type SystemAnalysisClient struct {
	config
}

// NewSystemAnalysisClient returns a client for the SystemAnalysis from the given config.
func NewSystemAnalysisClient(c config) *SystemAnalysisClient {
	return &SystemAnalysisClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemanalysis.Hooks(f(g(h())))`.
func (c *SystemAnalysisClient) Use(hooks ...Hook) {
	c.hooks.SystemAnalysis = append(c.hooks.SystemAnalysis, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemanalysis.Intercept(f(g(h())))`.
func (c *SystemAnalysisClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemAnalysis = append(c.inters.SystemAnalysis, interceptors...)
}

// Create returns a builder for creating a SystemAnalysis entity.
func (c *SystemAnalysisClient) Create() *SystemAnalysisCreate {
	mutation := newSystemAnalysisMutation(c.config, OpCreate)
	return &SystemAnalysisCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemAnalysis entities.
func (c *SystemAnalysisClient) CreateBulk(builders ...*SystemAnalysisCreate) *SystemAnalysisCreateBulk {
	return &SystemAnalysisCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemAnalysisClient) MapCreateBulk(slice any, setFunc func(*SystemAnalysisCreate, int)) *SystemAnalysisCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemAnalysisCreateBulk{err: fmt.Errorf("calling to SystemAnalysisClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemAnalysisCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemAnalysisCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemAnalysis.
func (c *SystemAnalysisClient) Update() *SystemAnalysisUpdate {
	mutation := newSystemAnalysisMutation(c.config, OpUpdate)
	return &SystemAnalysisUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemAnalysisClient) UpdateOne(sa *SystemAnalysis) *SystemAnalysisUpdateOne {
	mutation := newSystemAnalysisMutation(c.config, OpUpdateOne, withSystemAnalysis(sa))
	return &SystemAnalysisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemAnalysisClient) UpdateOneID(id uuid.UUID) *SystemAnalysisUpdateOne {
	mutation := newSystemAnalysisMutation(c.config, OpUpdateOne, withSystemAnalysisID(id))
	return &SystemAnalysisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemAnalysis.
func (c *SystemAnalysisClient) Delete() *SystemAnalysisDelete {
	mutation := newSystemAnalysisMutation(c.config, OpDelete)
	return &SystemAnalysisDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemAnalysisClient) DeleteOne(sa *SystemAnalysis) *SystemAnalysisDeleteOne {
	return c.DeleteOneID(sa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemAnalysisClient) DeleteOneID(id uuid.UUID) *SystemAnalysisDeleteOne {
	builder := c.Delete().Where(systemanalysis.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemAnalysisDeleteOne{builder}
}

// Query returns a query builder for SystemAnalysis.
func (c *SystemAnalysisClient) Query() *SystemAnalysisQuery {
	return &SystemAnalysisQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemAnalysis},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemAnalysis entity by its id.
func (c *SystemAnalysisClient) Get(ctx context.Context, id uuid.UUID) (*SystemAnalysis, error) {
	return c.Query().Where(systemanalysis.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemAnalysisClient) GetX(ctx context.Context, id uuid.UUID) *SystemAnalysis {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRetrospective queries the retrospective edge of a SystemAnalysis.
func (c *SystemAnalysisClient) QueryRetrospective(sa *SystemAnalysis) *RetrospectiveQuery {
	query := (&RetrospectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysis.Table, systemanalysis.FieldID, id),
			sqlgraph.To(retrospective.Table, retrospective.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, systemanalysis.RetrospectiveTable, systemanalysis.RetrospectiveColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponents queries the components edge of a SystemAnalysis.
func (c *SystemAnalysisClient) QueryComponents(sa *SystemAnalysis) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysis.Table, systemanalysis.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, systemanalysis.ComponentsTable, systemanalysis.ComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelationships queries the relationships edge of a SystemAnalysis.
func (c *SystemAnalysisClient) QueryRelationships(sa *SystemAnalysis) *SystemAnalysisRelationshipQuery {
	query := (&SystemAnalysisRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysis.Table, systemanalysis.FieldID, id),
			sqlgraph.To(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemanalysis.RelationshipsTable, systemanalysis.RelationshipsColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnalysisComponents queries the analysis_components edge of a SystemAnalysis.
func (c *SystemAnalysisClient) QueryAnalysisComponents(sa *SystemAnalysis) *SystemAnalysisComponentQuery {
	query := (&SystemAnalysisComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysis.Table, systemanalysis.FieldID, id),
			sqlgraph.To(systemanalysiscomponent.Table, systemanalysiscomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemanalysis.AnalysisComponentsTable, systemanalysis.AnalysisComponentsColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemAnalysisClient) Hooks() []Hook {
	hooks := c.hooks.SystemAnalysis
	return append(hooks[:len(hooks):len(hooks)], systemanalysis.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemAnalysisClient) Interceptors() []Interceptor {
	return c.inters.SystemAnalysis
}

func (c *SystemAnalysisClient) mutate(ctx context.Context, m *SystemAnalysisMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemAnalysisCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemAnalysisUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemAnalysisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemAnalysisDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemAnalysis mutation op: %q", m.Op())
	}
}

// SystemAnalysisComponentClient is a client for the SystemAnalysisComponent schema.
type SystemAnalysisComponentClient struct {
	config
}

// NewSystemAnalysisComponentClient returns a client for the SystemAnalysisComponent from the given config.
func NewSystemAnalysisComponentClient(c config) *SystemAnalysisComponentClient {
	return &SystemAnalysisComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemanalysiscomponent.Hooks(f(g(h())))`.
func (c *SystemAnalysisComponentClient) Use(hooks ...Hook) {
	c.hooks.SystemAnalysisComponent = append(c.hooks.SystemAnalysisComponent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemanalysiscomponent.Intercept(f(g(h())))`.
func (c *SystemAnalysisComponentClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemAnalysisComponent = append(c.inters.SystemAnalysisComponent, interceptors...)
}

// Create returns a builder for creating a SystemAnalysisComponent entity.
func (c *SystemAnalysisComponentClient) Create() *SystemAnalysisComponentCreate {
	mutation := newSystemAnalysisComponentMutation(c.config, OpCreate)
	return &SystemAnalysisComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemAnalysisComponent entities.
func (c *SystemAnalysisComponentClient) CreateBulk(builders ...*SystemAnalysisComponentCreate) *SystemAnalysisComponentCreateBulk {
	return &SystemAnalysisComponentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemAnalysisComponentClient) MapCreateBulk(slice any, setFunc func(*SystemAnalysisComponentCreate, int)) *SystemAnalysisComponentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemAnalysisComponentCreateBulk{err: fmt.Errorf("calling to SystemAnalysisComponentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemAnalysisComponentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemAnalysisComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemAnalysisComponent.
func (c *SystemAnalysisComponentClient) Update() *SystemAnalysisComponentUpdate {
	mutation := newSystemAnalysisComponentMutation(c.config, OpUpdate)
	return &SystemAnalysisComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemAnalysisComponentClient) UpdateOne(sac *SystemAnalysisComponent) *SystemAnalysisComponentUpdateOne {
	mutation := newSystemAnalysisComponentMutation(c.config, OpUpdateOne, withSystemAnalysisComponent(sac))
	return &SystemAnalysisComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemAnalysisComponentClient) UpdateOneID(id uuid.UUID) *SystemAnalysisComponentUpdateOne {
	mutation := newSystemAnalysisComponentMutation(c.config, OpUpdateOne, withSystemAnalysisComponentID(id))
	return &SystemAnalysisComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemAnalysisComponent.
func (c *SystemAnalysisComponentClient) Delete() *SystemAnalysisComponentDelete {
	mutation := newSystemAnalysisComponentMutation(c.config, OpDelete)
	return &SystemAnalysisComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemAnalysisComponentClient) DeleteOne(sac *SystemAnalysisComponent) *SystemAnalysisComponentDeleteOne {
	return c.DeleteOneID(sac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemAnalysisComponentClient) DeleteOneID(id uuid.UUID) *SystemAnalysisComponentDeleteOne {
	builder := c.Delete().Where(systemanalysiscomponent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemAnalysisComponentDeleteOne{builder}
}

// Query returns a query builder for SystemAnalysisComponent.
func (c *SystemAnalysisComponentClient) Query() *SystemAnalysisComponentQuery {
	return &SystemAnalysisComponentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemAnalysisComponent},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemAnalysisComponent entity by its id.
func (c *SystemAnalysisComponentClient) Get(ctx context.Context, id uuid.UUID) (*SystemAnalysisComponent, error) {
	return c.Query().Where(systemanalysiscomponent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemAnalysisComponentClient) GetX(ctx context.Context, id uuid.UUID) *SystemAnalysisComponent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAnalysis queries the analysis edge of a SystemAnalysisComponent.
func (c *SystemAnalysisComponentClient) QueryAnalysis(sac *SystemAnalysisComponent) *SystemAnalysisQuery {
	query := (&SystemAnalysisClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sac.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysiscomponent.Table, systemanalysiscomponent.FieldID, id),
			sqlgraph.To(systemanalysis.Table, systemanalysis.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemanalysiscomponent.AnalysisTable, systemanalysiscomponent.AnalysisColumn),
		)
		fromV = sqlgraph.Neighbors(sac.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponent queries the component edge of a SystemAnalysisComponent.
func (c *SystemAnalysisComponentClient) QueryComponent(sac *SystemAnalysisComponent) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sac.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysiscomponent.Table, systemanalysiscomponent.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemanalysiscomponent.ComponentTable, systemanalysiscomponent.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(sac.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemAnalysisComponentClient) Hooks() []Hook {
	hooks := c.hooks.SystemAnalysisComponent
	return append(hooks[:len(hooks):len(hooks)], systemanalysiscomponent.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemAnalysisComponentClient) Interceptors() []Interceptor {
	return c.inters.SystemAnalysisComponent
}

func (c *SystemAnalysisComponentClient) mutate(ctx context.Context, m *SystemAnalysisComponentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemAnalysisComponentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemAnalysisComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemAnalysisComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemAnalysisComponentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemAnalysisComponent mutation op: %q", m.Op())
	}
}

// SystemAnalysisRelationshipClient is a client for the SystemAnalysisRelationship schema.
type SystemAnalysisRelationshipClient struct {
	config
}

// NewSystemAnalysisRelationshipClient returns a client for the SystemAnalysisRelationship from the given config.
func NewSystemAnalysisRelationshipClient(c config) *SystemAnalysisRelationshipClient {
	return &SystemAnalysisRelationshipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemanalysisrelationship.Hooks(f(g(h())))`.
func (c *SystemAnalysisRelationshipClient) Use(hooks ...Hook) {
	c.hooks.SystemAnalysisRelationship = append(c.hooks.SystemAnalysisRelationship, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemanalysisrelationship.Intercept(f(g(h())))`.
func (c *SystemAnalysisRelationshipClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemAnalysisRelationship = append(c.inters.SystemAnalysisRelationship, interceptors...)
}

// Create returns a builder for creating a SystemAnalysisRelationship entity.
func (c *SystemAnalysisRelationshipClient) Create() *SystemAnalysisRelationshipCreate {
	mutation := newSystemAnalysisRelationshipMutation(c.config, OpCreate)
	return &SystemAnalysisRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemAnalysisRelationship entities.
func (c *SystemAnalysisRelationshipClient) CreateBulk(builders ...*SystemAnalysisRelationshipCreate) *SystemAnalysisRelationshipCreateBulk {
	return &SystemAnalysisRelationshipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemAnalysisRelationshipClient) MapCreateBulk(slice any, setFunc func(*SystemAnalysisRelationshipCreate, int)) *SystemAnalysisRelationshipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemAnalysisRelationshipCreateBulk{err: fmt.Errorf("calling to SystemAnalysisRelationshipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemAnalysisRelationshipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemAnalysisRelationshipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemAnalysisRelationship.
func (c *SystemAnalysisRelationshipClient) Update() *SystemAnalysisRelationshipUpdate {
	mutation := newSystemAnalysisRelationshipMutation(c.config, OpUpdate)
	return &SystemAnalysisRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemAnalysisRelationshipClient) UpdateOne(sar *SystemAnalysisRelationship) *SystemAnalysisRelationshipUpdateOne {
	mutation := newSystemAnalysisRelationshipMutation(c.config, OpUpdateOne, withSystemAnalysisRelationship(sar))
	return &SystemAnalysisRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemAnalysisRelationshipClient) UpdateOneID(id uuid.UUID) *SystemAnalysisRelationshipUpdateOne {
	mutation := newSystemAnalysisRelationshipMutation(c.config, OpUpdateOne, withSystemAnalysisRelationshipID(id))
	return &SystemAnalysisRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemAnalysisRelationship.
func (c *SystemAnalysisRelationshipClient) Delete() *SystemAnalysisRelationshipDelete {
	mutation := newSystemAnalysisRelationshipMutation(c.config, OpDelete)
	return &SystemAnalysisRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemAnalysisRelationshipClient) DeleteOne(sar *SystemAnalysisRelationship) *SystemAnalysisRelationshipDeleteOne {
	return c.DeleteOneID(sar.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemAnalysisRelationshipClient) DeleteOneID(id uuid.UUID) *SystemAnalysisRelationshipDeleteOne {
	builder := c.Delete().Where(systemanalysisrelationship.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemAnalysisRelationshipDeleteOne{builder}
}

// Query returns a query builder for SystemAnalysisRelationship.
func (c *SystemAnalysisRelationshipClient) Query() *SystemAnalysisRelationshipQuery {
	return &SystemAnalysisRelationshipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemAnalysisRelationship},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemAnalysisRelationship entity by its id.
func (c *SystemAnalysisRelationshipClient) Get(ctx context.Context, id uuid.UUID) (*SystemAnalysisRelationship, error) {
	return c.Query().Where(systemanalysisrelationship.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemAnalysisRelationshipClient) GetX(ctx context.Context, id uuid.UUID) *SystemAnalysisRelationship {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySystemAnalysis queries the system_analysis edge of a SystemAnalysisRelationship.
func (c *SystemAnalysisRelationshipClient) QuerySystemAnalysis(sar *SystemAnalysisRelationship) *SystemAnalysisQuery {
	query := (&SystemAnalysisClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sar.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID, id),
			sqlgraph.To(systemanalysis.Table, systemanalysis.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemanalysisrelationship.SystemAnalysisTable, systemanalysisrelationship.SystemAnalysisColumn),
		)
		fromV = sqlgraph.Neighbors(sar.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponentRelationship queries the component_relationship edge of a SystemAnalysisRelationship.
func (c *SystemAnalysisRelationshipClient) QueryComponentRelationship(sar *SystemAnalysisRelationship) *SystemComponentRelationshipQuery {
	query := (&SystemComponentRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sar.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID, id),
			sqlgraph.To(systemcomponentrelationship.Table, systemcomponentrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemanalysisrelationship.ComponentRelationshipTable, systemanalysisrelationship.ComponentRelationshipColumn),
		)
		fromV = sqlgraph.Neighbors(sar.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a SystemAnalysisRelationship.
func (c *SystemAnalysisRelationshipClient) QueryControls(sar *SystemAnalysisRelationship) *SystemComponentControlQuery {
	query := (&SystemComponentControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sar.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID, id),
			sqlgraph.To(systemcomponentcontrol.Table, systemcomponentcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, systemanalysisrelationship.ControlsTable, systemanalysisrelationship.ControlsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sar.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySignals queries the signals edge of a SystemAnalysisRelationship.
func (c *SystemAnalysisRelationshipClient) QuerySignals(sar *SystemAnalysisRelationship) *SystemComponentSignalQuery {
	query := (&SystemComponentSignalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sar.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID, id),
			sqlgraph.To(systemcomponentsignal.Table, systemcomponentsignal.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, systemanalysisrelationship.SignalsTable, systemanalysisrelationship.SignalsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sar.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlActions queries the control_actions edge of a SystemAnalysisRelationship.
func (c *SystemAnalysisRelationshipClient) QueryControlActions(sar *SystemAnalysisRelationship) *SystemRelationshipControlActionQuery {
	query := (&SystemRelationshipControlActionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sar.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID, id),
			sqlgraph.To(systemrelationshipcontrolaction.Table, systemrelationshipcontrolaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemanalysisrelationship.ControlActionsTable, systemanalysisrelationship.ControlActionsColumn),
		)
		fromV = sqlgraph.Neighbors(sar.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFeedbackSignals queries the feedback_signals edge of a SystemAnalysisRelationship.
func (c *SystemAnalysisRelationshipClient) QueryFeedbackSignals(sar *SystemAnalysisRelationship) *SystemRelationshipFeedbackSignalQuery {
	query := (&SystemRelationshipFeedbackSignalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sar.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID, id),
			sqlgraph.To(systemrelationshipfeedbacksignal.Table, systemrelationshipfeedbacksignal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemanalysisrelationship.FeedbackSignalsTable, systemanalysisrelationship.FeedbackSignalsColumn),
		)
		fromV = sqlgraph.Neighbors(sar.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemAnalysisRelationshipClient) Hooks() []Hook {
	hooks := c.hooks.SystemAnalysisRelationship
	return append(hooks[:len(hooks):len(hooks)], systemanalysisrelationship.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemAnalysisRelationshipClient) Interceptors() []Interceptor {
	return c.inters.SystemAnalysisRelationship
}

func (c *SystemAnalysisRelationshipClient) mutate(ctx context.Context, m *SystemAnalysisRelationshipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemAnalysisRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemAnalysisRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemAnalysisRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemAnalysisRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemAnalysisRelationship mutation op: %q", m.Op())
	}
}

// SystemComponentClient is a client for the SystemComponent schema.
type SystemComponentClient struct {
	config
}

// NewSystemComponentClient returns a client for the SystemComponent from the given config.
func NewSystemComponentClient(c config) *SystemComponentClient {
	return &SystemComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemcomponent.Hooks(f(g(h())))`.
func (c *SystemComponentClient) Use(hooks ...Hook) {
	c.hooks.SystemComponent = append(c.hooks.SystemComponent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemcomponent.Intercept(f(g(h())))`.
func (c *SystemComponentClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemComponent = append(c.inters.SystemComponent, interceptors...)
}

// Create returns a builder for creating a SystemComponent entity.
func (c *SystemComponentClient) Create() *SystemComponentCreate {
	mutation := newSystemComponentMutation(c.config, OpCreate)
	return &SystemComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemComponent entities.
func (c *SystemComponentClient) CreateBulk(builders ...*SystemComponentCreate) *SystemComponentCreateBulk {
	return &SystemComponentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemComponentClient) MapCreateBulk(slice any, setFunc func(*SystemComponentCreate, int)) *SystemComponentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemComponentCreateBulk{err: fmt.Errorf("calling to SystemComponentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemComponentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemComponent.
func (c *SystemComponentClient) Update() *SystemComponentUpdate {
	mutation := newSystemComponentMutation(c.config, OpUpdate)
	return &SystemComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemComponentClient) UpdateOne(sc *SystemComponent) *SystemComponentUpdateOne {
	mutation := newSystemComponentMutation(c.config, OpUpdateOne, withSystemComponent(sc))
	return &SystemComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemComponentClient) UpdateOneID(id uuid.UUID) *SystemComponentUpdateOne {
	mutation := newSystemComponentMutation(c.config, OpUpdateOne, withSystemComponentID(id))
	return &SystemComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemComponent.
func (c *SystemComponentClient) Delete() *SystemComponentDelete {
	mutation := newSystemComponentMutation(c.config, OpDelete)
	return &SystemComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemComponentClient) DeleteOne(sc *SystemComponent) *SystemComponentDeleteOne {
	return c.DeleteOneID(sc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemComponentClient) DeleteOneID(id uuid.UUID) *SystemComponentDeleteOne {
	builder := c.Delete().Where(systemcomponent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemComponentDeleteOne{builder}
}

// Query returns a query builder for SystemComponent.
func (c *SystemComponentClient) Query() *SystemComponentQuery {
	return &SystemComponentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemComponent},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemComponent entity by its id.
func (c *SystemComponentClient) Get(ctx context.Context, id uuid.UUID) (*SystemComponent, error) {
	return c.Query().Where(systemcomponent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemComponentClient) GetX(ctx context.Context, id uuid.UUID) *SystemComponent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryKind queries the kind edge of a SystemComponent.
func (c *SystemComponentClient) QueryKind(sc *SystemComponent) *SystemComponentKindQuery {
	query := (&SystemComponentKindClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponent.Table, systemcomponent.FieldID, id),
			sqlgraph.To(systemcomponentkind.Table, systemcomponentkind.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemcomponent.KindTable, systemcomponent.KindColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelated queries the related edge of a SystemComponent.
func (c *SystemComponentClient) QueryRelated(sc *SystemComponent) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponent.Table, systemcomponent.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, systemcomponent.RelatedTable, systemcomponent.RelatedPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySystemAnalyses queries the system_analyses edge of a SystemComponent.
func (c *SystemComponentClient) QuerySystemAnalyses(sc *SystemComponent) *SystemAnalysisQuery {
	query := (&SystemAnalysisClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponent.Table, systemcomponent.FieldID, id),
			sqlgraph.To(systemanalysis.Table, systemanalysis.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, systemcomponent.SystemAnalysesTable, systemcomponent.SystemAnalysesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a SystemComponent.
func (c *SystemComponentClient) QueryEvents(sc *SystemComponent) *IncidentEventQuery {
	query := (&IncidentEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponent.Table, systemcomponent.FieldID, id),
			sqlgraph.To(incidentevent.Table, incidentevent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, systemcomponent.EventsTable, systemcomponent.EventsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConstraints queries the constraints edge of a SystemComponent.
func (c *SystemComponentClient) QueryConstraints(sc *SystemComponent) *SystemComponentConstraintQuery {
	query := (&SystemComponentConstraintClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponent.Table, systemcomponent.FieldID, id),
			sqlgraph.To(systemcomponentconstraint.Table, systemcomponentconstraint.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemcomponent.ConstraintsTable, systemcomponent.ConstraintsColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a SystemComponent.
func (c *SystemComponentClient) QueryControls(sc *SystemComponent) *SystemComponentControlQuery {
	query := (&SystemComponentControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponent.Table, systemcomponent.FieldID, id),
			sqlgraph.To(systemcomponentcontrol.Table, systemcomponentcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemcomponent.ControlsTable, systemcomponent.ControlsColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySignals queries the signals edge of a SystemComponent.
func (c *SystemComponentClient) QuerySignals(sc *SystemComponent) *SystemComponentSignalQuery {
	query := (&SystemComponentSignalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponent.Table, systemcomponent.FieldID, id),
			sqlgraph.To(systemcomponentsignal.Table, systemcomponentsignal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemcomponent.SignalsTable, systemcomponent.SignalsColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHazards queries the hazards edge of a SystemComponent.
func (c *SystemComponentClient) QueryHazards(sc *SystemComponent) *SystemHazardQuery {
	query := (&SystemHazardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponent.Table, systemcomponent.FieldID, id),
			sqlgraph.To(systemhazard.Table, systemhazard.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, systemcomponent.HazardsTable, systemcomponent.HazardsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponentRelationships queries the component_relationships edge of a SystemComponent.
func (c *SystemComponentClient) QueryComponentRelationships(sc *SystemComponent) *SystemComponentRelationshipQuery {
	query := (&SystemComponentRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponent.Table, systemcomponent.FieldID, id),
			sqlgraph.To(systemcomponentrelationship.Table, systemcomponentrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemcomponent.ComponentRelationshipsTable, systemcomponent.ComponentRelationshipsColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySystemAnalysisComponents queries the system_analysis_components edge of a SystemComponent.
func (c *SystemComponentClient) QuerySystemAnalysisComponents(sc *SystemComponent) *SystemAnalysisComponentQuery {
	query := (&SystemAnalysisComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponent.Table, systemcomponent.FieldID, id),
			sqlgraph.To(systemanalysiscomponent.Table, systemanalysiscomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemcomponent.SystemAnalysisComponentsTable, systemcomponent.SystemAnalysisComponentsColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventComponents queries the event_components edge of a SystemComponent.
func (c *SystemComponentClient) QueryEventComponents(sc *SystemComponent) *IncidentEventSystemComponentQuery {
	query := (&IncidentEventSystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponent.Table, systemcomponent.FieldID, id),
			sqlgraph.To(incidenteventsystemcomponent.Table, incidenteventsystemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemcomponent.EventComponentsTable, systemcomponent.EventComponentsColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemComponentClient) Hooks() []Hook {
	hooks := c.hooks.SystemComponent
	return append(hooks[:len(hooks):len(hooks)], systemcomponent.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemComponentClient) Interceptors() []Interceptor {
	return c.inters.SystemComponent
}

func (c *SystemComponentClient) mutate(ctx context.Context, m *SystemComponentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemComponentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemComponentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemComponent mutation op: %q", m.Op())
	}
}

// SystemComponentConstraintClient is a client for the SystemComponentConstraint schema.
type SystemComponentConstraintClient struct {
	config
}

// NewSystemComponentConstraintClient returns a client for the SystemComponentConstraint from the given config.
func NewSystemComponentConstraintClient(c config) *SystemComponentConstraintClient {
	return &SystemComponentConstraintClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemcomponentconstraint.Hooks(f(g(h())))`.
func (c *SystemComponentConstraintClient) Use(hooks ...Hook) {
	c.hooks.SystemComponentConstraint = append(c.hooks.SystemComponentConstraint, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemcomponentconstraint.Intercept(f(g(h())))`.
func (c *SystemComponentConstraintClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemComponentConstraint = append(c.inters.SystemComponentConstraint, interceptors...)
}

// Create returns a builder for creating a SystemComponentConstraint entity.
func (c *SystemComponentConstraintClient) Create() *SystemComponentConstraintCreate {
	mutation := newSystemComponentConstraintMutation(c.config, OpCreate)
	return &SystemComponentConstraintCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemComponentConstraint entities.
func (c *SystemComponentConstraintClient) CreateBulk(builders ...*SystemComponentConstraintCreate) *SystemComponentConstraintCreateBulk {
	return &SystemComponentConstraintCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemComponentConstraintClient) MapCreateBulk(slice any, setFunc func(*SystemComponentConstraintCreate, int)) *SystemComponentConstraintCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemComponentConstraintCreateBulk{err: fmt.Errorf("calling to SystemComponentConstraintClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemComponentConstraintCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemComponentConstraintCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemComponentConstraint.
func (c *SystemComponentConstraintClient) Update() *SystemComponentConstraintUpdate {
	mutation := newSystemComponentConstraintMutation(c.config, OpUpdate)
	return &SystemComponentConstraintUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemComponentConstraintClient) UpdateOne(scc *SystemComponentConstraint) *SystemComponentConstraintUpdateOne {
	mutation := newSystemComponentConstraintMutation(c.config, OpUpdateOne, withSystemComponentConstraint(scc))
	return &SystemComponentConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemComponentConstraintClient) UpdateOneID(id uuid.UUID) *SystemComponentConstraintUpdateOne {
	mutation := newSystemComponentConstraintMutation(c.config, OpUpdateOne, withSystemComponentConstraintID(id))
	return &SystemComponentConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemComponentConstraint.
func (c *SystemComponentConstraintClient) Delete() *SystemComponentConstraintDelete {
	mutation := newSystemComponentConstraintMutation(c.config, OpDelete)
	return &SystemComponentConstraintDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemComponentConstraintClient) DeleteOne(scc *SystemComponentConstraint) *SystemComponentConstraintDeleteOne {
	return c.DeleteOneID(scc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemComponentConstraintClient) DeleteOneID(id uuid.UUID) *SystemComponentConstraintDeleteOne {
	builder := c.Delete().Where(systemcomponentconstraint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemComponentConstraintDeleteOne{builder}
}

// Query returns a query builder for SystemComponentConstraint.
func (c *SystemComponentConstraintClient) Query() *SystemComponentConstraintQuery {
	return &SystemComponentConstraintQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemComponentConstraint},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemComponentConstraint entity by its id.
func (c *SystemComponentConstraintClient) Get(ctx context.Context, id uuid.UUID) (*SystemComponentConstraint, error) {
	return c.Query().Where(systemcomponentconstraint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemComponentConstraintClient) GetX(ctx context.Context, id uuid.UUID) *SystemComponentConstraint {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponent queries the component edge of a SystemComponentConstraint.
func (c *SystemComponentConstraintClient) QueryComponent(scc *SystemComponentConstraint) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentconstraint.Table, systemcomponentconstraint.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemcomponentconstraint.ComponentTable, systemcomponentconstraint.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(scc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHazards queries the hazards edge of a SystemComponentConstraint.
func (c *SystemComponentConstraintClient) QueryHazards(scc *SystemComponentConstraint) *SystemHazardQuery {
	query := (&SystemHazardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentconstraint.Table, systemcomponentconstraint.FieldID, id),
			sqlgraph.To(systemhazard.Table, systemhazard.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, systemcomponentconstraint.HazardsTable, systemcomponentconstraint.HazardsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(scc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemComponentConstraintClient) Hooks() []Hook {
	hooks := c.hooks.SystemComponentConstraint
	return append(hooks[:len(hooks):len(hooks)], systemcomponentconstraint.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemComponentConstraintClient) Interceptors() []Interceptor {
	return c.inters.SystemComponentConstraint
}

func (c *SystemComponentConstraintClient) mutate(ctx context.Context, m *SystemComponentConstraintMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemComponentConstraintCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemComponentConstraintUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemComponentConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemComponentConstraintDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemComponentConstraint mutation op: %q", m.Op())
	}
}

// SystemComponentControlClient is a client for the SystemComponentControl schema.
type SystemComponentControlClient struct {
	config
}

// NewSystemComponentControlClient returns a client for the SystemComponentControl from the given config.
func NewSystemComponentControlClient(c config) *SystemComponentControlClient {
	return &SystemComponentControlClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemcomponentcontrol.Hooks(f(g(h())))`.
func (c *SystemComponentControlClient) Use(hooks ...Hook) {
	c.hooks.SystemComponentControl = append(c.hooks.SystemComponentControl, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemcomponentcontrol.Intercept(f(g(h())))`.
func (c *SystemComponentControlClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemComponentControl = append(c.inters.SystemComponentControl, interceptors...)
}

// Create returns a builder for creating a SystemComponentControl entity.
func (c *SystemComponentControlClient) Create() *SystemComponentControlCreate {
	mutation := newSystemComponentControlMutation(c.config, OpCreate)
	return &SystemComponentControlCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemComponentControl entities.
func (c *SystemComponentControlClient) CreateBulk(builders ...*SystemComponentControlCreate) *SystemComponentControlCreateBulk {
	return &SystemComponentControlCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemComponentControlClient) MapCreateBulk(slice any, setFunc func(*SystemComponentControlCreate, int)) *SystemComponentControlCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemComponentControlCreateBulk{err: fmt.Errorf("calling to SystemComponentControlClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemComponentControlCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemComponentControlCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemComponentControl.
func (c *SystemComponentControlClient) Update() *SystemComponentControlUpdate {
	mutation := newSystemComponentControlMutation(c.config, OpUpdate)
	return &SystemComponentControlUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemComponentControlClient) UpdateOne(scc *SystemComponentControl) *SystemComponentControlUpdateOne {
	mutation := newSystemComponentControlMutation(c.config, OpUpdateOne, withSystemComponentControl(scc))
	return &SystemComponentControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemComponentControlClient) UpdateOneID(id uuid.UUID) *SystemComponentControlUpdateOne {
	mutation := newSystemComponentControlMutation(c.config, OpUpdateOne, withSystemComponentControlID(id))
	return &SystemComponentControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemComponentControl.
func (c *SystemComponentControlClient) Delete() *SystemComponentControlDelete {
	mutation := newSystemComponentControlMutation(c.config, OpDelete)
	return &SystemComponentControlDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemComponentControlClient) DeleteOne(scc *SystemComponentControl) *SystemComponentControlDeleteOne {
	return c.DeleteOneID(scc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemComponentControlClient) DeleteOneID(id uuid.UUID) *SystemComponentControlDeleteOne {
	builder := c.Delete().Where(systemcomponentcontrol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemComponentControlDeleteOne{builder}
}

// Query returns a query builder for SystemComponentControl.
func (c *SystemComponentControlClient) Query() *SystemComponentControlQuery {
	return &SystemComponentControlQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemComponentControl},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemComponentControl entity by its id.
func (c *SystemComponentControlClient) Get(ctx context.Context, id uuid.UUID) (*SystemComponentControl, error) {
	return c.Query().Where(systemcomponentcontrol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemComponentControlClient) GetX(ctx context.Context, id uuid.UUID) *SystemComponentControl {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponent queries the component edge of a SystemComponentControl.
func (c *SystemComponentControlClient) QueryComponent(scc *SystemComponentControl) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentcontrol.Table, systemcomponentcontrol.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemcomponentcontrol.ComponentTable, systemcomponentcontrol.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(scc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelationships queries the relationships edge of a SystemComponentControl.
func (c *SystemComponentControlClient) QueryRelationships(scc *SystemComponentControl) *SystemAnalysisRelationshipQuery {
	query := (&SystemAnalysisRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentcontrol.Table, systemcomponentcontrol.FieldID, id),
			sqlgraph.To(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, systemcomponentcontrol.RelationshipsTable, systemcomponentcontrol.RelationshipsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(scc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlActions queries the control_actions edge of a SystemComponentControl.
func (c *SystemComponentControlClient) QueryControlActions(scc *SystemComponentControl) *SystemRelationshipControlActionQuery {
	query := (&SystemRelationshipControlActionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentcontrol.Table, systemcomponentcontrol.FieldID, id),
			sqlgraph.To(systemrelationshipcontrolaction.Table, systemrelationshipcontrolaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemcomponentcontrol.ControlActionsTable, systemcomponentcontrol.ControlActionsColumn),
		)
		fromV = sqlgraph.Neighbors(scc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemComponentControlClient) Hooks() []Hook {
	hooks := c.hooks.SystemComponentControl
	return append(hooks[:len(hooks):len(hooks)], systemcomponentcontrol.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemComponentControlClient) Interceptors() []Interceptor {
	return c.inters.SystemComponentControl
}

func (c *SystemComponentControlClient) mutate(ctx context.Context, m *SystemComponentControlMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemComponentControlCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemComponentControlUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemComponentControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemComponentControlDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemComponentControl mutation op: %q", m.Op())
	}
}

// SystemComponentKindClient is a client for the SystemComponentKind schema.
type SystemComponentKindClient struct {
	config
}

// NewSystemComponentKindClient returns a client for the SystemComponentKind from the given config.
func NewSystemComponentKindClient(c config) *SystemComponentKindClient {
	return &SystemComponentKindClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemcomponentkind.Hooks(f(g(h())))`.
func (c *SystemComponentKindClient) Use(hooks ...Hook) {
	c.hooks.SystemComponentKind = append(c.hooks.SystemComponentKind, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemcomponentkind.Intercept(f(g(h())))`.
func (c *SystemComponentKindClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemComponentKind = append(c.inters.SystemComponentKind, interceptors...)
}

// Create returns a builder for creating a SystemComponentKind entity.
func (c *SystemComponentKindClient) Create() *SystemComponentKindCreate {
	mutation := newSystemComponentKindMutation(c.config, OpCreate)
	return &SystemComponentKindCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemComponentKind entities.
func (c *SystemComponentKindClient) CreateBulk(builders ...*SystemComponentKindCreate) *SystemComponentKindCreateBulk {
	return &SystemComponentKindCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemComponentKindClient) MapCreateBulk(slice any, setFunc func(*SystemComponentKindCreate, int)) *SystemComponentKindCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemComponentKindCreateBulk{err: fmt.Errorf("calling to SystemComponentKindClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemComponentKindCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemComponentKindCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemComponentKind.
func (c *SystemComponentKindClient) Update() *SystemComponentKindUpdate {
	mutation := newSystemComponentKindMutation(c.config, OpUpdate)
	return &SystemComponentKindUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemComponentKindClient) UpdateOne(sck *SystemComponentKind) *SystemComponentKindUpdateOne {
	mutation := newSystemComponentKindMutation(c.config, OpUpdateOne, withSystemComponentKind(sck))
	return &SystemComponentKindUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemComponentKindClient) UpdateOneID(id uuid.UUID) *SystemComponentKindUpdateOne {
	mutation := newSystemComponentKindMutation(c.config, OpUpdateOne, withSystemComponentKindID(id))
	return &SystemComponentKindUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemComponentKind.
func (c *SystemComponentKindClient) Delete() *SystemComponentKindDelete {
	mutation := newSystemComponentKindMutation(c.config, OpDelete)
	return &SystemComponentKindDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemComponentKindClient) DeleteOne(sck *SystemComponentKind) *SystemComponentKindDeleteOne {
	return c.DeleteOneID(sck.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemComponentKindClient) DeleteOneID(id uuid.UUID) *SystemComponentKindDeleteOne {
	builder := c.Delete().Where(systemcomponentkind.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemComponentKindDeleteOne{builder}
}

// Query returns a query builder for SystemComponentKind.
func (c *SystemComponentKindClient) Query() *SystemComponentKindQuery {
	return &SystemComponentKindQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemComponentKind},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemComponentKind entity by its id.
func (c *SystemComponentKindClient) Get(ctx context.Context, id uuid.UUID) (*SystemComponentKind, error) {
	return c.Query().Where(systemcomponentkind.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemComponentKindClient) GetX(ctx context.Context, id uuid.UUID) *SystemComponentKind {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponents queries the components edge of a SystemComponentKind.
func (c *SystemComponentKindClient) QueryComponents(sck *SystemComponentKind) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sck.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentkind.Table, systemcomponentkind.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemcomponentkind.ComponentsTable, systemcomponentkind.ComponentsColumn),
		)
		fromV = sqlgraph.Neighbors(sck.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemComponentKindClient) Hooks() []Hook {
	hooks := c.hooks.SystemComponentKind
	return append(hooks[:len(hooks):len(hooks)], systemcomponentkind.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemComponentKindClient) Interceptors() []Interceptor {
	return c.inters.SystemComponentKind
}

func (c *SystemComponentKindClient) mutate(ctx context.Context, m *SystemComponentKindMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemComponentKindCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemComponentKindUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemComponentKindUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemComponentKindDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemComponentKind mutation op: %q", m.Op())
	}
}

// SystemComponentRelationshipClient is a client for the SystemComponentRelationship schema.
type SystemComponentRelationshipClient struct {
	config
}

// NewSystemComponentRelationshipClient returns a client for the SystemComponentRelationship from the given config.
func NewSystemComponentRelationshipClient(c config) *SystemComponentRelationshipClient {
	return &SystemComponentRelationshipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemcomponentrelationship.Hooks(f(g(h())))`.
func (c *SystemComponentRelationshipClient) Use(hooks ...Hook) {
	c.hooks.SystemComponentRelationship = append(c.hooks.SystemComponentRelationship, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemcomponentrelationship.Intercept(f(g(h())))`.
func (c *SystemComponentRelationshipClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemComponentRelationship = append(c.inters.SystemComponentRelationship, interceptors...)
}

// Create returns a builder for creating a SystemComponentRelationship entity.
func (c *SystemComponentRelationshipClient) Create() *SystemComponentRelationshipCreate {
	mutation := newSystemComponentRelationshipMutation(c.config, OpCreate)
	return &SystemComponentRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemComponentRelationship entities.
func (c *SystemComponentRelationshipClient) CreateBulk(builders ...*SystemComponentRelationshipCreate) *SystemComponentRelationshipCreateBulk {
	return &SystemComponentRelationshipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemComponentRelationshipClient) MapCreateBulk(slice any, setFunc func(*SystemComponentRelationshipCreate, int)) *SystemComponentRelationshipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemComponentRelationshipCreateBulk{err: fmt.Errorf("calling to SystemComponentRelationshipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemComponentRelationshipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemComponentRelationshipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemComponentRelationship.
func (c *SystemComponentRelationshipClient) Update() *SystemComponentRelationshipUpdate {
	mutation := newSystemComponentRelationshipMutation(c.config, OpUpdate)
	return &SystemComponentRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemComponentRelationshipClient) UpdateOne(scr *SystemComponentRelationship) *SystemComponentRelationshipUpdateOne {
	mutation := newSystemComponentRelationshipMutation(c.config, OpUpdateOne, withSystemComponentRelationship(scr))
	return &SystemComponentRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemComponentRelationshipClient) UpdateOneID(id uuid.UUID) *SystemComponentRelationshipUpdateOne {
	mutation := newSystemComponentRelationshipMutation(c.config, OpUpdateOne, withSystemComponentRelationshipID(id))
	return &SystemComponentRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemComponentRelationship.
func (c *SystemComponentRelationshipClient) Delete() *SystemComponentRelationshipDelete {
	mutation := newSystemComponentRelationshipMutation(c.config, OpDelete)
	return &SystemComponentRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemComponentRelationshipClient) DeleteOne(scr *SystemComponentRelationship) *SystemComponentRelationshipDeleteOne {
	return c.DeleteOneID(scr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemComponentRelationshipClient) DeleteOneID(id uuid.UUID) *SystemComponentRelationshipDeleteOne {
	builder := c.Delete().Where(systemcomponentrelationship.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemComponentRelationshipDeleteOne{builder}
}

// Query returns a query builder for SystemComponentRelationship.
func (c *SystemComponentRelationshipClient) Query() *SystemComponentRelationshipQuery {
	return &SystemComponentRelationshipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemComponentRelationship},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemComponentRelationship entity by its id.
func (c *SystemComponentRelationshipClient) Get(ctx context.Context, id uuid.UUID) (*SystemComponentRelationship, error) {
	return c.Query().Where(systemcomponentrelationship.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemComponentRelationshipClient) GetX(ctx context.Context, id uuid.UUID) *SystemComponentRelationship {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySource queries the source edge of a SystemComponentRelationship.
func (c *SystemComponentRelationshipClient) QuerySource(scr *SystemComponentRelationship) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentrelationship.Table, systemcomponentrelationship.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemcomponentrelationship.SourceTable, systemcomponentrelationship.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(scr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTarget queries the target edge of a SystemComponentRelationship.
func (c *SystemComponentRelationshipClient) QueryTarget(scr *SystemComponentRelationship) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentrelationship.Table, systemcomponentrelationship.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemcomponentrelationship.TargetTable, systemcomponentrelationship.TargetColumn),
		)
		fromV = sqlgraph.Neighbors(scr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySystemAnalyses queries the system_analyses edge of a SystemComponentRelationship.
func (c *SystemComponentRelationshipClient) QuerySystemAnalyses(scr *SystemComponentRelationship) *SystemAnalysisRelationshipQuery {
	query := (&SystemAnalysisRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentrelationship.Table, systemcomponentrelationship.FieldID, id),
			sqlgraph.To(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemcomponentrelationship.SystemAnalysesTable, systemcomponentrelationship.SystemAnalysesColumn),
		)
		fromV = sqlgraph.Neighbors(scr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHazards queries the hazards edge of a SystemComponentRelationship.
func (c *SystemComponentRelationshipClient) QueryHazards(scr *SystemComponentRelationship) *SystemHazardQuery {
	query := (&SystemHazardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentrelationship.Table, systemcomponentrelationship.FieldID, id),
			sqlgraph.To(systemhazard.Table, systemhazard.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, systemcomponentrelationship.HazardsTable, systemcomponentrelationship.HazardsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(scr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemComponentRelationshipClient) Hooks() []Hook {
	hooks := c.hooks.SystemComponentRelationship
	return append(hooks[:len(hooks):len(hooks)], systemcomponentrelationship.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemComponentRelationshipClient) Interceptors() []Interceptor {
	return c.inters.SystemComponentRelationship
}

func (c *SystemComponentRelationshipClient) mutate(ctx context.Context, m *SystemComponentRelationshipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemComponentRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemComponentRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemComponentRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemComponentRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemComponentRelationship mutation op: %q", m.Op())
	}
}

// SystemComponentSignalClient is a client for the SystemComponentSignal schema.
type SystemComponentSignalClient struct {
	config
}

// NewSystemComponentSignalClient returns a client for the SystemComponentSignal from the given config.
func NewSystemComponentSignalClient(c config) *SystemComponentSignalClient {
	return &SystemComponentSignalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemcomponentsignal.Hooks(f(g(h())))`.
func (c *SystemComponentSignalClient) Use(hooks ...Hook) {
	c.hooks.SystemComponentSignal = append(c.hooks.SystemComponentSignal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemcomponentsignal.Intercept(f(g(h())))`.
func (c *SystemComponentSignalClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemComponentSignal = append(c.inters.SystemComponentSignal, interceptors...)
}

// Create returns a builder for creating a SystemComponentSignal entity.
func (c *SystemComponentSignalClient) Create() *SystemComponentSignalCreate {
	mutation := newSystemComponentSignalMutation(c.config, OpCreate)
	return &SystemComponentSignalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemComponentSignal entities.
func (c *SystemComponentSignalClient) CreateBulk(builders ...*SystemComponentSignalCreate) *SystemComponentSignalCreateBulk {
	return &SystemComponentSignalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemComponentSignalClient) MapCreateBulk(slice any, setFunc func(*SystemComponentSignalCreate, int)) *SystemComponentSignalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemComponentSignalCreateBulk{err: fmt.Errorf("calling to SystemComponentSignalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemComponentSignalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemComponentSignalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemComponentSignal.
func (c *SystemComponentSignalClient) Update() *SystemComponentSignalUpdate {
	mutation := newSystemComponentSignalMutation(c.config, OpUpdate)
	return &SystemComponentSignalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemComponentSignalClient) UpdateOne(scs *SystemComponentSignal) *SystemComponentSignalUpdateOne {
	mutation := newSystemComponentSignalMutation(c.config, OpUpdateOne, withSystemComponentSignal(scs))
	return &SystemComponentSignalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemComponentSignalClient) UpdateOneID(id uuid.UUID) *SystemComponentSignalUpdateOne {
	mutation := newSystemComponentSignalMutation(c.config, OpUpdateOne, withSystemComponentSignalID(id))
	return &SystemComponentSignalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemComponentSignal.
func (c *SystemComponentSignalClient) Delete() *SystemComponentSignalDelete {
	mutation := newSystemComponentSignalMutation(c.config, OpDelete)
	return &SystemComponentSignalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemComponentSignalClient) DeleteOne(scs *SystemComponentSignal) *SystemComponentSignalDeleteOne {
	return c.DeleteOneID(scs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemComponentSignalClient) DeleteOneID(id uuid.UUID) *SystemComponentSignalDeleteOne {
	builder := c.Delete().Where(systemcomponentsignal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemComponentSignalDeleteOne{builder}
}

// Query returns a query builder for SystemComponentSignal.
func (c *SystemComponentSignalClient) Query() *SystemComponentSignalQuery {
	return &SystemComponentSignalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemComponentSignal},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemComponentSignal entity by its id.
func (c *SystemComponentSignalClient) Get(ctx context.Context, id uuid.UUID) (*SystemComponentSignal, error) {
	return c.Query().Where(systemcomponentsignal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemComponentSignalClient) GetX(ctx context.Context, id uuid.UUID) *SystemComponentSignal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponent queries the component edge of a SystemComponentSignal.
func (c *SystemComponentSignalClient) QueryComponent(scs *SystemComponentSignal) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentsignal.Table, systemcomponentsignal.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemcomponentsignal.ComponentTable, systemcomponentsignal.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(scs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelationships queries the relationships edge of a SystemComponentSignal.
func (c *SystemComponentSignalClient) QueryRelationships(scs *SystemComponentSignal) *SystemAnalysisRelationshipQuery {
	query := (&SystemAnalysisRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentsignal.Table, systemcomponentsignal.FieldID, id),
			sqlgraph.To(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, systemcomponentsignal.RelationshipsTable, systemcomponentsignal.RelationshipsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(scs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFeedbackSignals queries the feedback_signals edge of a SystemComponentSignal.
func (c *SystemComponentSignalClient) QueryFeedbackSignals(scs *SystemComponentSignal) *SystemRelationshipFeedbackSignalQuery {
	query := (&SystemRelationshipFeedbackSignalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := scs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemcomponentsignal.Table, systemcomponentsignal.FieldID, id),
			sqlgraph.To(systemrelationshipfeedbacksignal.Table, systemrelationshipfeedbacksignal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, systemcomponentsignal.FeedbackSignalsTable, systemcomponentsignal.FeedbackSignalsColumn),
		)
		fromV = sqlgraph.Neighbors(scs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemComponentSignalClient) Hooks() []Hook {
	hooks := c.hooks.SystemComponentSignal
	return append(hooks[:len(hooks):len(hooks)], systemcomponentsignal.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemComponentSignalClient) Interceptors() []Interceptor {
	return c.inters.SystemComponentSignal
}

func (c *SystemComponentSignalClient) mutate(ctx context.Context, m *SystemComponentSignalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemComponentSignalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemComponentSignalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemComponentSignalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemComponentSignalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemComponentSignal mutation op: %q", m.Op())
	}
}

// SystemHazardClient is a client for the SystemHazard schema.
type SystemHazardClient struct {
	config
}

// NewSystemHazardClient returns a client for the SystemHazard from the given config.
func NewSystemHazardClient(c config) *SystemHazardClient {
	return &SystemHazardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemhazard.Hooks(f(g(h())))`.
func (c *SystemHazardClient) Use(hooks ...Hook) {
	c.hooks.SystemHazard = append(c.hooks.SystemHazard, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemhazard.Intercept(f(g(h())))`.
func (c *SystemHazardClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemHazard = append(c.inters.SystemHazard, interceptors...)
}

// Create returns a builder for creating a SystemHazard entity.
func (c *SystemHazardClient) Create() *SystemHazardCreate {
	mutation := newSystemHazardMutation(c.config, OpCreate)
	return &SystemHazardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemHazard entities.
func (c *SystemHazardClient) CreateBulk(builders ...*SystemHazardCreate) *SystemHazardCreateBulk {
	return &SystemHazardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemHazardClient) MapCreateBulk(slice any, setFunc func(*SystemHazardCreate, int)) *SystemHazardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemHazardCreateBulk{err: fmt.Errorf("calling to SystemHazardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemHazardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemHazardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemHazard.
func (c *SystemHazardClient) Update() *SystemHazardUpdate {
	mutation := newSystemHazardMutation(c.config, OpUpdate)
	return &SystemHazardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemHazardClient) UpdateOne(sh *SystemHazard) *SystemHazardUpdateOne {
	mutation := newSystemHazardMutation(c.config, OpUpdateOne, withSystemHazard(sh))
	return &SystemHazardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemHazardClient) UpdateOneID(id uuid.UUID) *SystemHazardUpdateOne {
	mutation := newSystemHazardMutation(c.config, OpUpdateOne, withSystemHazardID(id))
	return &SystemHazardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemHazard.
func (c *SystemHazardClient) Delete() *SystemHazardDelete {
	mutation := newSystemHazardMutation(c.config, OpDelete)
	return &SystemHazardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemHazardClient) DeleteOne(sh *SystemHazard) *SystemHazardDeleteOne {
	return c.DeleteOneID(sh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemHazardClient) DeleteOneID(id uuid.UUID) *SystemHazardDeleteOne {
	builder := c.Delete().Where(systemhazard.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemHazardDeleteOne{builder}
}

// Query returns a query builder for SystemHazard.
func (c *SystemHazardClient) Query() *SystemHazardQuery {
	return &SystemHazardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemHazard},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemHazard entity by its id.
func (c *SystemHazardClient) Get(ctx context.Context, id uuid.UUID) (*SystemHazard, error) {
	return c.Query().Where(systemhazard.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemHazardClient) GetX(ctx context.Context, id uuid.UUID) *SystemHazard {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponents queries the components edge of a SystemHazard.
func (c *SystemHazardClient) QueryComponents(sh *SystemHazard) *SystemComponentQuery {
	query := (&SystemComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemhazard.Table, systemhazard.FieldID, id),
			sqlgraph.To(systemcomponent.Table, systemcomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, systemhazard.ComponentsTable, systemhazard.ComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConstraints queries the constraints edge of a SystemHazard.
func (c *SystemHazardClient) QueryConstraints(sh *SystemHazard) *SystemComponentConstraintQuery {
	query := (&SystemComponentConstraintClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemhazard.Table, systemhazard.FieldID, id),
			sqlgraph.To(systemcomponentconstraint.Table, systemcomponentconstraint.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, systemhazard.ConstraintsTable, systemhazard.ConstraintsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelationships queries the relationships edge of a SystemHazard.
func (c *SystemHazardClient) QueryRelationships(sh *SystemHazard) *SystemComponentRelationshipQuery {
	query := (&SystemComponentRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemhazard.Table, systemhazard.FieldID, id),
			sqlgraph.To(systemcomponentrelationship.Table, systemcomponentrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, systemhazard.RelationshipsTable, systemhazard.RelationshipsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemHazardClient) Hooks() []Hook {
	hooks := c.hooks.SystemHazard
	return append(hooks[:len(hooks):len(hooks)], systemhazard.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemHazardClient) Interceptors() []Interceptor {
	return c.inters.SystemHazard
}

func (c *SystemHazardClient) mutate(ctx context.Context, m *SystemHazardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemHazardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemHazardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemHazardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemHazardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemHazard mutation op: %q", m.Op())
	}
}

// SystemRelationshipControlActionClient is a client for the SystemRelationshipControlAction schema.
type SystemRelationshipControlActionClient struct {
	config
}

// NewSystemRelationshipControlActionClient returns a client for the SystemRelationshipControlAction from the given config.
func NewSystemRelationshipControlActionClient(c config) *SystemRelationshipControlActionClient {
	return &SystemRelationshipControlActionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemrelationshipcontrolaction.Hooks(f(g(h())))`.
func (c *SystemRelationshipControlActionClient) Use(hooks ...Hook) {
	c.hooks.SystemRelationshipControlAction = append(c.hooks.SystemRelationshipControlAction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemrelationshipcontrolaction.Intercept(f(g(h())))`.
func (c *SystemRelationshipControlActionClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemRelationshipControlAction = append(c.inters.SystemRelationshipControlAction, interceptors...)
}

// Create returns a builder for creating a SystemRelationshipControlAction entity.
func (c *SystemRelationshipControlActionClient) Create() *SystemRelationshipControlActionCreate {
	mutation := newSystemRelationshipControlActionMutation(c.config, OpCreate)
	return &SystemRelationshipControlActionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemRelationshipControlAction entities.
func (c *SystemRelationshipControlActionClient) CreateBulk(builders ...*SystemRelationshipControlActionCreate) *SystemRelationshipControlActionCreateBulk {
	return &SystemRelationshipControlActionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemRelationshipControlActionClient) MapCreateBulk(slice any, setFunc func(*SystemRelationshipControlActionCreate, int)) *SystemRelationshipControlActionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemRelationshipControlActionCreateBulk{err: fmt.Errorf("calling to SystemRelationshipControlActionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemRelationshipControlActionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemRelationshipControlActionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemRelationshipControlAction.
func (c *SystemRelationshipControlActionClient) Update() *SystemRelationshipControlActionUpdate {
	mutation := newSystemRelationshipControlActionMutation(c.config, OpUpdate)
	return &SystemRelationshipControlActionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemRelationshipControlActionClient) UpdateOne(srca *SystemRelationshipControlAction) *SystemRelationshipControlActionUpdateOne {
	mutation := newSystemRelationshipControlActionMutation(c.config, OpUpdateOne, withSystemRelationshipControlAction(srca))
	return &SystemRelationshipControlActionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemRelationshipControlActionClient) UpdateOneID(id uuid.UUID) *SystemRelationshipControlActionUpdateOne {
	mutation := newSystemRelationshipControlActionMutation(c.config, OpUpdateOne, withSystemRelationshipControlActionID(id))
	return &SystemRelationshipControlActionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemRelationshipControlAction.
func (c *SystemRelationshipControlActionClient) Delete() *SystemRelationshipControlActionDelete {
	mutation := newSystemRelationshipControlActionMutation(c.config, OpDelete)
	return &SystemRelationshipControlActionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemRelationshipControlActionClient) DeleteOne(srca *SystemRelationshipControlAction) *SystemRelationshipControlActionDeleteOne {
	return c.DeleteOneID(srca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemRelationshipControlActionClient) DeleteOneID(id uuid.UUID) *SystemRelationshipControlActionDeleteOne {
	builder := c.Delete().Where(systemrelationshipcontrolaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemRelationshipControlActionDeleteOne{builder}
}

// Query returns a query builder for SystemRelationshipControlAction.
func (c *SystemRelationshipControlActionClient) Query() *SystemRelationshipControlActionQuery {
	return &SystemRelationshipControlActionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemRelationshipControlAction},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemRelationshipControlAction entity by its id.
func (c *SystemRelationshipControlActionClient) Get(ctx context.Context, id uuid.UUID) (*SystemRelationshipControlAction, error) {
	return c.Query().Where(systemrelationshipcontrolaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemRelationshipControlActionClient) GetX(ctx context.Context, id uuid.UUID) *SystemRelationshipControlAction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelationship queries the relationship edge of a SystemRelationshipControlAction.
func (c *SystemRelationshipControlActionClient) QueryRelationship(srca *SystemRelationshipControlAction) *SystemAnalysisRelationshipQuery {
	query := (&SystemAnalysisRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := srca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemrelationshipcontrolaction.Table, systemrelationshipcontrolaction.FieldID, id),
			sqlgraph.To(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemrelationshipcontrolaction.RelationshipTable, systemrelationshipcontrolaction.RelationshipColumn),
		)
		fromV = sqlgraph.Neighbors(srca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControl queries the control edge of a SystemRelationshipControlAction.
func (c *SystemRelationshipControlActionClient) QueryControl(srca *SystemRelationshipControlAction) *SystemComponentControlQuery {
	query := (&SystemComponentControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := srca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemrelationshipcontrolaction.Table, systemrelationshipcontrolaction.FieldID, id),
			sqlgraph.To(systemcomponentcontrol.Table, systemcomponentcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemrelationshipcontrolaction.ControlTable, systemrelationshipcontrolaction.ControlColumn),
		)
		fromV = sqlgraph.Neighbors(srca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemRelationshipControlActionClient) Hooks() []Hook {
	hooks := c.hooks.SystemRelationshipControlAction
	return append(hooks[:len(hooks):len(hooks)], systemrelationshipcontrolaction.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemRelationshipControlActionClient) Interceptors() []Interceptor {
	return c.inters.SystemRelationshipControlAction
}

func (c *SystemRelationshipControlActionClient) mutate(ctx context.Context, m *SystemRelationshipControlActionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemRelationshipControlActionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemRelationshipControlActionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemRelationshipControlActionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemRelationshipControlActionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemRelationshipControlAction mutation op: %q", m.Op())
	}
}

// SystemRelationshipFeedbackSignalClient is a client for the SystemRelationshipFeedbackSignal schema.
type SystemRelationshipFeedbackSignalClient struct {
	config
}

// NewSystemRelationshipFeedbackSignalClient returns a client for the SystemRelationshipFeedbackSignal from the given config.
func NewSystemRelationshipFeedbackSignalClient(c config) *SystemRelationshipFeedbackSignalClient {
	return &SystemRelationshipFeedbackSignalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemrelationshipfeedbacksignal.Hooks(f(g(h())))`.
func (c *SystemRelationshipFeedbackSignalClient) Use(hooks ...Hook) {
	c.hooks.SystemRelationshipFeedbackSignal = append(c.hooks.SystemRelationshipFeedbackSignal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemrelationshipfeedbacksignal.Intercept(f(g(h())))`.
func (c *SystemRelationshipFeedbackSignalClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemRelationshipFeedbackSignal = append(c.inters.SystemRelationshipFeedbackSignal, interceptors...)
}

// Create returns a builder for creating a SystemRelationshipFeedbackSignal entity.
func (c *SystemRelationshipFeedbackSignalClient) Create() *SystemRelationshipFeedbackSignalCreate {
	mutation := newSystemRelationshipFeedbackSignalMutation(c.config, OpCreate)
	return &SystemRelationshipFeedbackSignalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemRelationshipFeedbackSignal entities.
func (c *SystemRelationshipFeedbackSignalClient) CreateBulk(builders ...*SystemRelationshipFeedbackSignalCreate) *SystemRelationshipFeedbackSignalCreateBulk {
	return &SystemRelationshipFeedbackSignalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemRelationshipFeedbackSignalClient) MapCreateBulk(slice any, setFunc func(*SystemRelationshipFeedbackSignalCreate, int)) *SystemRelationshipFeedbackSignalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemRelationshipFeedbackSignalCreateBulk{err: fmt.Errorf("calling to SystemRelationshipFeedbackSignalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemRelationshipFeedbackSignalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemRelationshipFeedbackSignalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemRelationshipFeedbackSignal.
func (c *SystemRelationshipFeedbackSignalClient) Update() *SystemRelationshipFeedbackSignalUpdate {
	mutation := newSystemRelationshipFeedbackSignalMutation(c.config, OpUpdate)
	return &SystemRelationshipFeedbackSignalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemRelationshipFeedbackSignalClient) UpdateOne(srfs *SystemRelationshipFeedbackSignal) *SystemRelationshipFeedbackSignalUpdateOne {
	mutation := newSystemRelationshipFeedbackSignalMutation(c.config, OpUpdateOne, withSystemRelationshipFeedbackSignal(srfs))
	return &SystemRelationshipFeedbackSignalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemRelationshipFeedbackSignalClient) UpdateOneID(id uuid.UUID) *SystemRelationshipFeedbackSignalUpdateOne {
	mutation := newSystemRelationshipFeedbackSignalMutation(c.config, OpUpdateOne, withSystemRelationshipFeedbackSignalID(id))
	return &SystemRelationshipFeedbackSignalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemRelationshipFeedbackSignal.
func (c *SystemRelationshipFeedbackSignalClient) Delete() *SystemRelationshipFeedbackSignalDelete {
	mutation := newSystemRelationshipFeedbackSignalMutation(c.config, OpDelete)
	return &SystemRelationshipFeedbackSignalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemRelationshipFeedbackSignalClient) DeleteOne(srfs *SystemRelationshipFeedbackSignal) *SystemRelationshipFeedbackSignalDeleteOne {
	return c.DeleteOneID(srfs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemRelationshipFeedbackSignalClient) DeleteOneID(id uuid.UUID) *SystemRelationshipFeedbackSignalDeleteOne {
	builder := c.Delete().Where(systemrelationshipfeedbacksignal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemRelationshipFeedbackSignalDeleteOne{builder}
}

// Query returns a query builder for SystemRelationshipFeedbackSignal.
func (c *SystemRelationshipFeedbackSignalClient) Query() *SystemRelationshipFeedbackSignalQuery {
	return &SystemRelationshipFeedbackSignalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemRelationshipFeedbackSignal},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemRelationshipFeedbackSignal entity by its id.
func (c *SystemRelationshipFeedbackSignalClient) Get(ctx context.Context, id uuid.UUID) (*SystemRelationshipFeedbackSignal, error) {
	return c.Query().Where(systemrelationshipfeedbacksignal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemRelationshipFeedbackSignalClient) GetX(ctx context.Context, id uuid.UUID) *SystemRelationshipFeedbackSignal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelationship queries the relationship edge of a SystemRelationshipFeedbackSignal.
func (c *SystemRelationshipFeedbackSignalClient) QueryRelationship(srfs *SystemRelationshipFeedbackSignal) *SystemAnalysisRelationshipQuery {
	query := (&SystemAnalysisRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := srfs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemrelationshipfeedbacksignal.Table, systemrelationshipfeedbacksignal.FieldID, id),
			sqlgraph.To(systemanalysisrelationship.Table, systemanalysisrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemrelationshipfeedbacksignal.RelationshipTable, systemrelationshipfeedbacksignal.RelationshipColumn),
		)
		fromV = sqlgraph.Neighbors(srfs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySignal queries the signal edge of a SystemRelationshipFeedbackSignal.
func (c *SystemRelationshipFeedbackSignalClient) QuerySignal(srfs *SystemRelationshipFeedbackSignal) *SystemComponentSignalQuery {
	query := (&SystemComponentSignalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := srfs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemrelationshipfeedbacksignal.Table, systemrelationshipfeedbacksignal.FieldID, id),
			sqlgraph.To(systemcomponentsignal.Table, systemcomponentsignal.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, systemrelationshipfeedbacksignal.SignalTable, systemrelationshipfeedbacksignal.SignalColumn),
		)
		fromV = sqlgraph.Neighbors(srfs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemRelationshipFeedbackSignalClient) Hooks() []Hook {
	hooks := c.hooks.SystemRelationshipFeedbackSignal
	return append(hooks[:len(hooks):len(hooks)], systemrelationshipfeedbacksignal.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemRelationshipFeedbackSignalClient) Interceptors() []Interceptor {
	return c.inters.SystemRelationshipFeedbackSignal
}

func (c *SystemRelationshipFeedbackSignalClient) mutate(ctx context.Context, m *SystemRelationshipFeedbackSignalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemRelationshipFeedbackSignalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemRelationshipFeedbackSignalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemRelationshipFeedbackSignalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemRelationshipFeedbackSignalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemRelationshipFeedbackSignal mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id uuid.UUID) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id uuid.UUID) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id uuid.UUID) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id uuid.UUID) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTickets queries the tickets edge of a Task.
func (c *TaskClient) QueryTickets(t *Task) *TicketQuery {
	query := (&TicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, task.TicketsTable, task.TicketsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncident queries the incident edge of a Task.
func (c *TaskClient) QueryIncident(t *Task) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.IncidentTable, task.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignee queries the assignee edge of a Task.
func (c *TaskClient) QueryAssignee(t *Task) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.AssigneeTable, task.AssigneeColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a Task.
func (c *TaskClient) QueryCreator(t *Task) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.CreatorTable, task.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	hooks := c.hooks.Task
	return append(hooks[:len(hooks):len(hooks)], task.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	return c.inters.Task
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// TeamClient is a client for the Team schema.
type TeamClient struct {
	config
}

// NewTeamClient returns a client for the Team from the given config.
func NewTeamClient(c config) *TeamClient {
	return &TeamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `team.Hooks(f(g(h())))`.
func (c *TeamClient) Use(hooks ...Hook) {
	c.hooks.Team = append(c.hooks.Team, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `team.Intercept(f(g(h())))`.
func (c *TeamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Team = append(c.inters.Team, interceptors...)
}

// Create returns a builder for creating a Team entity.
func (c *TeamClient) Create() *TeamCreate {
	mutation := newTeamMutation(c.config, OpCreate)
	return &TeamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Team entities.
func (c *TeamClient) CreateBulk(builders ...*TeamCreate) *TeamCreateBulk {
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamClient) MapCreateBulk(slice any, setFunc func(*TeamCreate, int)) *TeamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamCreateBulk{err: fmt.Errorf("calling to TeamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Team.
func (c *TeamClient) Update() *TeamUpdate {
	mutation := newTeamMutation(c.config, OpUpdate)
	return &TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamClient) UpdateOne(t *Team) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeam(t))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamClient) UpdateOneID(id uuid.UUID) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeamID(id))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Team.
func (c *TeamClient) Delete() *TeamDelete {
	mutation := newTeamMutation(c.config, OpDelete)
	return &TeamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamClient) DeleteOne(t *Team) *TeamDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamClient) DeleteOneID(id uuid.UUID) *TeamDeleteOne {
	builder := c.Delete().Where(team.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamDeleteOne{builder}
}

// Query returns a query builder for Team.
func (c *TeamClient) Query() *TeamQuery {
	return &TeamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeam},
		inters: c.Interceptors(),
	}
}

// Get returns a Team entity by its id.
func (c *TeamClient) Get(ctx context.Context, id uuid.UUID) (*Team, error) {
	return c.Query().Where(team.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamClient) GetX(ctx context.Context, id uuid.UUID) *Team {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Team.
func (c *TeamClient) QueryUsers(t *Team) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, team.UsersTable, team.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOncallRosters queries the oncall_rosters edge of a Team.
func (c *TeamClient) QueryOncallRosters(t *Team) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, team.OncallRostersTable, team.OncallRostersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentAssignments queries the incident_assignments edge of a Team.
func (c *TeamClient) QueryIncidentAssignments(t *Team) *IncidentTeamAssignmentQuery {
	query := (&IncidentTeamAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(incidentteamassignment.Table, incidentteamassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, team.IncidentAssignmentsTable, team.IncidentAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledMeetings queries the scheduled_meetings edge of a Team.
func (c *TeamClient) QueryScheduledMeetings(t *Team) *MeetingScheduleQuery {
	query := (&MeetingScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(meetingschedule.Table, meetingschedule.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, team.ScheduledMeetingsTable, team.ScheduledMeetingsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamClient) Hooks() []Hook {
	hooks := c.hooks.Team
	return append(hooks[:len(hooks):len(hooks)], team.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TeamClient) Interceptors() []Interceptor {
	return c.inters.Team
}

func (c *TeamClient) mutate(ctx context.Context, m *TeamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Team mutation op: %q", m.Op())
	}
}

// TenantClient is a client for the Tenant schema.
type TenantClient struct {
	config
}

// NewTenantClient returns a client for the Tenant from the given config.
func NewTenantClient(c config) *TenantClient {
	return &TenantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tenant.Hooks(f(g(h())))`.
func (c *TenantClient) Use(hooks ...Hook) {
	c.hooks.Tenant = append(c.hooks.Tenant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tenant.Intercept(f(g(h())))`.
func (c *TenantClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tenant = append(c.inters.Tenant, interceptors...)
}

// Create returns a builder for creating a Tenant entity.
func (c *TenantClient) Create() *TenantCreate {
	mutation := newTenantMutation(c.config, OpCreate)
	return &TenantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tenant entities.
func (c *TenantClient) CreateBulk(builders ...*TenantCreate) *TenantCreateBulk {
	return &TenantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TenantClient) MapCreateBulk(slice any, setFunc func(*TenantCreate, int)) *TenantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TenantCreateBulk{err: fmt.Errorf("calling to TenantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TenantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TenantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tenant.
func (c *TenantClient) Update() *TenantUpdate {
	mutation := newTenantMutation(c.config, OpUpdate)
	return &TenantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TenantClient) UpdateOne(t *Tenant) *TenantUpdateOne {
	mutation := newTenantMutation(c.config, OpUpdateOne, withTenant(t))
	return &TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TenantClient) UpdateOneID(id int) *TenantUpdateOne {
	mutation := newTenantMutation(c.config, OpUpdateOne, withTenantID(id))
	return &TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tenant.
func (c *TenantClient) Delete() *TenantDelete {
	mutation := newTenantMutation(c.config, OpDelete)
	return &TenantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TenantClient) DeleteOne(t *Tenant) *TenantDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TenantClient) DeleteOneID(id int) *TenantDeleteOne {
	builder := c.Delete().Where(tenant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TenantDeleteOne{builder}
}

// Query returns a query builder for Tenant.
func (c *TenantClient) Query() *TenantQuery {
	return &TenantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTenant},
		inters: c.Interceptors(),
	}
}

// Get returns a Tenant entity by its id.
func (c *TenantClient) Get(ctx context.Context, id int) (*Tenant, error) {
	return c.Query().Where(tenant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TenantClient) GetX(ctx context.Context, id int) *Tenant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TenantClient) Hooks() []Hook {
	hooks := c.hooks.Tenant
	return append(hooks[:len(hooks):len(hooks)], tenant.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TenantClient) Interceptors() []Interceptor {
	return c.inters.Tenant
}

func (c *TenantClient) mutate(ctx context.Context, m *TenantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TenantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TenantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TenantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tenant mutation op: %q", m.Op())
	}
}

// TicketClient is a client for the Ticket schema.
type TicketClient struct {
	config
}

// NewTicketClient returns a client for the Ticket from the given config.
func NewTicketClient(c config) *TicketClient {
	return &TicketClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ticket.Hooks(f(g(h())))`.
func (c *TicketClient) Use(hooks ...Hook) {
	c.hooks.Ticket = append(c.hooks.Ticket, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ticket.Intercept(f(g(h())))`.
func (c *TicketClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ticket = append(c.inters.Ticket, interceptors...)
}

// Create returns a builder for creating a Ticket entity.
func (c *TicketClient) Create() *TicketCreate {
	mutation := newTicketMutation(c.config, OpCreate)
	return &TicketCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ticket entities.
func (c *TicketClient) CreateBulk(builders ...*TicketCreate) *TicketCreateBulk {
	return &TicketCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TicketClient) MapCreateBulk(slice any, setFunc func(*TicketCreate, int)) *TicketCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TicketCreateBulk{err: fmt.Errorf("calling to TicketClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TicketCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TicketCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ticket.
func (c *TicketClient) Update() *TicketUpdate {
	mutation := newTicketMutation(c.config, OpUpdate)
	return &TicketUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TicketClient) UpdateOne(t *Ticket) *TicketUpdateOne {
	mutation := newTicketMutation(c.config, OpUpdateOne, withTicket(t))
	return &TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TicketClient) UpdateOneID(id uuid.UUID) *TicketUpdateOne {
	mutation := newTicketMutation(c.config, OpUpdateOne, withTicketID(id))
	return &TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ticket.
func (c *TicketClient) Delete() *TicketDelete {
	mutation := newTicketMutation(c.config, OpDelete)
	return &TicketDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TicketClient) DeleteOne(t *Ticket) *TicketDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TicketClient) DeleteOneID(id uuid.UUID) *TicketDeleteOne {
	builder := c.Delete().Where(ticket.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TicketDeleteOne{builder}
}

// Query returns a query builder for Ticket.
func (c *TicketClient) Query() *TicketQuery {
	return &TicketQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTicket},
		inters: c.Interceptors(),
	}
}

// Get returns a Ticket entity by its id.
func (c *TicketClient) Get(ctx context.Context, id uuid.UUID) (*Ticket, error) {
	return c.Query().Where(ticket.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TicketClient) GetX(ctx context.Context, id uuid.UUID) *Ticket {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTasks queries the tasks edge of a Ticket.
func (c *TicketClient) QueryTasks(t *Ticket) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, ticket.TasksTable, ticket.TasksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TicketClient) Hooks() []Hook {
	hooks := c.hooks.Ticket
	return append(hooks[:len(hooks):len(hooks)], ticket.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TicketClient) Interceptors() []Interceptor {
	return c.inters.Ticket
}

func (c *TicketClient) mutate(ctx context.Context, m *TicketMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TicketCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TicketUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TicketDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Ticket mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a User.
func (c *UserClient) QueryTenant(u *User) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, user.TenantTable, user.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the teams edge of a User.
func (c *UserClient) QueryTeams(u *User) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.TeamsTable, user.TeamsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWatchedOncallRosters queries the watched_oncall_rosters edge of a User.
func (c *UserClient) QueryWatchedOncallRosters(u *User) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.WatchedOncallRostersTable, user.WatchedOncallRostersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOncallSchedules queries the oncall_schedules edge of a User.
func (c *UserClient) QueryOncallSchedules(u *User) *OncallScheduleParticipantQuery {
	query := (&OncallScheduleParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(oncallscheduleparticipant.Table, oncallscheduleparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.OncallSchedulesTable, user.OncallSchedulesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOncallShifts queries the oncall_shifts edge of a User.
func (c *UserClient) QueryOncallShifts(u *User) *OncallUserShiftQuery {
	query := (&OncallUserShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(oncallusershift.Table, oncallusershift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.OncallShiftsTable, user.OncallShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOncallAnnotations queries the oncall_annotations edge of a User.
func (c *UserClient) QueryOncallAnnotations(u *User) *OncallAnnotationQuery {
	query := (&OncallAnnotationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(oncallannotation.Table, oncallannotation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.OncallAnnotationsTable, user.OncallAnnotationsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentRoleAssignments queries the incident_role_assignments edge of a User.
func (c *UserClient) QueryIncidentRoleAssignments(u *User) *IncidentRoleAssignmentQuery {
	query := (&IncidentRoleAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(incidentroleassignment.Table, incidentroleassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.IncidentRoleAssignmentsTable, user.IncidentRoleAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentDebriefs queries the incident_debriefs edge of a User.
func (c *UserClient) QueryIncidentDebriefs(u *User) *IncidentDebriefQuery {
	query := (&IncidentDebriefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(incidentdebrief.Table, incidentdebrief.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.IncidentDebriefsTable, user.IncidentDebriefsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedTasks queries the assigned_tasks edge of a User.
func (c *UserClient) QueryAssignedTasks(u *User) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssignedTasksTable, user.AssignedTasksColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedTasks queries the created_tasks edge of a User.
func (c *UserClient) QueryCreatedTasks(u *User) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedTasksTable, user.CreatedTasksColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRetrospectiveReviewRequests queries the retrospective_review_requests edge of a User.
func (c *UserClient) QueryRetrospectiveReviewRequests(u *User) *RetrospectiveReviewQuery {
	query := (&RetrospectiveReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(retrospectivereview.Table, retrospectivereview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.RetrospectiveReviewRequestsTable, user.RetrospectiveReviewRequestsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRetrospectiveReviewResponses queries the retrospective_review_responses edge of a User.
func (c *UserClient) QueryRetrospectiveReviewResponses(u *User) *RetrospectiveReviewQuery {
	query := (&RetrospectiveReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(retrospectivereview.Table, retrospectivereview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.RetrospectiveReviewResponsesTable, user.RetrospectiveReviewResponsesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Alert, AlertMetrics, Environment, Functionality, Incident, IncidentDebrief,
		IncidentDebriefMessage, IncidentDebriefQuestion, IncidentDebriefSuggestion,
		IncidentEvent, IncidentEventContext, IncidentEventContributingFactor,
		IncidentEventEvidence, IncidentEventSystemComponent, IncidentField,
		IncidentFieldOption, IncidentLink, IncidentMilestone, IncidentRole,
		IncidentRoleAssignment, IncidentSeverity, IncidentTag, IncidentTeamAssignment,
		IncidentType, MeetingSchedule, MeetingSession, OncallAnnotation,
		OncallAnnotationAlertFeedback, OncallEvent, OncallHandoverTemplate,
		OncallRoster, OncallRosterMetrics, OncallSchedule, OncallScheduleParticipant,
		OncallUserShift, OncallUserShiftHandover, OncallUserShiftMetrics, Playbook,
		ProviderConfig, ProviderSyncHistory, Retrospective, RetrospectiveDiscussion,
		RetrospectiveDiscussionReply, RetrospectiveReview, SystemAnalysis,
		SystemAnalysisComponent, SystemAnalysisRelationship, SystemComponent,
		SystemComponentConstraint, SystemComponentControl, SystemComponentKind,
		SystemComponentRelationship, SystemComponentSignal, SystemHazard,
		SystemRelationshipControlAction, SystemRelationshipFeedbackSignal, Task, Team,
		Tenant, Ticket, User []ent.Hook
	}
	inters struct {
		Alert, AlertMetrics, Environment, Functionality, Incident, IncidentDebrief,
		IncidentDebriefMessage, IncidentDebriefQuestion, IncidentDebriefSuggestion,
		IncidentEvent, IncidentEventContext, IncidentEventContributingFactor,
		IncidentEventEvidence, IncidentEventSystemComponent, IncidentField,
		IncidentFieldOption, IncidentLink, IncidentMilestone, IncidentRole,
		IncidentRoleAssignment, IncidentSeverity, IncidentTag, IncidentTeamAssignment,
		IncidentType, MeetingSchedule, MeetingSession, OncallAnnotation,
		OncallAnnotationAlertFeedback, OncallEvent, OncallHandoverTemplate,
		OncallRoster, OncallRosterMetrics, OncallSchedule, OncallScheduleParticipant,
		OncallUserShift, OncallUserShiftHandover, OncallUserShiftMetrics, Playbook,
		ProviderConfig, ProviderSyncHistory, Retrospective, RetrospectiveDiscussion,
		RetrospectiveDiscussionReply, RetrospectiveReview, SystemAnalysis,
		SystemAnalysisComponent, SystemAnalysisRelationship, SystemComponent,
		SystemComponentConstraint, SystemComponentControl, SystemComponentKind,
		SystemComponentRelationship, SystemComponentSignal, SystemHazard,
		SystemRelationshipControlAction, SystemRelationshipFeedbackSignal, Task, Team,
		Tenant, Ticket, User []ent.Interceptor
	}
)
