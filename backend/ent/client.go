// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/google/uuid"
	"github.com/rezible/rezible/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/rezible/rezible/ent/environment"
	"github.com/rezible/rezible/ent/functionality"
	"github.com/rezible/rezible/ent/incident"
	"github.com/rezible/rezible/ent/incidentdebrief"
	"github.com/rezible/rezible/ent/incidentdebriefmessage"
	"github.com/rezible/rezible/ent/incidentdebriefquestion"
	"github.com/rezible/rezible/ent/incidentdebriefsuggestion"
	"github.com/rezible/rezible/ent/incidentevent"
	"github.com/rezible/rezible/ent/incidentfield"
	"github.com/rezible/rezible/ent/incidentfieldoption"
	"github.com/rezible/rezible/ent/incidentlink"
	"github.com/rezible/rezible/ent/incidentresourceimpact"
	"github.com/rezible/rezible/ent/incidentrole"
	"github.com/rezible/rezible/ent/incidentroleassignment"
	"github.com/rezible/rezible/ent/incidentseverity"
	"github.com/rezible/rezible/ent/incidenttag"
	"github.com/rezible/rezible/ent/incidentteamassignment"
	"github.com/rezible/rezible/ent/incidenttype"
	"github.com/rezible/rezible/ent/meetingschedule"
	"github.com/rezible/rezible/ent/meetingsession"
	"github.com/rezible/rezible/ent/oncallalert"
	"github.com/rezible/rezible/ent/oncallalertinstance"
	"github.com/rezible/rezible/ent/oncallhandovertemplate"
	"github.com/rezible/rezible/ent/oncallroster"
	"github.com/rezible/rezible/ent/oncallschedule"
	"github.com/rezible/rezible/ent/oncallscheduleparticipant"
	"github.com/rezible/rezible/ent/oncallusershift"
	"github.com/rezible/rezible/ent/oncallusershiftannotation"
	"github.com/rezible/rezible/ent/oncallusershiftcover"
	"github.com/rezible/rezible/ent/oncallusershifthandover"
	"github.com/rezible/rezible/ent/providerconfig"
	"github.com/rezible/rezible/ent/providersynchistory"
	"github.com/rezible/rezible/ent/retrospective"
	"github.com/rezible/rezible/ent/retrospectivediscussion"
	"github.com/rezible/rezible/ent/retrospectivediscussionreply"
	"github.com/rezible/rezible/ent/retrospectivereview"
	"github.com/rezible/rezible/ent/service"
	"github.com/rezible/rezible/ent/subscription"
	"github.com/rezible/rezible/ent/task"
	"github.com/rezible/rezible/ent/team"
	"github.com/rezible/rezible/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Environment is the client for interacting with the Environment builders.
	Environment *EnvironmentClient
	// Functionality is the client for interacting with the Functionality builders.
	Functionality *FunctionalityClient
	// Incident is the client for interacting with the Incident builders.
	Incident *IncidentClient
	// IncidentDebrief is the client for interacting with the IncidentDebrief builders.
	IncidentDebrief *IncidentDebriefClient
	// IncidentDebriefMessage is the client for interacting with the IncidentDebriefMessage builders.
	IncidentDebriefMessage *IncidentDebriefMessageClient
	// IncidentDebriefQuestion is the client for interacting with the IncidentDebriefQuestion builders.
	IncidentDebriefQuestion *IncidentDebriefQuestionClient
	// IncidentDebriefSuggestion is the client for interacting with the IncidentDebriefSuggestion builders.
	IncidentDebriefSuggestion *IncidentDebriefSuggestionClient
	// IncidentEvent is the client for interacting with the IncidentEvent builders.
	IncidentEvent *IncidentEventClient
	// IncidentField is the client for interacting with the IncidentField builders.
	IncidentField *IncidentFieldClient
	// IncidentFieldOption is the client for interacting with the IncidentFieldOption builders.
	IncidentFieldOption *IncidentFieldOptionClient
	// IncidentLink is the client for interacting with the IncidentLink builders.
	IncidentLink *IncidentLinkClient
	// IncidentResourceImpact is the client for interacting with the IncidentResourceImpact builders.
	IncidentResourceImpact *IncidentResourceImpactClient
	// IncidentRole is the client for interacting with the IncidentRole builders.
	IncidentRole *IncidentRoleClient
	// IncidentRoleAssignment is the client for interacting with the IncidentRoleAssignment builders.
	IncidentRoleAssignment *IncidentRoleAssignmentClient
	// IncidentSeverity is the client for interacting with the IncidentSeverity builders.
	IncidentSeverity *IncidentSeverityClient
	// IncidentTag is the client for interacting with the IncidentTag builders.
	IncidentTag *IncidentTagClient
	// IncidentTeamAssignment is the client for interacting with the IncidentTeamAssignment builders.
	IncidentTeamAssignment *IncidentTeamAssignmentClient
	// IncidentType is the client for interacting with the IncidentType builders.
	IncidentType *IncidentTypeClient
	// MeetingSchedule is the client for interacting with the MeetingSchedule builders.
	MeetingSchedule *MeetingScheduleClient
	// MeetingSession is the client for interacting with the MeetingSession builders.
	MeetingSession *MeetingSessionClient
	// OncallAlert is the client for interacting with the OncallAlert builders.
	OncallAlert *OncallAlertClient
	// OncallAlertInstance is the client for interacting with the OncallAlertInstance builders.
	OncallAlertInstance *OncallAlertInstanceClient
	// OncallHandoverTemplate is the client for interacting with the OncallHandoverTemplate builders.
	OncallHandoverTemplate *OncallHandoverTemplateClient
	// OncallRoster is the client for interacting with the OncallRoster builders.
	OncallRoster *OncallRosterClient
	// OncallSchedule is the client for interacting with the OncallSchedule builders.
	OncallSchedule *OncallScheduleClient
	// OncallScheduleParticipant is the client for interacting with the OncallScheduleParticipant builders.
	OncallScheduleParticipant *OncallScheduleParticipantClient
	// OncallUserShift is the client for interacting with the OncallUserShift builders.
	OncallUserShift *OncallUserShiftClient
	// OncallUserShiftAnnotation is the client for interacting with the OncallUserShiftAnnotation builders.
	OncallUserShiftAnnotation *OncallUserShiftAnnotationClient
	// OncallUserShiftCover is the client for interacting with the OncallUserShiftCover builders.
	OncallUserShiftCover *OncallUserShiftCoverClient
	// OncallUserShiftHandover is the client for interacting with the OncallUserShiftHandover builders.
	OncallUserShiftHandover *OncallUserShiftHandoverClient
	// ProviderConfig is the client for interacting with the ProviderConfig builders.
	ProviderConfig *ProviderConfigClient
	// ProviderSyncHistory is the client for interacting with the ProviderSyncHistory builders.
	ProviderSyncHistory *ProviderSyncHistoryClient
	// Retrospective is the client for interacting with the Retrospective builders.
	Retrospective *RetrospectiveClient
	// RetrospectiveDiscussion is the client for interacting with the RetrospectiveDiscussion builders.
	RetrospectiveDiscussion *RetrospectiveDiscussionClient
	// RetrospectiveDiscussionReply is the client for interacting with the RetrospectiveDiscussionReply builders.
	RetrospectiveDiscussionReply *RetrospectiveDiscussionReplyClient
	// RetrospectiveReview is the client for interacting with the RetrospectiveReview builders.
	RetrospectiveReview *RetrospectiveReviewClient
	// Service is the client for interacting with the Service builders.
	Service *ServiceClient
	// Subscription is the client for interacting with the Subscription builders.
	Subscription *SubscriptionClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// Team is the client for interacting with the Team builders.
	Team *TeamClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Environment = NewEnvironmentClient(c.config)
	c.Functionality = NewFunctionalityClient(c.config)
	c.Incident = NewIncidentClient(c.config)
	c.IncidentDebrief = NewIncidentDebriefClient(c.config)
	c.IncidentDebriefMessage = NewIncidentDebriefMessageClient(c.config)
	c.IncidentDebriefQuestion = NewIncidentDebriefQuestionClient(c.config)
	c.IncidentDebriefSuggestion = NewIncidentDebriefSuggestionClient(c.config)
	c.IncidentEvent = NewIncidentEventClient(c.config)
	c.IncidentField = NewIncidentFieldClient(c.config)
	c.IncidentFieldOption = NewIncidentFieldOptionClient(c.config)
	c.IncidentLink = NewIncidentLinkClient(c.config)
	c.IncidentResourceImpact = NewIncidentResourceImpactClient(c.config)
	c.IncidentRole = NewIncidentRoleClient(c.config)
	c.IncidentRoleAssignment = NewIncidentRoleAssignmentClient(c.config)
	c.IncidentSeverity = NewIncidentSeverityClient(c.config)
	c.IncidentTag = NewIncidentTagClient(c.config)
	c.IncidentTeamAssignment = NewIncidentTeamAssignmentClient(c.config)
	c.IncidentType = NewIncidentTypeClient(c.config)
	c.MeetingSchedule = NewMeetingScheduleClient(c.config)
	c.MeetingSession = NewMeetingSessionClient(c.config)
	c.OncallAlert = NewOncallAlertClient(c.config)
	c.OncallAlertInstance = NewOncallAlertInstanceClient(c.config)
	c.OncallHandoverTemplate = NewOncallHandoverTemplateClient(c.config)
	c.OncallRoster = NewOncallRosterClient(c.config)
	c.OncallSchedule = NewOncallScheduleClient(c.config)
	c.OncallScheduleParticipant = NewOncallScheduleParticipantClient(c.config)
	c.OncallUserShift = NewOncallUserShiftClient(c.config)
	c.OncallUserShiftAnnotation = NewOncallUserShiftAnnotationClient(c.config)
	c.OncallUserShiftCover = NewOncallUserShiftCoverClient(c.config)
	c.OncallUserShiftHandover = NewOncallUserShiftHandoverClient(c.config)
	c.ProviderConfig = NewProviderConfigClient(c.config)
	c.ProviderSyncHistory = NewProviderSyncHistoryClient(c.config)
	c.Retrospective = NewRetrospectiveClient(c.config)
	c.RetrospectiveDiscussion = NewRetrospectiveDiscussionClient(c.config)
	c.RetrospectiveDiscussionReply = NewRetrospectiveDiscussionReplyClient(c.config)
	c.RetrospectiveReview = NewRetrospectiveReviewClient(c.config)
	c.Service = NewServiceClient(c.config)
	c.Subscription = NewSubscriptionClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.Team = NewTeamClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                          ctx,
		config:                       cfg,
		Environment:                  NewEnvironmentClient(cfg),
		Functionality:                NewFunctionalityClient(cfg),
		Incident:                     NewIncidentClient(cfg),
		IncidentDebrief:              NewIncidentDebriefClient(cfg),
		IncidentDebriefMessage:       NewIncidentDebriefMessageClient(cfg),
		IncidentDebriefQuestion:      NewIncidentDebriefQuestionClient(cfg),
		IncidentDebriefSuggestion:    NewIncidentDebriefSuggestionClient(cfg),
		IncidentEvent:                NewIncidentEventClient(cfg),
		IncidentField:                NewIncidentFieldClient(cfg),
		IncidentFieldOption:          NewIncidentFieldOptionClient(cfg),
		IncidentLink:                 NewIncidentLinkClient(cfg),
		IncidentResourceImpact:       NewIncidentResourceImpactClient(cfg),
		IncidentRole:                 NewIncidentRoleClient(cfg),
		IncidentRoleAssignment:       NewIncidentRoleAssignmentClient(cfg),
		IncidentSeverity:             NewIncidentSeverityClient(cfg),
		IncidentTag:                  NewIncidentTagClient(cfg),
		IncidentTeamAssignment:       NewIncidentTeamAssignmentClient(cfg),
		IncidentType:                 NewIncidentTypeClient(cfg),
		MeetingSchedule:              NewMeetingScheduleClient(cfg),
		MeetingSession:               NewMeetingSessionClient(cfg),
		OncallAlert:                  NewOncallAlertClient(cfg),
		OncallAlertInstance:          NewOncallAlertInstanceClient(cfg),
		OncallHandoverTemplate:       NewOncallHandoverTemplateClient(cfg),
		OncallRoster:                 NewOncallRosterClient(cfg),
		OncallSchedule:               NewOncallScheduleClient(cfg),
		OncallScheduleParticipant:    NewOncallScheduleParticipantClient(cfg),
		OncallUserShift:              NewOncallUserShiftClient(cfg),
		OncallUserShiftAnnotation:    NewOncallUserShiftAnnotationClient(cfg),
		OncallUserShiftCover:         NewOncallUserShiftCoverClient(cfg),
		OncallUserShiftHandover:      NewOncallUserShiftHandoverClient(cfg),
		ProviderConfig:               NewProviderConfigClient(cfg),
		ProviderSyncHistory:          NewProviderSyncHistoryClient(cfg),
		Retrospective:                NewRetrospectiveClient(cfg),
		RetrospectiveDiscussion:      NewRetrospectiveDiscussionClient(cfg),
		RetrospectiveDiscussionReply: NewRetrospectiveDiscussionReplyClient(cfg),
		RetrospectiveReview:          NewRetrospectiveReviewClient(cfg),
		Service:                      NewServiceClient(cfg),
		Subscription:                 NewSubscriptionClient(cfg),
		Task:                         NewTaskClient(cfg),
		Team:                         NewTeamClient(cfg),
		User:                         NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                          ctx,
		config:                       cfg,
		Environment:                  NewEnvironmentClient(cfg),
		Functionality:                NewFunctionalityClient(cfg),
		Incident:                     NewIncidentClient(cfg),
		IncidentDebrief:              NewIncidentDebriefClient(cfg),
		IncidentDebriefMessage:       NewIncidentDebriefMessageClient(cfg),
		IncidentDebriefQuestion:      NewIncidentDebriefQuestionClient(cfg),
		IncidentDebriefSuggestion:    NewIncidentDebriefSuggestionClient(cfg),
		IncidentEvent:                NewIncidentEventClient(cfg),
		IncidentField:                NewIncidentFieldClient(cfg),
		IncidentFieldOption:          NewIncidentFieldOptionClient(cfg),
		IncidentLink:                 NewIncidentLinkClient(cfg),
		IncidentResourceImpact:       NewIncidentResourceImpactClient(cfg),
		IncidentRole:                 NewIncidentRoleClient(cfg),
		IncidentRoleAssignment:       NewIncidentRoleAssignmentClient(cfg),
		IncidentSeverity:             NewIncidentSeverityClient(cfg),
		IncidentTag:                  NewIncidentTagClient(cfg),
		IncidentTeamAssignment:       NewIncidentTeamAssignmentClient(cfg),
		IncidentType:                 NewIncidentTypeClient(cfg),
		MeetingSchedule:              NewMeetingScheduleClient(cfg),
		MeetingSession:               NewMeetingSessionClient(cfg),
		OncallAlert:                  NewOncallAlertClient(cfg),
		OncallAlertInstance:          NewOncallAlertInstanceClient(cfg),
		OncallHandoverTemplate:       NewOncallHandoverTemplateClient(cfg),
		OncallRoster:                 NewOncallRosterClient(cfg),
		OncallSchedule:               NewOncallScheduleClient(cfg),
		OncallScheduleParticipant:    NewOncallScheduleParticipantClient(cfg),
		OncallUserShift:              NewOncallUserShiftClient(cfg),
		OncallUserShiftAnnotation:    NewOncallUserShiftAnnotationClient(cfg),
		OncallUserShiftCover:         NewOncallUserShiftCoverClient(cfg),
		OncallUserShiftHandover:      NewOncallUserShiftHandoverClient(cfg),
		ProviderConfig:               NewProviderConfigClient(cfg),
		ProviderSyncHistory:          NewProviderSyncHistoryClient(cfg),
		Retrospective:                NewRetrospectiveClient(cfg),
		RetrospectiveDiscussion:      NewRetrospectiveDiscussionClient(cfg),
		RetrospectiveDiscussionReply: NewRetrospectiveDiscussionReplyClient(cfg),
		RetrospectiveReview:          NewRetrospectiveReviewClient(cfg),
		Service:                      NewServiceClient(cfg),
		Subscription:                 NewSubscriptionClient(cfg),
		Task:                         NewTaskClient(cfg),
		Team:                         NewTeamClient(cfg),
		User:                         NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Environment.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Environment, c.Functionality, c.Incident, c.IncidentDebrief,
		c.IncidentDebriefMessage, c.IncidentDebriefQuestion,
		c.IncidentDebriefSuggestion, c.IncidentEvent, c.IncidentField,
		c.IncidentFieldOption, c.IncidentLink, c.IncidentResourceImpact,
		c.IncidentRole, c.IncidentRoleAssignment, c.IncidentSeverity, c.IncidentTag,
		c.IncidentTeamAssignment, c.IncidentType, c.MeetingSchedule, c.MeetingSession,
		c.OncallAlert, c.OncallAlertInstance, c.OncallHandoverTemplate, c.OncallRoster,
		c.OncallSchedule, c.OncallScheduleParticipant, c.OncallUserShift,
		c.OncallUserShiftAnnotation, c.OncallUserShiftCover, c.OncallUserShiftHandover,
		c.ProviderConfig, c.ProviderSyncHistory, c.Retrospective,
		c.RetrospectiveDiscussion, c.RetrospectiveDiscussionReply,
		c.RetrospectiveReview, c.Service, c.Subscription, c.Task, c.Team, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Environment, c.Functionality, c.Incident, c.IncidentDebrief,
		c.IncidentDebriefMessage, c.IncidentDebriefQuestion,
		c.IncidentDebriefSuggestion, c.IncidentEvent, c.IncidentField,
		c.IncidentFieldOption, c.IncidentLink, c.IncidentResourceImpact,
		c.IncidentRole, c.IncidentRoleAssignment, c.IncidentSeverity, c.IncidentTag,
		c.IncidentTeamAssignment, c.IncidentType, c.MeetingSchedule, c.MeetingSession,
		c.OncallAlert, c.OncallAlertInstance, c.OncallHandoverTemplate, c.OncallRoster,
		c.OncallSchedule, c.OncallScheduleParticipant, c.OncallUserShift,
		c.OncallUserShiftAnnotation, c.OncallUserShiftCover, c.OncallUserShiftHandover,
		c.ProviderConfig, c.ProviderSyncHistory, c.Retrospective,
		c.RetrospectiveDiscussion, c.RetrospectiveDiscussionReply,
		c.RetrospectiveReview, c.Service, c.Subscription, c.Task, c.Team, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *EnvironmentMutation:
		return c.Environment.mutate(ctx, m)
	case *FunctionalityMutation:
		return c.Functionality.mutate(ctx, m)
	case *IncidentMutation:
		return c.Incident.mutate(ctx, m)
	case *IncidentDebriefMutation:
		return c.IncidentDebrief.mutate(ctx, m)
	case *IncidentDebriefMessageMutation:
		return c.IncidentDebriefMessage.mutate(ctx, m)
	case *IncidentDebriefQuestionMutation:
		return c.IncidentDebriefQuestion.mutate(ctx, m)
	case *IncidentDebriefSuggestionMutation:
		return c.IncidentDebriefSuggestion.mutate(ctx, m)
	case *IncidentEventMutation:
		return c.IncidentEvent.mutate(ctx, m)
	case *IncidentFieldMutation:
		return c.IncidentField.mutate(ctx, m)
	case *IncidentFieldOptionMutation:
		return c.IncidentFieldOption.mutate(ctx, m)
	case *IncidentLinkMutation:
		return c.IncidentLink.mutate(ctx, m)
	case *IncidentResourceImpactMutation:
		return c.IncidentResourceImpact.mutate(ctx, m)
	case *IncidentRoleMutation:
		return c.IncidentRole.mutate(ctx, m)
	case *IncidentRoleAssignmentMutation:
		return c.IncidentRoleAssignment.mutate(ctx, m)
	case *IncidentSeverityMutation:
		return c.IncidentSeverity.mutate(ctx, m)
	case *IncidentTagMutation:
		return c.IncidentTag.mutate(ctx, m)
	case *IncidentTeamAssignmentMutation:
		return c.IncidentTeamAssignment.mutate(ctx, m)
	case *IncidentTypeMutation:
		return c.IncidentType.mutate(ctx, m)
	case *MeetingScheduleMutation:
		return c.MeetingSchedule.mutate(ctx, m)
	case *MeetingSessionMutation:
		return c.MeetingSession.mutate(ctx, m)
	case *OncallAlertMutation:
		return c.OncallAlert.mutate(ctx, m)
	case *OncallAlertInstanceMutation:
		return c.OncallAlertInstance.mutate(ctx, m)
	case *OncallHandoverTemplateMutation:
		return c.OncallHandoverTemplate.mutate(ctx, m)
	case *OncallRosterMutation:
		return c.OncallRoster.mutate(ctx, m)
	case *OncallScheduleMutation:
		return c.OncallSchedule.mutate(ctx, m)
	case *OncallScheduleParticipantMutation:
		return c.OncallScheduleParticipant.mutate(ctx, m)
	case *OncallUserShiftMutation:
		return c.OncallUserShift.mutate(ctx, m)
	case *OncallUserShiftAnnotationMutation:
		return c.OncallUserShiftAnnotation.mutate(ctx, m)
	case *OncallUserShiftCoverMutation:
		return c.OncallUserShiftCover.mutate(ctx, m)
	case *OncallUserShiftHandoverMutation:
		return c.OncallUserShiftHandover.mutate(ctx, m)
	case *ProviderConfigMutation:
		return c.ProviderConfig.mutate(ctx, m)
	case *ProviderSyncHistoryMutation:
		return c.ProviderSyncHistory.mutate(ctx, m)
	case *RetrospectiveMutation:
		return c.Retrospective.mutate(ctx, m)
	case *RetrospectiveDiscussionMutation:
		return c.RetrospectiveDiscussion.mutate(ctx, m)
	case *RetrospectiveDiscussionReplyMutation:
		return c.RetrospectiveDiscussionReply.mutate(ctx, m)
	case *RetrospectiveReviewMutation:
		return c.RetrospectiveReview.mutate(ctx, m)
	case *ServiceMutation:
		return c.Service.mutate(ctx, m)
	case *SubscriptionMutation:
		return c.Subscription.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *TeamMutation:
		return c.Team.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// EnvironmentClient is a client for the Environment schema.
type EnvironmentClient struct {
	config
}

// NewEnvironmentClient returns a client for the Environment from the given config.
func NewEnvironmentClient(c config) *EnvironmentClient {
	return &EnvironmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `environment.Hooks(f(g(h())))`.
func (c *EnvironmentClient) Use(hooks ...Hook) {
	c.hooks.Environment = append(c.hooks.Environment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `environment.Intercept(f(g(h())))`.
func (c *EnvironmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Environment = append(c.inters.Environment, interceptors...)
}

// Create returns a builder for creating a Environment entity.
func (c *EnvironmentClient) Create() *EnvironmentCreate {
	mutation := newEnvironmentMutation(c.config, OpCreate)
	return &EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Environment entities.
func (c *EnvironmentClient) CreateBulk(builders ...*EnvironmentCreate) *EnvironmentCreateBulk {
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvironmentClient) MapCreateBulk(slice any, setFunc func(*EnvironmentCreate, int)) *EnvironmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvironmentCreateBulk{err: fmt.Errorf("calling to EnvironmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvironmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Environment.
func (c *EnvironmentClient) Update() *EnvironmentUpdate {
	mutation := newEnvironmentMutation(c.config, OpUpdate)
	return &EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvironmentClient) UpdateOne(e *Environment) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironment(e))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvironmentClient) UpdateOneID(id uuid.UUID) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironmentID(id))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Environment.
func (c *EnvironmentClient) Delete() *EnvironmentDelete {
	mutation := newEnvironmentMutation(c.config, OpDelete)
	return &EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvironmentClient) DeleteOne(e *Environment) *EnvironmentDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvironmentClient) DeleteOneID(id uuid.UUID) *EnvironmentDeleteOne {
	builder := c.Delete().Where(environment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvironmentDeleteOne{builder}
}

// Query returns a query builder for Environment.
func (c *EnvironmentClient) Query() *EnvironmentQuery {
	return &EnvironmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnvironment},
		inters: c.Interceptors(),
	}
}

// Get returns a Environment entity by its id.
func (c *EnvironmentClient) Get(ctx context.Context, id uuid.UUID) (*Environment, error) {
	return c.Query().Where(environment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvironmentClient) GetX(ctx context.Context, id uuid.UUID) *Environment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a Environment.
func (c *EnvironmentClient) QueryIncidents(e *Environment) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, environment.IncidentsTable, environment.IncidentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvironmentClient) Hooks() []Hook {
	hooks := c.hooks.Environment
	return append(hooks[:len(hooks):len(hooks)], environment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EnvironmentClient) Interceptors() []Interceptor {
	inters := c.inters.Environment
	return append(inters[:len(inters):len(inters)], environment.Interceptors[:]...)
}

func (c *EnvironmentClient) mutate(ctx context.Context, m *EnvironmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Environment mutation op: %q", m.Op())
	}
}

// FunctionalityClient is a client for the Functionality schema.
type FunctionalityClient struct {
	config
}

// NewFunctionalityClient returns a client for the Functionality from the given config.
func NewFunctionalityClient(c config) *FunctionalityClient {
	return &FunctionalityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `functionality.Hooks(f(g(h())))`.
func (c *FunctionalityClient) Use(hooks ...Hook) {
	c.hooks.Functionality = append(c.hooks.Functionality, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `functionality.Intercept(f(g(h())))`.
func (c *FunctionalityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Functionality = append(c.inters.Functionality, interceptors...)
}

// Create returns a builder for creating a Functionality entity.
func (c *FunctionalityClient) Create() *FunctionalityCreate {
	mutation := newFunctionalityMutation(c.config, OpCreate)
	return &FunctionalityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Functionality entities.
func (c *FunctionalityClient) CreateBulk(builders ...*FunctionalityCreate) *FunctionalityCreateBulk {
	return &FunctionalityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FunctionalityClient) MapCreateBulk(slice any, setFunc func(*FunctionalityCreate, int)) *FunctionalityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FunctionalityCreateBulk{err: fmt.Errorf("calling to FunctionalityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FunctionalityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FunctionalityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Functionality.
func (c *FunctionalityClient) Update() *FunctionalityUpdate {
	mutation := newFunctionalityMutation(c.config, OpUpdate)
	return &FunctionalityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FunctionalityClient) UpdateOne(f *Functionality) *FunctionalityUpdateOne {
	mutation := newFunctionalityMutation(c.config, OpUpdateOne, withFunctionality(f))
	return &FunctionalityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FunctionalityClient) UpdateOneID(id uuid.UUID) *FunctionalityUpdateOne {
	mutation := newFunctionalityMutation(c.config, OpUpdateOne, withFunctionalityID(id))
	return &FunctionalityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Functionality.
func (c *FunctionalityClient) Delete() *FunctionalityDelete {
	mutation := newFunctionalityMutation(c.config, OpDelete)
	return &FunctionalityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FunctionalityClient) DeleteOne(f *Functionality) *FunctionalityDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FunctionalityClient) DeleteOneID(id uuid.UUID) *FunctionalityDeleteOne {
	builder := c.Delete().Where(functionality.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FunctionalityDeleteOne{builder}
}

// Query returns a query builder for Functionality.
func (c *FunctionalityClient) Query() *FunctionalityQuery {
	return &FunctionalityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFunctionality},
		inters: c.Interceptors(),
	}
}

// Get returns a Functionality entity by its id.
func (c *FunctionalityClient) Get(ctx context.Context, id uuid.UUID) (*Functionality, error) {
	return c.Query().Where(functionality.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FunctionalityClient) GetX(ctx context.Context, id uuid.UUID) *Functionality {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a Functionality.
func (c *FunctionalityClient) QueryIncidents(f *Functionality) *IncidentResourceImpactQuery {
	query := (&IncidentResourceImpactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(functionality.Table, functionality.FieldID, id),
			sqlgraph.To(incidentresourceimpact.Table, incidentresourceimpact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, functionality.IncidentsTable, functionality.IncidentsColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FunctionalityClient) Hooks() []Hook {
	return c.hooks.Functionality
}

// Interceptors returns the client interceptors.
func (c *FunctionalityClient) Interceptors() []Interceptor {
	return c.inters.Functionality
}

func (c *FunctionalityClient) mutate(ctx context.Context, m *FunctionalityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FunctionalityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FunctionalityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FunctionalityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FunctionalityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Functionality mutation op: %q", m.Op())
	}
}

// IncidentClient is a client for the Incident schema.
type IncidentClient struct {
	config
}

// NewIncidentClient returns a client for the Incident from the given config.
func NewIncidentClient(c config) *IncidentClient {
	return &IncidentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incident.Hooks(f(g(h())))`.
func (c *IncidentClient) Use(hooks ...Hook) {
	c.hooks.Incident = append(c.hooks.Incident, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incident.Intercept(f(g(h())))`.
func (c *IncidentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Incident = append(c.inters.Incident, interceptors...)
}

// Create returns a builder for creating a Incident entity.
func (c *IncidentClient) Create() *IncidentCreate {
	mutation := newIncidentMutation(c.config, OpCreate)
	return &IncidentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Incident entities.
func (c *IncidentClient) CreateBulk(builders ...*IncidentCreate) *IncidentCreateBulk {
	return &IncidentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentClient) MapCreateBulk(slice any, setFunc func(*IncidentCreate, int)) *IncidentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentCreateBulk{err: fmt.Errorf("calling to IncidentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Incident.
func (c *IncidentClient) Update() *IncidentUpdate {
	mutation := newIncidentMutation(c.config, OpUpdate)
	return &IncidentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentClient) UpdateOne(i *Incident) *IncidentUpdateOne {
	mutation := newIncidentMutation(c.config, OpUpdateOne, withIncident(i))
	return &IncidentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentClient) UpdateOneID(id uuid.UUID) *IncidentUpdateOne {
	mutation := newIncidentMutation(c.config, OpUpdateOne, withIncidentID(id))
	return &IncidentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Incident.
func (c *IncidentClient) Delete() *IncidentDelete {
	mutation := newIncidentMutation(c.config, OpDelete)
	return &IncidentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentClient) DeleteOne(i *Incident) *IncidentDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentClient) DeleteOneID(id uuid.UUID) *IncidentDeleteOne {
	builder := c.Delete().Where(incident.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentDeleteOne{builder}
}

// Query returns a query builder for Incident.
func (c *IncidentClient) Query() *IncidentQuery {
	return &IncidentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncident},
		inters: c.Interceptors(),
	}
}

// Get returns a Incident entity by its id.
func (c *IncidentClient) Get(ctx context.Context, id uuid.UUID) (*Incident, error) {
	return c.Query().Where(incident.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentClient) GetX(ctx context.Context, id uuid.UUID) *Incident {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubscriptions queries the subscriptions edge of a Incident.
func (c *IncidentClient) QuerySubscriptions(i *Incident) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incident.SubscriptionsTable, incident.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeamAssignments queries the team_assignments edge of a Incident.
func (c *IncidentClient) QueryTeamAssignments(i *Incident) *IncidentTeamAssignmentQuery {
	query := (&IncidentTeamAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentteamassignment.Table, incidentteamassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incident.TeamAssignmentsTable, incident.TeamAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoleAssignments queries the role_assignments edge of a Incident.
func (c *IncidentClient) QueryRoleAssignments(i *Incident) *IncidentRoleAssignmentQuery {
	query := (&IncidentRoleAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentroleassignment.Table, incidentroleassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incident.RoleAssignmentsTable, incident.RoleAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLinkedIncidents queries the linked_incidents edge of a Incident.
func (c *IncidentClient) QueryLinkedIncidents(i *Incident) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incident.LinkedIncidentsTable, incident.LinkedIncidentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImpactedResources queries the impacted_resources edge of a Incident.
func (c *IncidentClient) QueryImpactedResources(i *Incident) *IncidentResourceImpactQuery {
	query := (&IncidentResourceImpactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentresourceimpact.Table, incidentresourceimpact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incident.ImpactedResourcesTable, incident.ImpactedResourcesColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironments queries the environments edge of a Incident.
func (c *IncidentClient) QueryEnvironments(i *Incident) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incident.EnvironmentsTable, incident.EnvironmentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeverity queries the severity edge of a Incident.
func (c *IncidentClient) QuerySeverity(i *Incident) *IncidentSeverityQuery {
	query := (&IncidentSeverityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentseverity.Table, incidentseverity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incident.SeverityTable, incident.SeverityColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryType queries the type edge of a Incident.
func (c *IncidentClient) QueryType(i *Incident) *IncidentTypeQuery {
	query := (&IncidentTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidenttype.Table, incidenttype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incident.TypeTable, incident.TypeColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRetrospective queries the retrospective edge of a Incident.
func (c *IncidentClient) QueryRetrospective(i *Incident) *RetrospectiveQuery {
	query := (&RetrospectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(retrospective.Table, retrospective.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, incident.RetrospectiveTable, incident.RetrospectiveColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Incident.
func (c *IncidentClient) QueryEvents(i *Incident) *IncidentEventQuery {
	query := (&IncidentEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentevent.Table, incidentevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incident.EventsTable, incident.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFieldSelections queries the field_selections edge of a Incident.
func (c *IncidentClient) QueryFieldSelections(i *Incident) *IncidentFieldOptionQuery {
	query := (&IncidentFieldOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentfieldoption.Table, incidentfieldoption.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incident.FieldSelectionsTable, incident.FieldSelectionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Incident.
func (c *IncidentClient) QueryTasks(i *Incident) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incident.TasksTable, incident.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTagAssignments queries the tag_assignments edge of a Incident.
func (c *IncidentClient) QueryTagAssignments(i *Incident) *IncidentTagQuery {
	query := (&IncidentTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidenttag.Table, incidenttag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incident.TagAssignmentsTable, incident.TagAssignmentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefs queries the debriefs edge of a Incident.
func (c *IncidentClient) QueryDebriefs(i *Incident) *IncidentDebriefQuery {
	query := (&IncidentDebriefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentdebrief.Table, incidentdebrief.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incident.DebriefsTable, incident.DebriefsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviewSessions queries the review_sessions edge of a Incident.
func (c *IncidentClient) QueryReviewSessions(i *Incident) *MeetingSessionQuery {
	query := (&MeetingSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(meetingsession.Table, meetingsession.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incident.ReviewSessionsTable, incident.ReviewSessionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentLinks queries the incident_links edge of a Incident.
func (c *IncidentClient) QueryIncidentLinks(i *Incident) *IncidentLinkQuery {
	query := (&IncidentLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentlink.Table, incidentlink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incident.IncidentLinksTable, incident.IncidentLinksColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentClient) Hooks() []Hook {
	return c.hooks.Incident
}

// Interceptors returns the client interceptors.
func (c *IncidentClient) Interceptors() []Interceptor {
	return c.inters.Incident
}

func (c *IncidentClient) mutate(ctx context.Context, m *IncidentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Incident mutation op: %q", m.Op())
	}
}

// IncidentDebriefClient is a client for the IncidentDebrief schema.
type IncidentDebriefClient struct {
	config
}

// NewIncidentDebriefClient returns a client for the IncidentDebrief from the given config.
func NewIncidentDebriefClient(c config) *IncidentDebriefClient {
	return &IncidentDebriefClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentdebrief.Hooks(f(g(h())))`.
func (c *IncidentDebriefClient) Use(hooks ...Hook) {
	c.hooks.IncidentDebrief = append(c.hooks.IncidentDebrief, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentdebrief.Intercept(f(g(h())))`.
func (c *IncidentDebriefClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentDebrief = append(c.inters.IncidentDebrief, interceptors...)
}

// Create returns a builder for creating a IncidentDebrief entity.
func (c *IncidentDebriefClient) Create() *IncidentDebriefCreate {
	mutation := newIncidentDebriefMutation(c.config, OpCreate)
	return &IncidentDebriefCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentDebrief entities.
func (c *IncidentDebriefClient) CreateBulk(builders ...*IncidentDebriefCreate) *IncidentDebriefCreateBulk {
	return &IncidentDebriefCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentDebriefClient) MapCreateBulk(slice any, setFunc func(*IncidentDebriefCreate, int)) *IncidentDebriefCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentDebriefCreateBulk{err: fmt.Errorf("calling to IncidentDebriefClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentDebriefCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentDebriefCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentDebrief.
func (c *IncidentDebriefClient) Update() *IncidentDebriefUpdate {
	mutation := newIncidentDebriefMutation(c.config, OpUpdate)
	return &IncidentDebriefUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentDebriefClient) UpdateOne(id *IncidentDebrief) *IncidentDebriefUpdateOne {
	mutation := newIncidentDebriefMutation(c.config, OpUpdateOne, withIncidentDebrief(id))
	return &IncidentDebriefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentDebriefClient) UpdateOneID(id uuid.UUID) *IncidentDebriefUpdateOne {
	mutation := newIncidentDebriefMutation(c.config, OpUpdateOne, withIncidentDebriefID(id))
	return &IncidentDebriefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentDebrief.
func (c *IncidentDebriefClient) Delete() *IncidentDebriefDelete {
	mutation := newIncidentDebriefMutation(c.config, OpDelete)
	return &IncidentDebriefDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentDebriefClient) DeleteOne(id *IncidentDebrief) *IncidentDebriefDeleteOne {
	return c.DeleteOneID(id.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentDebriefClient) DeleteOneID(id uuid.UUID) *IncidentDebriefDeleteOne {
	builder := c.Delete().Where(incidentdebrief.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentDebriefDeleteOne{builder}
}

// Query returns a query builder for IncidentDebrief.
func (c *IncidentDebriefClient) Query() *IncidentDebriefQuery {
	return &IncidentDebriefQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentDebrief},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentDebrief entity by its id.
func (c *IncidentDebriefClient) Get(ctx context.Context, id uuid.UUID) (*IncidentDebrief, error) {
	return c.Query().Where(incidentdebrief.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentDebriefClient) GetX(ctx context.Context, id uuid.UUID) *IncidentDebrief {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a IncidentDebrief.
func (c *IncidentDebriefClient) QueryIncident(node *IncidentDebrief) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := node.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebrief.Table, incidentdebrief.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentdebrief.IncidentTable, incidentdebrief.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(node.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a IncidentDebrief.
func (c *IncidentDebriefClient) QueryUser(node *IncidentDebrief) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := node.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebrief.Table, incidentdebrief.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentdebrief.UserTable, incidentdebrief.UserColumn),
		)
		fromV = sqlgraph.Neighbors(node.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a IncidentDebrief.
func (c *IncidentDebriefClient) QueryMessages(node *IncidentDebrief) *IncidentDebriefMessageQuery {
	query := (&IncidentDebriefMessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := node.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebrief.Table, incidentdebrief.FieldID, id),
			sqlgraph.To(incidentdebriefmessage.Table, incidentdebriefmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incidentdebrief.MessagesTable, incidentdebrief.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(node.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySuggestions queries the suggestions edge of a IncidentDebrief.
func (c *IncidentDebriefClient) QuerySuggestions(node *IncidentDebrief) *IncidentDebriefSuggestionQuery {
	query := (&IncidentDebriefSuggestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := node.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebrief.Table, incidentdebrief.FieldID, id),
			sqlgraph.To(incidentdebriefsuggestion.Table, incidentdebriefsuggestion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incidentdebrief.SuggestionsTable, incidentdebrief.SuggestionsColumn),
		)
		fromV = sqlgraph.Neighbors(node.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentDebriefClient) Hooks() []Hook {
	return c.hooks.IncidentDebrief
}

// Interceptors returns the client interceptors.
func (c *IncidentDebriefClient) Interceptors() []Interceptor {
	return c.inters.IncidentDebrief
}

func (c *IncidentDebriefClient) mutate(ctx context.Context, m *IncidentDebriefMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentDebriefCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentDebriefUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentDebriefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentDebriefDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentDebrief mutation op: %q", m.Op())
	}
}

// IncidentDebriefMessageClient is a client for the IncidentDebriefMessage schema.
type IncidentDebriefMessageClient struct {
	config
}

// NewIncidentDebriefMessageClient returns a client for the IncidentDebriefMessage from the given config.
func NewIncidentDebriefMessageClient(c config) *IncidentDebriefMessageClient {
	return &IncidentDebriefMessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentdebriefmessage.Hooks(f(g(h())))`.
func (c *IncidentDebriefMessageClient) Use(hooks ...Hook) {
	c.hooks.IncidentDebriefMessage = append(c.hooks.IncidentDebriefMessage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentdebriefmessage.Intercept(f(g(h())))`.
func (c *IncidentDebriefMessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentDebriefMessage = append(c.inters.IncidentDebriefMessage, interceptors...)
}

// Create returns a builder for creating a IncidentDebriefMessage entity.
func (c *IncidentDebriefMessageClient) Create() *IncidentDebriefMessageCreate {
	mutation := newIncidentDebriefMessageMutation(c.config, OpCreate)
	return &IncidentDebriefMessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentDebriefMessage entities.
func (c *IncidentDebriefMessageClient) CreateBulk(builders ...*IncidentDebriefMessageCreate) *IncidentDebriefMessageCreateBulk {
	return &IncidentDebriefMessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentDebriefMessageClient) MapCreateBulk(slice any, setFunc func(*IncidentDebriefMessageCreate, int)) *IncidentDebriefMessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentDebriefMessageCreateBulk{err: fmt.Errorf("calling to IncidentDebriefMessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentDebriefMessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentDebriefMessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentDebriefMessage.
func (c *IncidentDebriefMessageClient) Update() *IncidentDebriefMessageUpdate {
	mutation := newIncidentDebriefMessageMutation(c.config, OpUpdate)
	return &IncidentDebriefMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentDebriefMessageClient) UpdateOne(idm *IncidentDebriefMessage) *IncidentDebriefMessageUpdateOne {
	mutation := newIncidentDebriefMessageMutation(c.config, OpUpdateOne, withIncidentDebriefMessage(idm))
	return &IncidentDebriefMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentDebriefMessageClient) UpdateOneID(id uuid.UUID) *IncidentDebriefMessageUpdateOne {
	mutation := newIncidentDebriefMessageMutation(c.config, OpUpdateOne, withIncidentDebriefMessageID(id))
	return &IncidentDebriefMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentDebriefMessage.
func (c *IncidentDebriefMessageClient) Delete() *IncidentDebriefMessageDelete {
	mutation := newIncidentDebriefMessageMutation(c.config, OpDelete)
	return &IncidentDebriefMessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentDebriefMessageClient) DeleteOne(idm *IncidentDebriefMessage) *IncidentDebriefMessageDeleteOne {
	return c.DeleteOneID(idm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentDebriefMessageClient) DeleteOneID(id uuid.UUID) *IncidentDebriefMessageDeleteOne {
	builder := c.Delete().Where(incidentdebriefmessage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentDebriefMessageDeleteOne{builder}
}

// Query returns a query builder for IncidentDebriefMessage.
func (c *IncidentDebriefMessageClient) Query() *IncidentDebriefMessageQuery {
	return &IncidentDebriefMessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentDebriefMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentDebriefMessage entity by its id.
func (c *IncidentDebriefMessageClient) Get(ctx context.Context, id uuid.UUID) (*IncidentDebriefMessage, error) {
	return c.Query().Where(incidentdebriefmessage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentDebriefMessageClient) GetX(ctx context.Context, id uuid.UUID) *IncidentDebriefMessage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDebrief queries the debrief edge of a IncidentDebriefMessage.
func (c *IncidentDebriefMessageClient) QueryDebrief(idm *IncidentDebriefMessage) *IncidentDebriefQuery {
	query := (&IncidentDebriefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefmessage.Table, incidentdebriefmessage.FieldID, id),
			sqlgraph.To(incidentdebrief.Table, incidentdebrief.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentdebriefmessage.DebriefTable, incidentdebriefmessage.DebriefColumn),
		)
		fromV = sqlgraph.Neighbors(idm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFromQuestion queries the from_question edge of a IncidentDebriefMessage.
func (c *IncidentDebriefMessageClient) QueryFromQuestion(idm *IncidentDebriefMessage) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefmessage.Table, incidentdebriefmessage.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentdebriefmessage.FromQuestionTable, incidentdebriefmessage.FromQuestionColumn),
		)
		fromV = sqlgraph.Neighbors(idm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentDebriefMessageClient) Hooks() []Hook {
	return c.hooks.IncidentDebriefMessage
}

// Interceptors returns the client interceptors.
func (c *IncidentDebriefMessageClient) Interceptors() []Interceptor {
	return c.inters.IncidentDebriefMessage
}

func (c *IncidentDebriefMessageClient) mutate(ctx context.Context, m *IncidentDebriefMessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentDebriefMessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentDebriefMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentDebriefMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentDebriefMessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentDebriefMessage mutation op: %q", m.Op())
	}
}

// IncidentDebriefQuestionClient is a client for the IncidentDebriefQuestion schema.
type IncidentDebriefQuestionClient struct {
	config
}

// NewIncidentDebriefQuestionClient returns a client for the IncidentDebriefQuestion from the given config.
func NewIncidentDebriefQuestionClient(c config) *IncidentDebriefQuestionClient {
	return &IncidentDebriefQuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentdebriefquestion.Hooks(f(g(h())))`.
func (c *IncidentDebriefQuestionClient) Use(hooks ...Hook) {
	c.hooks.IncidentDebriefQuestion = append(c.hooks.IncidentDebriefQuestion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentdebriefquestion.Intercept(f(g(h())))`.
func (c *IncidentDebriefQuestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentDebriefQuestion = append(c.inters.IncidentDebriefQuestion, interceptors...)
}

// Create returns a builder for creating a IncidentDebriefQuestion entity.
func (c *IncidentDebriefQuestionClient) Create() *IncidentDebriefQuestionCreate {
	mutation := newIncidentDebriefQuestionMutation(c.config, OpCreate)
	return &IncidentDebriefQuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentDebriefQuestion entities.
func (c *IncidentDebriefQuestionClient) CreateBulk(builders ...*IncidentDebriefQuestionCreate) *IncidentDebriefQuestionCreateBulk {
	return &IncidentDebriefQuestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentDebriefQuestionClient) MapCreateBulk(slice any, setFunc func(*IncidentDebriefQuestionCreate, int)) *IncidentDebriefQuestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentDebriefQuestionCreateBulk{err: fmt.Errorf("calling to IncidentDebriefQuestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentDebriefQuestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentDebriefQuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) Update() *IncidentDebriefQuestionUpdate {
	mutation := newIncidentDebriefQuestionMutation(c.config, OpUpdate)
	return &IncidentDebriefQuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentDebriefQuestionClient) UpdateOne(idq *IncidentDebriefQuestion) *IncidentDebriefQuestionUpdateOne {
	mutation := newIncidentDebriefQuestionMutation(c.config, OpUpdateOne, withIncidentDebriefQuestion(idq))
	return &IncidentDebriefQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentDebriefQuestionClient) UpdateOneID(id uuid.UUID) *IncidentDebriefQuestionUpdateOne {
	mutation := newIncidentDebriefQuestionMutation(c.config, OpUpdateOne, withIncidentDebriefQuestionID(id))
	return &IncidentDebriefQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) Delete() *IncidentDebriefQuestionDelete {
	mutation := newIncidentDebriefQuestionMutation(c.config, OpDelete)
	return &IncidentDebriefQuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentDebriefQuestionClient) DeleteOne(idq *IncidentDebriefQuestion) *IncidentDebriefQuestionDeleteOne {
	return c.DeleteOneID(idq.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentDebriefQuestionClient) DeleteOneID(id uuid.UUID) *IncidentDebriefQuestionDeleteOne {
	builder := c.Delete().Where(incidentdebriefquestion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentDebriefQuestionDeleteOne{builder}
}

// Query returns a query builder for IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) Query() *IncidentDebriefQuestionQuery {
	return &IncidentDebriefQuestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentDebriefQuestion},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentDebriefQuestion entity by its id.
func (c *IncidentDebriefQuestionClient) Get(ctx context.Context, id uuid.UUID) (*IncidentDebriefQuestion, error) {
	return c.Query().Where(incidentdebriefquestion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentDebriefQuestionClient) GetX(ctx context.Context, id uuid.UUID) *IncidentDebriefQuestion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMessages queries the messages edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryMessages(idq *IncidentDebriefQuestion) *IncidentDebriefMessageQuery {
	query := (&IncidentDebriefMessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidentdebriefmessage.Table, incidentdebriefmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incidentdebriefquestion.MessagesTable, incidentdebriefquestion.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentFields queries the incident_fields edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryIncidentFields(idq *IncidentDebriefQuestion) *IncidentFieldQuery {
	query := (&IncidentFieldClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidentfield.Table, incidentfield.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incidentdebriefquestion.IncidentFieldsTable, incidentdebriefquestion.IncidentFieldsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentRoles queries the incident_roles edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryIncidentRoles(idq *IncidentDebriefQuestion) *IncidentRoleQuery {
	query := (&IncidentRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidentrole.Table, incidentrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incidentdebriefquestion.IncidentRolesTable, incidentdebriefquestion.IncidentRolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentSeverities queries the incident_severities edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryIncidentSeverities(idq *IncidentDebriefQuestion) *IncidentSeverityQuery {
	query := (&IncidentSeverityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidentseverity.Table, incidentseverity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incidentdebriefquestion.IncidentSeveritiesTable, incidentdebriefquestion.IncidentSeveritiesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentTags queries the incident_tags edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryIncidentTags(idq *IncidentDebriefQuestion) *IncidentTagQuery {
	query := (&IncidentTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidenttag.Table, incidenttag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incidentdebriefquestion.IncidentTagsTable, incidentdebriefquestion.IncidentTagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentTypes queries the incident_types edge of a IncidentDebriefQuestion.
func (c *IncidentDebriefQuestionClient) QueryIncidentTypes(idq *IncidentDebriefQuestion) *IncidentTypeQuery {
	query := (&IncidentTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := idq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID, id),
			sqlgraph.To(incidenttype.Table, incidenttype.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, incidentdebriefquestion.IncidentTypesTable, incidentdebriefquestion.IncidentTypesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(idq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentDebriefQuestionClient) Hooks() []Hook {
	return c.hooks.IncidentDebriefQuestion
}

// Interceptors returns the client interceptors.
func (c *IncidentDebriefQuestionClient) Interceptors() []Interceptor {
	return c.inters.IncidentDebriefQuestion
}

func (c *IncidentDebriefQuestionClient) mutate(ctx context.Context, m *IncidentDebriefQuestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentDebriefQuestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentDebriefQuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentDebriefQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentDebriefQuestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentDebriefQuestion mutation op: %q", m.Op())
	}
}

// IncidentDebriefSuggestionClient is a client for the IncidentDebriefSuggestion schema.
type IncidentDebriefSuggestionClient struct {
	config
}

// NewIncidentDebriefSuggestionClient returns a client for the IncidentDebriefSuggestion from the given config.
func NewIncidentDebriefSuggestionClient(c config) *IncidentDebriefSuggestionClient {
	return &IncidentDebriefSuggestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentdebriefsuggestion.Hooks(f(g(h())))`.
func (c *IncidentDebriefSuggestionClient) Use(hooks ...Hook) {
	c.hooks.IncidentDebriefSuggestion = append(c.hooks.IncidentDebriefSuggestion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentdebriefsuggestion.Intercept(f(g(h())))`.
func (c *IncidentDebriefSuggestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentDebriefSuggestion = append(c.inters.IncidentDebriefSuggestion, interceptors...)
}

// Create returns a builder for creating a IncidentDebriefSuggestion entity.
func (c *IncidentDebriefSuggestionClient) Create() *IncidentDebriefSuggestionCreate {
	mutation := newIncidentDebriefSuggestionMutation(c.config, OpCreate)
	return &IncidentDebriefSuggestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentDebriefSuggestion entities.
func (c *IncidentDebriefSuggestionClient) CreateBulk(builders ...*IncidentDebriefSuggestionCreate) *IncidentDebriefSuggestionCreateBulk {
	return &IncidentDebriefSuggestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentDebriefSuggestionClient) MapCreateBulk(slice any, setFunc func(*IncidentDebriefSuggestionCreate, int)) *IncidentDebriefSuggestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentDebriefSuggestionCreateBulk{err: fmt.Errorf("calling to IncidentDebriefSuggestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentDebriefSuggestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentDebriefSuggestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentDebriefSuggestion.
func (c *IncidentDebriefSuggestionClient) Update() *IncidentDebriefSuggestionUpdate {
	mutation := newIncidentDebriefSuggestionMutation(c.config, OpUpdate)
	return &IncidentDebriefSuggestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentDebriefSuggestionClient) UpdateOne(ids *IncidentDebriefSuggestion) *IncidentDebriefSuggestionUpdateOne {
	mutation := newIncidentDebriefSuggestionMutation(c.config, OpUpdateOne, withIncidentDebriefSuggestion(ids))
	return &IncidentDebriefSuggestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentDebriefSuggestionClient) UpdateOneID(id uuid.UUID) *IncidentDebriefSuggestionUpdateOne {
	mutation := newIncidentDebriefSuggestionMutation(c.config, OpUpdateOne, withIncidentDebriefSuggestionID(id))
	return &IncidentDebriefSuggestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentDebriefSuggestion.
func (c *IncidentDebriefSuggestionClient) Delete() *IncidentDebriefSuggestionDelete {
	mutation := newIncidentDebriefSuggestionMutation(c.config, OpDelete)
	return &IncidentDebriefSuggestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentDebriefSuggestionClient) DeleteOne(ids *IncidentDebriefSuggestion) *IncidentDebriefSuggestionDeleteOne {
	return c.DeleteOneID(ids.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentDebriefSuggestionClient) DeleteOneID(id uuid.UUID) *IncidentDebriefSuggestionDeleteOne {
	builder := c.Delete().Where(incidentdebriefsuggestion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentDebriefSuggestionDeleteOne{builder}
}

// Query returns a query builder for IncidentDebriefSuggestion.
func (c *IncidentDebriefSuggestionClient) Query() *IncidentDebriefSuggestionQuery {
	return &IncidentDebriefSuggestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentDebriefSuggestion},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentDebriefSuggestion entity by its id.
func (c *IncidentDebriefSuggestionClient) Get(ctx context.Context, id uuid.UUID) (*IncidentDebriefSuggestion, error) {
	return c.Query().Where(incidentdebriefsuggestion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentDebriefSuggestionClient) GetX(ctx context.Context, id uuid.UUID) *IncidentDebriefSuggestion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDebrief queries the debrief edge of a IncidentDebriefSuggestion.
func (c *IncidentDebriefSuggestionClient) QueryDebrief(ids *IncidentDebriefSuggestion) *IncidentDebriefQuery {
	query := (&IncidentDebriefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ids.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentdebriefsuggestion.Table, incidentdebriefsuggestion.FieldID, id),
			sqlgraph.To(incidentdebrief.Table, incidentdebrief.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentdebriefsuggestion.DebriefTable, incidentdebriefsuggestion.DebriefColumn),
		)
		fromV = sqlgraph.Neighbors(ids.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentDebriefSuggestionClient) Hooks() []Hook {
	return c.hooks.IncidentDebriefSuggestion
}

// Interceptors returns the client interceptors.
func (c *IncidentDebriefSuggestionClient) Interceptors() []Interceptor {
	return c.inters.IncidentDebriefSuggestion
}

func (c *IncidentDebriefSuggestionClient) mutate(ctx context.Context, m *IncidentDebriefSuggestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentDebriefSuggestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentDebriefSuggestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentDebriefSuggestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentDebriefSuggestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentDebriefSuggestion mutation op: %q", m.Op())
	}
}

// IncidentEventClient is a client for the IncidentEvent schema.
type IncidentEventClient struct {
	config
}

// NewIncidentEventClient returns a client for the IncidentEvent from the given config.
func NewIncidentEventClient(c config) *IncidentEventClient {
	return &IncidentEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentevent.Hooks(f(g(h())))`.
func (c *IncidentEventClient) Use(hooks ...Hook) {
	c.hooks.IncidentEvent = append(c.hooks.IncidentEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentevent.Intercept(f(g(h())))`.
func (c *IncidentEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentEvent = append(c.inters.IncidentEvent, interceptors...)
}

// Create returns a builder for creating a IncidentEvent entity.
func (c *IncidentEventClient) Create() *IncidentEventCreate {
	mutation := newIncidentEventMutation(c.config, OpCreate)
	return &IncidentEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentEvent entities.
func (c *IncidentEventClient) CreateBulk(builders ...*IncidentEventCreate) *IncidentEventCreateBulk {
	return &IncidentEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentEventClient) MapCreateBulk(slice any, setFunc func(*IncidentEventCreate, int)) *IncidentEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentEventCreateBulk{err: fmt.Errorf("calling to IncidentEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentEvent.
func (c *IncidentEventClient) Update() *IncidentEventUpdate {
	mutation := newIncidentEventMutation(c.config, OpUpdate)
	return &IncidentEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentEventClient) UpdateOne(ie *IncidentEvent) *IncidentEventUpdateOne {
	mutation := newIncidentEventMutation(c.config, OpUpdateOne, withIncidentEvent(ie))
	return &IncidentEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentEventClient) UpdateOneID(id uuid.UUID) *IncidentEventUpdateOne {
	mutation := newIncidentEventMutation(c.config, OpUpdateOne, withIncidentEventID(id))
	return &IncidentEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentEvent.
func (c *IncidentEventClient) Delete() *IncidentEventDelete {
	mutation := newIncidentEventMutation(c.config, OpDelete)
	return &IncidentEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentEventClient) DeleteOne(ie *IncidentEvent) *IncidentEventDeleteOne {
	return c.DeleteOneID(ie.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentEventClient) DeleteOneID(id uuid.UUID) *IncidentEventDeleteOne {
	builder := c.Delete().Where(incidentevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentEventDeleteOne{builder}
}

// Query returns a query builder for IncidentEvent.
func (c *IncidentEventClient) Query() *IncidentEventQuery {
	return &IncidentEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentEvent entity by its id.
func (c *IncidentEventClient) Get(ctx context.Context, id uuid.UUID) (*IncidentEvent, error) {
	return c.Query().Where(incidentevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentEventClient) GetX(ctx context.Context, id uuid.UUID) *IncidentEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a IncidentEvent.
func (c *IncidentEventClient) QueryIncident(ie *IncidentEvent) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ie.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentevent.Table, incidentevent.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentevent.IncidentTable, incidentevent.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(ie.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServices queries the services edge of a IncidentEvent.
func (c *IncidentEventClient) QueryServices(ie *IncidentEvent) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ie.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentevent.Table, incidentevent.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incidentevent.ServicesTable, incidentevent.ServicesColumn),
		)
		fromV = sqlgraph.Neighbors(ie.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentEventClient) Hooks() []Hook {
	return c.hooks.IncidentEvent
}

// Interceptors returns the client interceptors.
func (c *IncidentEventClient) Interceptors() []Interceptor {
	return c.inters.IncidentEvent
}

func (c *IncidentEventClient) mutate(ctx context.Context, m *IncidentEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentEvent mutation op: %q", m.Op())
	}
}

// IncidentFieldClient is a client for the IncidentField schema.
type IncidentFieldClient struct {
	config
}

// NewIncidentFieldClient returns a client for the IncidentField from the given config.
func NewIncidentFieldClient(c config) *IncidentFieldClient {
	return &IncidentFieldClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentfield.Hooks(f(g(h())))`.
func (c *IncidentFieldClient) Use(hooks ...Hook) {
	c.hooks.IncidentField = append(c.hooks.IncidentField, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentfield.Intercept(f(g(h())))`.
func (c *IncidentFieldClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentField = append(c.inters.IncidentField, interceptors...)
}

// Create returns a builder for creating a IncidentField entity.
func (c *IncidentFieldClient) Create() *IncidentFieldCreate {
	mutation := newIncidentFieldMutation(c.config, OpCreate)
	return &IncidentFieldCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentField entities.
func (c *IncidentFieldClient) CreateBulk(builders ...*IncidentFieldCreate) *IncidentFieldCreateBulk {
	return &IncidentFieldCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentFieldClient) MapCreateBulk(slice any, setFunc func(*IncidentFieldCreate, int)) *IncidentFieldCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentFieldCreateBulk{err: fmt.Errorf("calling to IncidentFieldClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentFieldCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentFieldCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentField.
func (c *IncidentFieldClient) Update() *IncidentFieldUpdate {
	mutation := newIncidentFieldMutation(c.config, OpUpdate)
	return &IncidentFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentFieldClient) UpdateOne(_if *IncidentField) *IncidentFieldUpdateOne {
	mutation := newIncidentFieldMutation(c.config, OpUpdateOne, withIncidentField(_if))
	return &IncidentFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentFieldClient) UpdateOneID(id uuid.UUID) *IncidentFieldUpdateOne {
	mutation := newIncidentFieldMutation(c.config, OpUpdateOne, withIncidentFieldID(id))
	return &IncidentFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentField.
func (c *IncidentFieldClient) Delete() *IncidentFieldDelete {
	mutation := newIncidentFieldMutation(c.config, OpDelete)
	return &IncidentFieldDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentFieldClient) DeleteOne(_if *IncidentField) *IncidentFieldDeleteOne {
	return c.DeleteOneID(_if.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentFieldClient) DeleteOneID(id uuid.UUID) *IncidentFieldDeleteOne {
	builder := c.Delete().Where(incidentfield.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentFieldDeleteOne{builder}
}

// Query returns a query builder for IncidentField.
func (c *IncidentFieldClient) Query() *IncidentFieldQuery {
	return &IncidentFieldQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentField},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentField entity by its id.
func (c *IncidentFieldClient) Get(ctx context.Context, id uuid.UUID) (*IncidentField, error) {
	return c.Query().Where(incidentfield.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentFieldClient) GetX(ctx context.Context, id uuid.UUID) *IncidentField {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOptions queries the options edge of a IncidentField.
func (c *IncidentFieldClient) QueryOptions(_if *IncidentField) *IncidentFieldOptionQuery {
	query := (&IncidentFieldOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _if.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentfield.Table, incidentfield.FieldID, id),
			sqlgraph.To(incidentfieldoption.Table, incidentfieldoption.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incidentfield.OptionsTable, incidentfield.OptionsColumn),
		)
		fromV = sqlgraph.Neighbors(_if.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefQuestions queries the debrief_questions edge of a IncidentField.
func (c *IncidentFieldClient) QueryDebriefQuestions(_if *IncidentField) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _if.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentfield.Table, incidentfield.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidentfield.DebriefQuestionsTable, incidentfield.DebriefQuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_if.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentFieldClient) Hooks() []Hook {
	hooks := c.hooks.IncidentField
	return append(hooks[:len(hooks):len(hooks)], incidentfield.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentFieldClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentField
	return append(inters[:len(inters):len(inters)], incidentfield.Interceptors[:]...)
}

func (c *IncidentFieldClient) mutate(ctx context.Context, m *IncidentFieldMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentFieldCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentFieldDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentField mutation op: %q", m.Op())
	}
}

// IncidentFieldOptionClient is a client for the IncidentFieldOption schema.
type IncidentFieldOptionClient struct {
	config
}

// NewIncidentFieldOptionClient returns a client for the IncidentFieldOption from the given config.
func NewIncidentFieldOptionClient(c config) *IncidentFieldOptionClient {
	return &IncidentFieldOptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentfieldoption.Hooks(f(g(h())))`.
func (c *IncidentFieldOptionClient) Use(hooks ...Hook) {
	c.hooks.IncidentFieldOption = append(c.hooks.IncidentFieldOption, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentfieldoption.Intercept(f(g(h())))`.
func (c *IncidentFieldOptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentFieldOption = append(c.inters.IncidentFieldOption, interceptors...)
}

// Create returns a builder for creating a IncidentFieldOption entity.
func (c *IncidentFieldOptionClient) Create() *IncidentFieldOptionCreate {
	mutation := newIncidentFieldOptionMutation(c.config, OpCreate)
	return &IncidentFieldOptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentFieldOption entities.
func (c *IncidentFieldOptionClient) CreateBulk(builders ...*IncidentFieldOptionCreate) *IncidentFieldOptionCreateBulk {
	return &IncidentFieldOptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentFieldOptionClient) MapCreateBulk(slice any, setFunc func(*IncidentFieldOptionCreate, int)) *IncidentFieldOptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentFieldOptionCreateBulk{err: fmt.Errorf("calling to IncidentFieldOptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentFieldOptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentFieldOptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentFieldOption.
func (c *IncidentFieldOptionClient) Update() *IncidentFieldOptionUpdate {
	mutation := newIncidentFieldOptionMutation(c.config, OpUpdate)
	return &IncidentFieldOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentFieldOptionClient) UpdateOne(ifo *IncidentFieldOption) *IncidentFieldOptionUpdateOne {
	mutation := newIncidentFieldOptionMutation(c.config, OpUpdateOne, withIncidentFieldOption(ifo))
	return &IncidentFieldOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentFieldOptionClient) UpdateOneID(id uuid.UUID) *IncidentFieldOptionUpdateOne {
	mutation := newIncidentFieldOptionMutation(c.config, OpUpdateOne, withIncidentFieldOptionID(id))
	return &IncidentFieldOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentFieldOption.
func (c *IncidentFieldOptionClient) Delete() *IncidentFieldOptionDelete {
	mutation := newIncidentFieldOptionMutation(c.config, OpDelete)
	return &IncidentFieldOptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentFieldOptionClient) DeleteOne(ifo *IncidentFieldOption) *IncidentFieldOptionDeleteOne {
	return c.DeleteOneID(ifo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentFieldOptionClient) DeleteOneID(id uuid.UUID) *IncidentFieldOptionDeleteOne {
	builder := c.Delete().Where(incidentfieldoption.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentFieldOptionDeleteOne{builder}
}

// Query returns a query builder for IncidentFieldOption.
func (c *IncidentFieldOptionClient) Query() *IncidentFieldOptionQuery {
	return &IncidentFieldOptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentFieldOption},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentFieldOption entity by its id.
func (c *IncidentFieldOptionClient) Get(ctx context.Context, id uuid.UUID) (*IncidentFieldOption, error) {
	return c.Query().Where(incidentfieldoption.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentFieldOptionClient) GetX(ctx context.Context, id uuid.UUID) *IncidentFieldOption {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidentField queries the incident_field edge of a IncidentFieldOption.
func (c *IncidentFieldOptionClient) QueryIncidentField(ifo *IncidentFieldOption) *IncidentFieldQuery {
	query := (&IncidentFieldClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ifo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentfieldoption.Table, incidentfieldoption.FieldID, id),
			sqlgraph.To(incidentfield.Table, incidentfield.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentfieldoption.IncidentFieldTable, incidentfieldoption.IncidentFieldColumn),
		)
		fromV = sqlgraph.Neighbors(ifo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidents queries the incidents edge of a IncidentFieldOption.
func (c *IncidentFieldOptionClient) QueryIncidents(ifo *IncidentFieldOption) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ifo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentfieldoption.Table, incidentfieldoption.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidentfieldoption.IncidentsTable, incidentfieldoption.IncidentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ifo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentFieldOptionClient) Hooks() []Hook {
	hooks := c.hooks.IncidentFieldOption
	return append(hooks[:len(hooks):len(hooks)], incidentfieldoption.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentFieldOptionClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentFieldOption
	return append(inters[:len(inters):len(inters)], incidentfieldoption.Interceptors[:]...)
}

func (c *IncidentFieldOptionClient) mutate(ctx context.Context, m *IncidentFieldOptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentFieldOptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentFieldOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentFieldOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentFieldOptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentFieldOption mutation op: %q", m.Op())
	}
}

// IncidentLinkClient is a client for the IncidentLink schema.
type IncidentLinkClient struct {
	config
}

// NewIncidentLinkClient returns a client for the IncidentLink from the given config.
func NewIncidentLinkClient(c config) *IncidentLinkClient {
	return &IncidentLinkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentlink.Hooks(f(g(h())))`.
func (c *IncidentLinkClient) Use(hooks ...Hook) {
	c.hooks.IncidentLink = append(c.hooks.IncidentLink, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentlink.Intercept(f(g(h())))`.
func (c *IncidentLinkClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentLink = append(c.inters.IncidentLink, interceptors...)
}

// Create returns a builder for creating a IncidentLink entity.
func (c *IncidentLinkClient) Create() *IncidentLinkCreate {
	mutation := newIncidentLinkMutation(c.config, OpCreate)
	return &IncidentLinkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentLink entities.
func (c *IncidentLinkClient) CreateBulk(builders ...*IncidentLinkCreate) *IncidentLinkCreateBulk {
	return &IncidentLinkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentLinkClient) MapCreateBulk(slice any, setFunc func(*IncidentLinkCreate, int)) *IncidentLinkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentLinkCreateBulk{err: fmt.Errorf("calling to IncidentLinkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentLinkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentLinkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentLink.
func (c *IncidentLinkClient) Update() *IncidentLinkUpdate {
	mutation := newIncidentLinkMutation(c.config, OpUpdate)
	return &IncidentLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentLinkClient) UpdateOne(il *IncidentLink) *IncidentLinkUpdateOne {
	mutation := newIncidentLinkMutation(c.config, OpUpdateOne, withIncidentLink(il))
	return &IncidentLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentLinkClient) UpdateOneID(id int) *IncidentLinkUpdateOne {
	mutation := newIncidentLinkMutation(c.config, OpUpdateOne, withIncidentLinkID(id))
	return &IncidentLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentLink.
func (c *IncidentLinkClient) Delete() *IncidentLinkDelete {
	mutation := newIncidentLinkMutation(c.config, OpDelete)
	return &IncidentLinkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentLinkClient) DeleteOne(il *IncidentLink) *IncidentLinkDeleteOne {
	return c.DeleteOneID(il.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentLinkClient) DeleteOneID(id int) *IncidentLinkDeleteOne {
	builder := c.Delete().Where(incidentlink.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentLinkDeleteOne{builder}
}

// Query returns a query builder for IncidentLink.
func (c *IncidentLinkClient) Query() *IncidentLinkQuery {
	return &IncidentLinkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentLink},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentLink entity by its id.
func (c *IncidentLinkClient) Get(ctx context.Context, id int) (*IncidentLink, error) {
	return c.Query().Where(incidentlink.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentLinkClient) GetX(ctx context.Context, id int) *IncidentLink {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a IncidentLink.
func (c *IncidentLinkClient) QueryIncident(il *IncidentLink) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := il.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentlink.Table, incidentlink.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentlink.IncidentTable, incidentlink.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(il.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLinkedIncident queries the linked_incident edge of a IncidentLink.
func (c *IncidentLinkClient) QueryLinkedIncident(il *IncidentLink) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := il.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentlink.Table, incidentlink.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentlink.LinkedIncidentTable, incidentlink.LinkedIncidentColumn),
		)
		fromV = sqlgraph.Neighbors(il.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResourceImpact queries the resource_impact edge of a IncidentLink.
func (c *IncidentLinkClient) QueryResourceImpact(il *IncidentLink) *IncidentResourceImpactQuery {
	query := (&IncidentResourceImpactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := il.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentlink.Table, incidentlink.FieldID, id),
			sqlgraph.To(incidentresourceimpact.Table, incidentresourceimpact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentlink.ResourceImpactTable, incidentlink.ResourceImpactColumn),
		)
		fromV = sqlgraph.Neighbors(il.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentLinkClient) Hooks() []Hook {
	return c.hooks.IncidentLink
}

// Interceptors returns the client interceptors.
func (c *IncidentLinkClient) Interceptors() []Interceptor {
	return c.inters.IncidentLink
}

func (c *IncidentLinkClient) mutate(ctx context.Context, m *IncidentLinkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentLinkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentLinkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentLink mutation op: %q", m.Op())
	}
}

// IncidentResourceImpactClient is a client for the IncidentResourceImpact schema.
type IncidentResourceImpactClient struct {
	config
}

// NewIncidentResourceImpactClient returns a client for the IncidentResourceImpact from the given config.
func NewIncidentResourceImpactClient(c config) *IncidentResourceImpactClient {
	return &IncidentResourceImpactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentresourceimpact.Hooks(f(g(h())))`.
func (c *IncidentResourceImpactClient) Use(hooks ...Hook) {
	c.hooks.IncidentResourceImpact = append(c.hooks.IncidentResourceImpact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentresourceimpact.Intercept(f(g(h())))`.
func (c *IncidentResourceImpactClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentResourceImpact = append(c.inters.IncidentResourceImpact, interceptors...)
}

// Create returns a builder for creating a IncidentResourceImpact entity.
func (c *IncidentResourceImpactClient) Create() *IncidentResourceImpactCreate {
	mutation := newIncidentResourceImpactMutation(c.config, OpCreate)
	return &IncidentResourceImpactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentResourceImpact entities.
func (c *IncidentResourceImpactClient) CreateBulk(builders ...*IncidentResourceImpactCreate) *IncidentResourceImpactCreateBulk {
	return &IncidentResourceImpactCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentResourceImpactClient) MapCreateBulk(slice any, setFunc func(*IncidentResourceImpactCreate, int)) *IncidentResourceImpactCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentResourceImpactCreateBulk{err: fmt.Errorf("calling to IncidentResourceImpactClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentResourceImpactCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentResourceImpactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentResourceImpact.
func (c *IncidentResourceImpactClient) Update() *IncidentResourceImpactUpdate {
	mutation := newIncidentResourceImpactMutation(c.config, OpUpdate)
	return &IncidentResourceImpactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentResourceImpactClient) UpdateOne(iri *IncidentResourceImpact) *IncidentResourceImpactUpdateOne {
	mutation := newIncidentResourceImpactMutation(c.config, OpUpdateOne, withIncidentResourceImpact(iri))
	return &IncidentResourceImpactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentResourceImpactClient) UpdateOneID(id uuid.UUID) *IncidentResourceImpactUpdateOne {
	mutation := newIncidentResourceImpactMutation(c.config, OpUpdateOne, withIncidentResourceImpactID(id))
	return &IncidentResourceImpactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentResourceImpact.
func (c *IncidentResourceImpactClient) Delete() *IncidentResourceImpactDelete {
	mutation := newIncidentResourceImpactMutation(c.config, OpDelete)
	return &IncidentResourceImpactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentResourceImpactClient) DeleteOne(iri *IncidentResourceImpact) *IncidentResourceImpactDeleteOne {
	return c.DeleteOneID(iri.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentResourceImpactClient) DeleteOneID(id uuid.UUID) *IncidentResourceImpactDeleteOne {
	builder := c.Delete().Where(incidentresourceimpact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentResourceImpactDeleteOne{builder}
}

// Query returns a query builder for IncidentResourceImpact.
func (c *IncidentResourceImpactClient) Query() *IncidentResourceImpactQuery {
	return &IncidentResourceImpactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentResourceImpact},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentResourceImpact entity by its id.
func (c *IncidentResourceImpactClient) Get(ctx context.Context, id uuid.UUID) (*IncidentResourceImpact, error) {
	return c.Query().Where(incidentresourceimpact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentResourceImpactClient) GetX(ctx context.Context, id uuid.UUID) *IncidentResourceImpact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a IncidentResourceImpact.
func (c *IncidentResourceImpactClient) QueryIncident(iri *IncidentResourceImpact) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iri.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentresourceimpact.Table, incidentresourceimpact.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentresourceimpact.IncidentTable, incidentresourceimpact.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(iri.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryService queries the service edge of a IncidentResourceImpact.
func (c *IncidentResourceImpactClient) QueryService(iri *IncidentResourceImpact) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iri.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentresourceimpact.Table, incidentresourceimpact.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentresourceimpact.ServiceTable, incidentresourceimpact.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(iri.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFunctionality queries the functionality edge of a IncidentResourceImpact.
func (c *IncidentResourceImpactClient) QueryFunctionality(iri *IncidentResourceImpact) *FunctionalityQuery {
	query := (&FunctionalityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iri.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentresourceimpact.Table, incidentresourceimpact.FieldID, id),
			sqlgraph.To(functionality.Table, functionality.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentresourceimpact.FunctionalityTable, incidentresourceimpact.FunctionalityColumn),
		)
		fromV = sqlgraph.Neighbors(iri.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResultingIncidents queries the resulting_incidents edge of a IncidentResourceImpact.
func (c *IncidentResourceImpactClient) QueryResultingIncidents(iri *IncidentResourceImpact) *IncidentLinkQuery {
	query := (&IncidentLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iri.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentresourceimpact.Table, incidentresourceimpact.FieldID, id),
			sqlgraph.To(incidentlink.Table, incidentlink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incidentresourceimpact.ResultingIncidentsTable, incidentresourceimpact.ResultingIncidentsColumn),
		)
		fromV = sqlgraph.Neighbors(iri.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentResourceImpactClient) Hooks() []Hook {
	return c.hooks.IncidentResourceImpact
}

// Interceptors returns the client interceptors.
func (c *IncidentResourceImpactClient) Interceptors() []Interceptor {
	return c.inters.IncidentResourceImpact
}

func (c *IncidentResourceImpactClient) mutate(ctx context.Context, m *IncidentResourceImpactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentResourceImpactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentResourceImpactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentResourceImpactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentResourceImpactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentResourceImpact mutation op: %q", m.Op())
	}
}

// IncidentRoleClient is a client for the IncidentRole schema.
type IncidentRoleClient struct {
	config
}

// NewIncidentRoleClient returns a client for the IncidentRole from the given config.
func NewIncidentRoleClient(c config) *IncidentRoleClient {
	return &IncidentRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentrole.Hooks(f(g(h())))`.
func (c *IncidentRoleClient) Use(hooks ...Hook) {
	c.hooks.IncidentRole = append(c.hooks.IncidentRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentrole.Intercept(f(g(h())))`.
func (c *IncidentRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentRole = append(c.inters.IncidentRole, interceptors...)
}

// Create returns a builder for creating a IncidentRole entity.
func (c *IncidentRoleClient) Create() *IncidentRoleCreate {
	mutation := newIncidentRoleMutation(c.config, OpCreate)
	return &IncidentRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentRole entities.
func (c *IncidentRoleClient) CreateBulk(builders ...*IncidentRoleCreate) *IncidentRoleCreateBulk {
	return &IncidentRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentRoleClient) MapCreateBulk(slice any, setFunc func(*IncidentRoleCreate, int)) *IncidentRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentRoleCreateBulk{err: fmt.Errorf("calling to IncidentRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentRole.
func (c *IncidentRoleClient) Update() *IncidentRoleUpdate {
	mutation := newIncidentRoleMutation(c.config, OpUpdate)
	return &IncidentRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentRoleClient) UpdateOne(ir *IncidentRole) *IncidentRoleUpdateOne {
	mutation := newIncidentRoleMutation(c.config, OpUpdateOne, withIncidentRole(ir))
	return &IncidentRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentRoleClient) UpdateOneID(id uuid.UUID) *IncidentRoleUpdateOne {
	mutation := newIncidentRoleMutation(c.config, OpUpdateOne, withIncidentRoleID(id))
	return &IncidentRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentRole.
func (c *IncidentRoleClient) Delete() *IncidentRoleDelete {
	mutation := newIncidentRoleMutation(c.config, OpDelete)
	return &IncidentRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentRoleClient) DeleteOne(ir *IncidentRole) *IncidentRoleDeleteOne {
	return c.DeleteOneID(ir.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentRoleClient) DeleteOneID(id uuid.UUID) *IncidentRoleDeleteOne {
	builder := c.Delete().Where(incidentrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentRoleDeleteOne{builder}
}

// Query returns a query builder for IncidentRole.
func (c *IncidentRoleClient) Query() *IncidentRoleQuery {
	return &IncidentRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentRole},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentRole entity by its id.
func (c *IncidentRoleClient) Get(ctx context.Context, id uuid.UUID) (*IncidentRole, error) {
	return c.Query().Where(incidentrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentRoleClient) GetX(ctx context.Context, id uuid.UUID) *IncidentRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAssignments queries the assignments edge of a IncidentRole.
func (c *IncidentRoleClient) QueryAssignments(ir *IncidentRole) *IncidentRoleAssignmentQuery {
	query := (&IncidentRoleAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ir.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentrole.Table, incidentrole.FieldID, id),
			sqlgraph.To(incidentroleassignment.Table, incidentroleassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incidentrole.AssignmentsTable, incidentrole.AssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(ir.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefQuestions queries the debrief_questions edge of a IncidentRole.
func (c *IncidentRoleClient) QueryDebriefQuestions(ir *IncidentRole) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ir.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentrole.Table, incidentrole.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidentrole.DebriefQuestionsTable, incidentrole.DebriefQuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ir.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentRoleClient) Hooks() []Hook {
	hooks := c.hooks.IncidentRole
	return append(hooks[:len(hooks):len(hooks)], incidentrole.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentRoleClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentRole
	return append(inters[:len(inters):len(inters)], incidentrole.Interceptors[:]...)
}

func (c *IncidentRoleClient) mutate(ctx context.Context, m *IncidentRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentRole mutation op: %q", m.Op())
	}
}

// IncidentRoleAssignmentClient is a client for the IncidentRoleAssignment schema.
type IncidentRoleAssignmentClient struct {
	config
}

// NewIncidentRoleAssignmentClient returns a client for the IncidentRoleAssignment from the given config.
func NewIncidentRoleAssignmentClient(c config) *IncidentRoleAssignmentClient {
	return &IncidentRoleAssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentroleassignment.Hooks(f(g(h())))`.
func (c *IncidentRoleAssignmentClient) Use(hooks ...Hook) {
	c.hooks.IncidentRoleAssignment = append(c.hooks.IncidentRoleAssignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentroleassignment.Intercept(f(g(h())))`.
func (c *IncidentRoleAssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentRoleAssignment = append(c.inters.IncidentRoleAssignment, interceptors...)
}

// Create returns a builder for creating a IncidentRoleAssignment entity.
func (c *IncidentRoleAssignmentClient) Create() *IncidentRoleAssignmentCreate {
	mutation := newIncidentRoleAssignmentMutation(c.config, OpCreate)
	return &IncidentRoleAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentRoleAssignment entities.
func (c *IncidentRoleAssignmentClient) CreateBulk(builders ...*IncidentRoleAssignmentCreate) *IncidentRoleAssignmentCreateBulk {
	return &IncidentRoleAssignmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentRoleAssignmentClient) MapCreateBulk(slice any, setFunc func(*IncidentRoleAssignmentCreate, int)) *IncidentRoleAssignmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentRoleAssignmentCreateBulk{err: fmt.Errorf("calling to IncidentRoleAssignmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentRoleAssignmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentRoleAssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) Update() *IncidentRoleAssignmentUpdate {
	mutation := newIncidentRoleAssignmentMutation(c.config, OpUpdate)
	return &IncidentRoleAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentRoleAssignmentClient) UpdateOne(ira *IncidentRoleAssignment) *IncidentRoleAssignmentUpdateOne {
	mutation := newIncidentRoleAssignmentMutation(c.config, OpUpdateOne, withIncidentRoleAssignment(ira))
	return &IncidentRoleAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentRoleAssignmentClient) UpdateOneID(id uuid.UUID) *IncidentRoleAssignmentUpdateOne {
	mutation := newIncidentRoleAssignmentMutation(c.config, OpUpdateOne, withIncidentRoleAssignmentID(id))
	return &IncidentRoleAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) Delete() *IncidentRoleAssignmentDelete {
	mutation := newIncidentRoleAssignmentMutation(c.config, OpDelete)
	return &IncidentRoleAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentRoleAssignmentClient) DeleteOne(ira *IncidentRoleAssignment) *IncidentRoleAssignmentDeleteOne {
	return c.DeleteOneID(ira.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentRoleAssignmentClient) DeleteOneID(id uuid.UUID) *IncidentRoleAssignmentDeleteOne {
	builder := c.Delete().Where(incidentroleassignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentRoleAssignmentDeleteOne{builder}
}

// Query returns a query builder for IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) Query() *IncidentRoleAssignmentQuery {
	return &IncidentRoleAssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentRoleAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentRoleAssignment entity by its id.
func (c *IncidentRoleAssignmentClient) Get(ctx context.Context, id uuid.UUID) (*IncidentRoleAssignment, error) {
	return c.Query().Where(incidentroleassignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentRoleAssignmentClient) GetX(ctx context.Context, id uuid.UUID) *IncidentRoleAssignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRole queries the role edge of a IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) QueryRole(ira *IncidentRoleAssignment) *IncidentRoleQuery {
	query := (&IncidentRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ira.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentroleassignment.Table, incidentroleassignment.FieldID, id),
			sqlgraph.To(incidentrole.Table, incidentrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentroleassignment.RoleTable, incidentroleassignment.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(ira.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncident queries the incident edge of a IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) QueryIncident(ira *IncidentRoleAssignment) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ira.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentroleassignment.Table, incidentroleassignment.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentroleassignment.IncidentTable, incidentroleassignment.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(ira.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a IncidentRoleAssignment.
func (c *IncidentRoleAssignmentClient) QueryUser(ira *IncidentRoleAssignment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ira.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentroleassignment.Table, incidentroleassignment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentroleassignment.UserTable, incidentroleassignment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ira.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentRoleAssignmentClient) Hooks() []Hook {
	return c.hooks.IncidentRoleAssignment
}

// Interceptors returns the client interceptors.
func (c *IncidentRoleAssignmentClient) Interceptors() []Interceptor {
	return c.inters.IncidentRoleAssignment
}

func (c *IncidentRoleAssignmentClient) mutate(ctx context.Context, m *IncidentRoleAssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentRoleAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentRoleAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentRoleAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentRoleAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentRoleAssignment mutation op: %q", m.Op())
	}
}

// IncidentSeverityClient is a client for the IncidentSeverity schema.
type IncidentSeverityClient struct {
	config
}

// NewIncidentSeverityClient returns a client for the IncidentSeverity from the given config.
func NewIncidentSeverityClient(c config) *IncidentSeverityClient {
	return &IncidentSeverityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentseverity.Hooks(f(g(h())))`.
func (c *IncidentSeverityClient) Use(hooks ...Hook) {
	c.hooks.IncidentSeverity = append(c.hooks.IncidentSeverity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentseverity.Intercept(f(g(h())))`.
func (c *IncidentSeverityClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentSeverity = append(c.inters.IncidentSeverity, interceptors...)
}

// Create returns a builder for creating a IncidentSeverity entity.
func (c *IncidentSeverityClient) Create() *IncidentSeverityCreate {
	mutation := newIncidentSeverityMutation(c.config, OpCreate)
	return &IncidentSeverityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentSeverity entities.
func (c *IncidentSeverityClient) CreateBulk(builders ...*IncidentSeverityCreate) *IncidentSeverityCreateBulk {
	return &IncidentSeverityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentSeverityClient) MapCreateBulk(slice any, setFunc func(*IncidentSeverityCreate, int)) *IncidentSeverityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentSeverityCreateBulk{err: fmt.Errorf("calling to IncidentSeverityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentSeverityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentSeverityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentSeverity.
func (c *IncidentSeverityClient) Update() *IncidentSeverityUpdate {
	mutation := newIncidentSeverityMutation(c.config, OpUpdate)
	return &IncidentSeverityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentSeverityClient) UpdateOne(is *IncidentSeverity) *IncidentSeverityUpdateOne {
	mutation := newIncidentSeverityMutation(c.config, OpUpdateOne, withIncidentSeverity(is))
	return &IncidentSeverityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentSeverityClient) UpdateOneID(id uuid.UUID) *IncidentSeverityUpdateOne {
	mutation := newIncidentSeverityMutation(c.config, OpUpdateOne, withIncidentSeverityID(id))
	return &IncidentSeverityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentSeverity.
func (c *IncidentSeverityClient) Delete() *IncidentSeverityDelete {
	mutation := newIncidentSeverityMutation(c.config, OpDelete)
	return &IncidentSeverityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentSeverityClient) DeleteOne(is *IncidentSeverity) *IncidentSeverityDeleteOne {
	return c.DeleteOneID(is.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentSeverityClient) DeleteOneID(id uuid.UUID) *IncidentSeverityDeleteOne {
	builder := c.Delete().Where(incidentseverity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentSeverityDeleteOne{builder}
}

// Query returns a query builder for IncidentSeverity.
func (c *IncidentSeverityClient) Query() *IncidentSeverityQuery {
	return &IncidentSeverityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentSeverity},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentSeverity entity by its id.
func (c *IncidentSeverityClient) Get(ctx context.Context, id uuid.UUID) (*IncidentSeverity, error) {
	return c.Query().Where(incidentseverity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentSeverityClient) GetX(ctx context.Context, id uuid.UUID) *IncidentSeverity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a IncidentSeverity.
func (c *IncidentSeverityClient) QueryIncidents(is *IncidentSeverity) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := is.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentseverity.Table, incidentseverity.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incidentseverity.IncidentsTable, incidentseverity.IncidentsColumn),
		)
		fromV = sqlgraph.Neighbors(is.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefQuestions queries the debrief_questions edge of a IncidentSeverity.
func (c *IncidentSeverityClient) QueryDebriefQuestions(is *IncidentSeverity) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := is.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentseverity.Table, incidentseverity.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidentseverity.DebriefQuestionsTable, incidentseverity.DebriefQuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(is.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentSeverityClient) Hooks() []Hook {
	hooks := c.hooks.IncidentSeverity
	return append(hooks[:len(hooks):len(hooks)], incidentseverity.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentSeverityClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentSeverity
	return append(inters[:len(inters):len(inters)], incidentseverity.Interceptors[:]...)
}

func (c *IncidentSeverityClient) mutate(ctx context.Context, m *IncidentSeverityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentSeverityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentSeverityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentSeverityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentSeverityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentSeverity mutation op: %q", m.Op())
	}
}

// IncidentTagClient is a client for the IncidentTag schema.
type IncidentTagClient struct {
	config
}

// NewIncidentTagClient returns a client for the IncidentTag from the given config.
func NewIncidentTagClient(c config) *IncidentTagClient {
	return &IncidentTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidenttag.Hooks(f(g(h())))`.
func (c *IncidentTagClient) Use(hooks ...Hook) {
	c.hooks.IncidentTag = append(c.hooks.IncidentTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidenttag.Intercept(f(g(h())))`.
func (c *IncidentTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentTag = append(c.inters.IncidentTag, interceptors...)
}

// Create returns a builder for creating a IncidentTag entity.
func (c *IncidentTagClient) Create() *IncidentTagCreate {
	mutation := newIncidentTagMutation(c.config, OpCreate)
	return &IncidentTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentTag entities.
func (c *IncidentTagClient) CreateBulk(builders ...*IncidentTagCreate) *IncidentTagCreateBulk {
	return &IncidentTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentTagClient) MapCreateBulk(slice any, setFunc func(*IncidentTagCreate, int)) *IncidentTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentTagCreateBulk{err: fmt.Errorf("calling to IncidentTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentTag.
func (c *IncidentTagClient) Update() *IncidentTagUpdate {
	mutation := newIncidentTagMutation(c.config, OpUpdate)
	return &IncidentTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentTagClient) UpdateOne(it *IncidentTag) *IncidentTagUpdateOne {
	mutation := newIncidentTagMutation(c.config, OpUpdateOne, withIncidentTag(it))
	return &IncidentTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentTagClient) UpdateOneID(id uuid.UUID) *IncidentTagUpdateOne {
	mutation := newIncidentTagMutation(c.config, OpUpdateOne, withIncidentTagID(id))
	return &IncidentTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentTag.
func (c *IncidentTagClient) Delete() *IncidentTagDelete {
	mutation := newIncidentTagMutation(c.config, OpDelete)
	return &IncidentTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentTagClient) DeleteOne(it *IncidentTag) *IncidentTagDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentTagClient) DeleteOneID(id uuid.UUID) *IncidentTagDeleteOne {
	builder := c.Delete().Where(incidenttag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentTagDeleteOne{builder}
}

// Query returns a query builder for IncidentTag.
func (c *IncidentTagClient) Query() *IncidentTagQuery {
	return &IncidentTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentTag},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentTag entity by its id.
func (c *IncidentTagClient) Get(ctx context.Context, id uuid.UUID) (*IncidentTag, error) {
	return c.Query().Where(incidenttag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentTagClient) GetX(ctx context.Context, id uuid.UUID) *IncidentTag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a IncidentTag.
func (c *IncidentTagClient) QueryIncidents(it *IncidentTag) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenttag.Table, incidenttag.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidenttag.IncidentsTable, incidenttag.IncidentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefQuestions queries the debrief_questions edge of a IncidentTag.
func (c *IncidentTagClient) QueryDebriefQuestions(it *IncidentTag) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenttag.Table, incidenttag.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidenttag.DebriefQuestionsTable, incidenttag.DebriefQuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentTagClient) Hooks() []Hook {
	hooks := c.hooks.IncidentTag
	return append(hooks[:len(hooks):len(hooks)], incidenttag.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentTagClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentTag
	return append(inters[:len(inters):len(inters)], incidenttag.Interceptors[:]...)
}

func (c *IncidentTagClient) mutate(ctx context.Context, m *IncidentTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentTag mutation op: %q", m.Op())
	}
}

// IncidentTeamAssignmentClient is a client for the IncidentTeamAssignment schema.
type IncidentTeamAssignmentClient struct {
	config
}

// NewIncidentTeamAssignmentClient returns a client for the IncidentTeamAssignment from the given config.
func NewIncidentTeamAssignmentClient(c config) *IncidentTeamAssignmentClient {
	return &IncidentTeamAssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentteamassignment.Hooks(f(g(h())))`.
func (c *IncidentTeamAssignmentClient) Use(hooks ...Hook) {
	c.hooks.IncidentTeamAssignment = append(c.hooks.IncidentTeamAssignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentteamassignment.Intercept(f(g(h())))`.
func (c *IncidentTeamAssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentTeamAssignment = append(c.inters.IncidentTeamAssignment, interceptors...)
}

// Create returns a builder for creating a IncidentTeamAssignment entity.
func (c *IncidentTeamAssignmentClient) Create() *IncidentTeamAssignmentCreate {
	mutation := newIncidentTeamAssignmentMutation(c.config, OpCreate)
	return &IncidentTeamAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentTeamAssignment entities.
func (c *IncidentTeamAssignmentClient) CreateBulk(builders ...*IncidentTeamAssignmentCreate) *IncidentTeamAssignmentCreateBulk {
	return &IncidentTeamAssignmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentTeamAssignmentClient) MapCreateBulk(slice any, setFunc func(*IncidentTeamAssignmentCreate, int)) *IncidentTeamAssignmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentTeamAssignmentCreateBulk{err: fmt.Errorf("calling to IncidentTeamAssignmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentTeamAssignmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentTeamAssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentTeamAssignment.
func (c *IncidentTeamAssignmentClient) Update() *IncidentTeamAssignmentUpdate {
	mutation := newIncidentTeamAssignmentMutation(c.config, OpUpdate)
	return &IncidentTeamAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentTeamAssignmentClient) UpdateOne(ita *IncidentTeamAssignment) *IncidentTeamAssignmentUpdateOne {
	mutation := newIncidentTeamAssignmentMutation(c.config, OpUpdateOne, withIncidentTeamAssignment(ita))
	return &IncidentTeamAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentTeamAssignmentClient) UpdateOneID(id int) *IncidentTeamAssignmentUpdateOne {
	mutation := newIncidentTeamAssignmentMutation(c.config, OpUpdateOne, withIncidentTeamAssignmentID(id))
	return &IncidentTeamAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentTeamAssignment.
func (c *IncidentTeamAssignmentClient) Delete() *IncidentTeamAssignmentDelete {
	mutation := newIncidentTeamAssignmentMutation(c.config, OpDelete)
	return &IncidentTeamAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentTeamAssignmentClient) DeleteOne(ita *IncidentTeamAssignment) *IncidentTeamAssignmentDeleteOne {
	return c.DeleteOneID(ita.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentTeamAssignmentClient) DeleteOneID(id int) *IncidentTeamAssignmentDeleteOne {
	builder := c.Delete().Where(incidentteamassignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentTeamAssignmentDeleteOne{builder}
}

// Query returns a query builder for IncidentTeamAssignment.
func (c *IncidentTeamAssignmentClient) Query() *IncidentTeamAssignmentQuery {
	return &IncidentTeamAssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentTeamAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentTeamAssignment entity by its id.
func (c *IncidentTeamAssignmentClient) Get(ctx context.Context, id int) (*IncidentTeamAssignment, error) {
	return c.Query().Where(incidentteamassignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentTeamAssignmentClient) GetX(ctx context.Context, id int) *IncidentTeamAssignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a IncidentTeamAssignment.
func (c *IncidentTeamAssignmentClient) QueryIncident(ita *IncidentTeamAssignment) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ita.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentteamassignment.Table, incidentteamassignment.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentteamassignment.IncidentTable, incidentteamassignment.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(ita.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a IncidentTeamAssignment.
func (c *IncidentTeamAssignmentClient) QueryTeam(ita *IncidentTeamAssignment) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ita.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentteamassignment.Table, incidentteamassignment.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, incidentteamassignment.TeamTable, incidentteamassignment.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(ita.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentTeamAssignmentClient) Hooks() []Hook {
	return c.hooks.IncidentTeamAssignment
}

// Interceptors returns the client interceptors.
func (c *IncidentTeamAssignmentClient) Interceptors() []Interceptor {
	return c.inters.IncidentTeamAssignment
}

func (c *IncidentTeamAssignmentClient) mutate(ctx context.Context, m *IncidentTeamAssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentTeamAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentTeamAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentTeamAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentTeamAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentTeamAssignment mutation op: %q", m.Op())
	}
}

// IncidentTypeClient is a client for the IncidentType schema.
type IncidentTypeClient struct {
	config
}

// NewIncidentTypeClient returns a client for the IncidentType from the given config.
func NewIncidentTypeClient(c config) *IncidentTypeClient {
	return &IncidentTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidenttype.Hooks(f(g(h())))`.
func (c *IncidentTypeClient) Use(hooks ...Hook) {
	c.hooks.IncidentType = append(c.hooks.IncidentType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidenttype.Intercept(f(g(h())))`.
func (c *IncidentTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentType = append(c.inters.IncidentType, interceptors...)
}

// Create returns a builder for creating a IncidentType entity.
func (c *IncidentTypeClient) Create() *IncidentTypeCreate {
	mutation := newIncidentTypeMutation(c.config, OpCreate)
	return &IncidentTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentType entities.
func (c *IncidentTypeClient) CreateBulk(builders ...*IncidentTypeCreate) *IncidentTypeCreateBulk {
	return &IncidentTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentTypeClient) MapCreateBulk(slice any, setFunc func(*IncidentTypeCreate, int)) *IncidentTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentTypeCreateBulk{err: fmt.Errorf("calling to IncidentTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentType.
func (c *IncidentTypeClient) Update() *IncidentTypeUpdate {
	mutation := newIncidentTypeMutation(c.config, OpUpdate)
	return &IncidentTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentTypeClient) UpdateOne(it *IncidentType) *IncidentTypeUpdateOne {
	mutation := newIncidentTypeMutation(c.config, OpUpdateOne, withIncidentType(it))
	return &IncidentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentTypeClient) UpdateOneID(id uuid.UUID) *IncidentTypeUpdateOne {
	mutation := newIncidentTypeMutation(c.config, OpUpdateOne, withIncidentTypeID(id))
	return &IncidentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentType.
func (c *IncidentTypeClient) Delete() *IncidentTypeDelete {
	mutation := newIncidentTypeMutation(c.config, OpDelete)
	return &IncidentTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentTypeClient) DeleteOne(it *IncidentType) *IncidentTypeDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentTypeClient) DeleteOneID(id uuid.UUID) *IncidentTypeDeleteOne {
	builder := c.Delete().Where(incidenttype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentTypeDeleteOne{builder}
}

// Query returns a query builder for IncidentType.
func (c *IncidentTypeClient) Query() *IncidentTypeQuery {
	return &IncidentTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentType},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentType entity by its id.
func (c *IncidentTypeClient) Get(ctx context.Context, id uuid.UUID) (*IncidentType, error) {
	return c.Query().Where(incidenttype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentTypeClient) GetX(ctx context.Context, id uuid.UUID) *IncidentType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a IncidentType.
func (c *IncidentTypeClient) QueryIncidents(it *IncidentType) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenttype.Table, incidenttype.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, incidenttype.IncidentsTable, incidenttype.IncidentsColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDebriefQuestions queries the debrief_questions edge of a IncidentType.
func (c *IncidentTypeClient) QueryDebriefQuestions(it *IncidentType) *IncidentDebriefQuestionQuery {
	query := (&IncidentDebriefQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidenttype.Table, incidenttype.FieldID, id),
			sqlgraph.To(incidentdebriefquestion.Table, incidentdebriefquestion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, incidenttype.DebriefQuestionsTable, incidenttype.DebriefQuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentTypeClient) Hooks() []Hook {
	hooks := c.hooks.IncidentType
	return append(hooks[:len(hooks):len(hooks)], incidenttype.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IncidentTypeClient) Interceptors() []Interceptor {
	inters := c.inters.IncidentType
	return append(inters[:len(inters):len(inters)], incidenttype.Interceptors[:]...)
}

func (c *IncidentTypeClient) mutate(ctx context.Context, m *IncidentTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentType mutation op: %q", m.Op())
	}
}

// MeetingScheduleClient is a client for the MeetingSchedule schema.
type MeetingScheduleClient struct {
	config
}

// NewMeetingScheduleClient returns a client for the MeetingSchedule from the given config.
func NewMeetingScheduleClient(c config) *MeetingScheduleClient {
	return &MeetingScheduleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `meetingschedule.Hooks(f(g(h())))`.
func (c *MeetingScheduleClient) Use(hooks ...Hook) {
	c.hooks.MeetingSchedule = append(c.hooks.MeetingSchedule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `meetingschedule.Intercept(f(g(h())))`.
func (c *MeetingScheduleClient) Intercept(interceptors ...Interceptor) {
	c.inters.MeetingSchedule = append(c.inters.MeetingSchedule, interceptors...)
}

// Create returns a builder for creating a MeetingSchedule entity.
func (c *MeetingScheduleClient) Create() *MeetingScheduleCreate {
	mutation := newMeetingScheduleMutation(c.config, OpCreate)
	return &MeetingScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MeetingSchedule entities.
func (c *MeetingScheduleClient) CreateBulk(builders ...*MeetingScheduleCreate) *MeetingScheduleCreateBulk {
	return &MeetingScheduleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MeetingScheduleClient) MapCreateBulk(slice any, setFunc func(*MeetingScheduleCreate, int)) *MeetingScheduleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MeetingScheduleCreateBulk{err: fmt.Errorf("calling to MeetingScheduleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MeetingScheduleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MeetingScheduleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MeetingSchedule.
func (c *MeetingScheduleClient) Update() *MeetingScheduleUpdate {
	mutation := newMeetingScheduleMutation(c.config, OpUpdate)
	return &MeetingScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MeetingScheduleClient) UpdateOne(ms *MeetingSchedule) *MeetingScheduleUpdateOne {
	mutation := newMeetingScheduleMutation(c.config, OpUpdateOne, withMeetingSchedule(ms))
	return &MeetingScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MeetingScheduleClient) UpdateOneID(id uuid.UUID) *MeetingScheduleUpdateOne {
	mutation := newMeetingScheduleMutation(c.config, OpUpdateOne, withMeetingScheduleID(id))
	return &MeetingScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MeetingSchedule.
func (c *MeetingScheduleClient) Delete() *MeetingScheduleDelete {
	mutation := newMeetingScheduleMutation(c.config, OpDelete)
	return &MeetingScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MeetingScheduleClient) DeleteOne(ms *MeetingSchedule) *MeetingScheduleDeleteOne {
	return c.DeleteOneID(ms.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MeetingScheduleClient) DeleteOneID(id uuid.UUID) *MeetingScheduleDeleteOne {
	builder := c.Delete().Where(meetingschedule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MeetingScheduleDeleteOne{builder}
}

// Query returns a query builder for MeetingSchedule.
func (c *MeetingScheduleClient) Query() *MeetingScheduleQuery {
	return &MeetingScheduleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMeetingSchedule},
		inters: c.Interceptors(),
	}
}

// Get returns a MeetingSchedule entity by its id.
func (c *MeetingScheduleClient) Get(ctx context.Context, id uuid.UUID) (*MeetingSchedule, error) {
	return c.Query().Where(meetingschedule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MeetingScheduleClient) GetX(ctx context.Context, id uuid.UUID) *MeetingSchedule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a MeetingSchedule.
func (c *MeetingScheduleClient) QuerySessions(ms *MeetingSchedule) *MeetingSessionQuery {
	query := (&MeetingSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ms.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(meetingschedule.Table, meetingschedule.FieldID, id),
			sqlgraph.To(meetingsession.Table, meetingsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, meetingschedule.SessionsTable, meetingschedule.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(ms.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwningTeam queries the owning_team edge of a MeetingSchedule.
func (c *MeetingScheduleClient) QueryOwningTeam(ms *MeetingSchedule) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ms.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(meetingschedule.Table, meetingschedule.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, meetingschedule.OwningTeamTable, meetingschedule.OwningTeamPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ms.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MeetingScheduleClient) Hooks() []Hook {
	return c.hooks.MeetingSchedule
}

// Interceptors returns the client interceptors.
func (c *MeetingScheduleClient) Interceptors() []Interceptor {
	return c.inters.MeetingSchedule
}

func (c *MeetingScheduleClient) mutate(ctx context.Context, m *MeetingScheduleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MeetingScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MeetingScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MeetingScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MeetingScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MeetingSchedule mutation op: %q", m.Op())
	}
}

// MeetingSessionClient is a client for the MeetingSession schema.
type MeetingSessionClient struct {
	config
}

// NewMeetingSessionClient returns a client for the MeetingSession from the given config.
func NewMeetingSessionClient(c config) *MeetingSessionClient {
	return &MeetingSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `meetingsession.Hooks(f(g(h())))`.
func (c *MeetingSessionClient) Use(hooks ...Hook) {
	c.hooks.MeetingSession = append(c.hooks.MeetingSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `meetingsession.Intercept(f(g(h())))`.
func (c *MeetingSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MeetingSession = append(c.inters.MeetingSession, interceptors...)
}

// Create returns a builder for creating a MeetingSession entity.
func (c *MeetingSessionClient) Create() *MeetingSessionCreate {
	mutation := newMeetingSessionMutation(c.config, OpCreate)
	return &MeetingSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MeetingSession entities.
func (c *MeetingSessionClient) CreateBulk(builders ...*MeetingSessionCreate) *MeetingSessionCreateBulk {
	return &MeetingSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MeetingSessionClient) MapCreateBulk(slice any, setFunc func(*MeetingSessionCreate, int)) *MeetingSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MeetingSessionCreateBulk{err: fmt.Errorf("calling to MeetingSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MeetingSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MeetingSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MeetingSession.
func (c *MeetingSessionClient) Update() *MeetingSessionUpdate {
	mutation := newMeetingSessionMutation(c.config, OpUpdate)
	return &MeetingSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MeetingSessionClient) UpdateOne(ms *MeetingSession) *MeetingSessionUpdateOne {
	mutation := newMeetingSessionMutation(c.config, OpUpdateOne, withMeetingSession(ms))
	return &MeetingSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MeetingSessionClient) UpdateOneID(id uuid.UUID) *MeetingSessionUpdateOne {
	mutation := newMeetingSessionMutation(c.config, OpUpdateOne, withMeetingSessionID(id))
	return &MeetingSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MeetingSession.
func (c *MeetingSessionClient) Delete() *MeetingSessionDelete {
	mutation := newMeetingSessionMutation(c.config, OpDelete)
	return &MeetingSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MeetingSessionClient) DeleteOne(ms *MeetingSession) *MeetingSessionDeleteOne {
	return c.DeleteOneID(ms.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MeetingSessionClient) DeleteOneID(id uuid.UUID) *MeetingSessionDeleteOne {
	builder := c.Delete().Where(meetingsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MeetingSessionDeleteOne{builder}
}

// Query returns a query builder for MeetingSession.
func (c *MeetingSessionClient) Query() *MeetingSessionQuery {
	return &MeetingSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMeetingSession},
		inters: c.Interceptors(),
	}
}

// Get returns a MeetingSession entity by its id.
func (c *MeetingSessionClient) Get(ctx context.Context, id uuid.UUID) (*MeetingSession, error) {
	return c.Query().Where(meetingsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MeetingSessionClient) GetX(ctx context.Context, id uuid.UUID) *MeetingSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a MeetingSession.
func (c *MeetingSessionClient) QueryIncidents(ms *MeetingSession) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ms.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(meetingsession.Table, meetingsession.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, meetingsession.IncidentsTable, meetingsession.IncidentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ms.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MeetingSessionClient) Hooks() []Hook {
	return c.hooks.MeetingSession
}

// Interceptors returns the client interceptors.
func (c *MeetingSessionClient) Interceptors() []Interceptor {
	return c.inters.MeetingSession
}

func (c *MeetingSessionClient) mutate(ctx context.Context, m *MeetingSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MeetingSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MeetingSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MeetingSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MeetingSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MeetingSession mutation op: %q", m.Op())
	}
}

// OncallAlertClient is a client for the OncallAlert schema.
type OncallAlertClient struct {
	config
}

// NewOncallAlertClient returns a client for the OncallAlert from the given config.
func NewOncallAlertClient(c config) *OncallAlertClient {
	return &OncallAlertClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallalert.Hooks(f(g(h())))`.
func (c *OncallAlertClient) Use(hooks ...Hook) {
	c.hooks.OncallAlert = append(c.hooks.OncallAlert, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallalert.Intercept(f(g(h())))`.
func (c *OncallAlertClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallAlert = append(c.inters.OncallAlert, interceptors...)
}

// Create returns a builder for creating a OncallAlert entity.
func (c *OncallAlertClient) Create() *OncallAlertCreate {
	mutation := newOncallAlertMutation(c.config, OpCreate)
	return &OncallAlertCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallAlert entities.
func (c *OncallAlertClient) CreateBulk(builders ...*OncallAlertCreate) *OncallAlertCreateBulk {
	return &OncallAlertCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallAlertClient) MapCreateBulk(slice any, setFunc func(*OncallAlertCreate, int)) *OncallAlertCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallAlertCreateBulk{err: fmt.Errorf("calling to OncallAlertClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallAlertCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallAlertCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallAlert.
func (c *OncallAlertClient) Update() *OncallAlertUpdate {
	mutation := newOncallAlertMutation(c.config, OpUpdate)
	return &OncallAlertUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallAlertClient) UpdateOne(oa *OncallAlert) *OncallAlertUpdateOne {
	mutation := newOncallAlertMutation(c.config, OpUpdateOne, withOncallAlert(oa))
	return &OncallAlertUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallAlertClient) UpdateOneID(id uuid.UUID) *OncallAlertUpdateOne {
	mutation := newOncallAlertMutation(c.config, OpUpdateOne, withOncallAlertID(id))
	return &OncallAlertUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallAlert.
func (c *OncallAlertClient) Delete() *OncallAlertDelete {
	mutation := newOncallAlertMutation(c.config, OpDelete)
	return &OncallAlertDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallAlertClient) DeleteOne(oa *OncallAlert) *OncallAlertDeleteOne {
	return c.DeleteOneID(oa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallAlertClient) DeleteOneID(id uuid.UUID) *OncallAlertDeleteOne {
	builder := c.Delete().Where(oncallalert.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallAlertDeleteOne{builder}
}

// Query returns a query builder for OncallAlert.
func (c *OncallAlertClient) Query() *OncallAlertQuery {
	return &OncallAlertQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallAlert},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallAlert entity by its id.
func (c *OncallAlertClient) Get(ctx context.Context, id uuid.UUID) (*OncallAlert, error) {
	return c.Query().Where(oncallalert.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallAlertClient) GetX(ctx context.Context, id uuid.UUID) *OncallAlert {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstances queries the instances edge of a OncallAlert.
func (c *OncallAlertClient) QueryInstances(oa *OncallAlert) *OncallAlertInstanceQuery {
	query := (&OncallAlertInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallalert.Table, oncallalert.FieldID, id),
			sqlgraph.To(oncallalertinstance.Table, oncallalertinstance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oncallalert.InstancesTable, oncallalert.InstancesColumn),
		)
		fromV = sqlgraph.Neighbors(oa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoster queries the roster edge of a OncallAlert.
func (c *OncallAlertClient) QueryRoster(oa *OncallAlert) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallalert.Table, oncallalert.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallalert.RosterTable, oncallalert.RosterColumn),
		)
		fromV = sqlgraph.Neighbors(oa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallAlertClient) Hooks() []Hook {
	return c.hooks.OncallAlert
}

// Interceptors returns the client interceptors.
func (c *OncallAlertClient) Interceptors() []Interceptor {
	return c.inters.OncallAlert
}

func (c *OncallAlertClient) mutate(ctx context.Context, m *OncallAlertMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallAlertCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallAlertUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallAlertUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallAlertDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallAlert mutation op: %q", m.Op())
	}
}

// OncallAlertInstanceClient is a client for the OncallAlertInstance schema.
type OncallAlertInstanceClient struct {
	config
}

// NewOncallAlertInstanceClient returns a client for the OncallAlertInstance from the given config.
func NewOncallAlertInstanceClient(c config) *OncallAlertInstanceClient {
	return &OncallAlertInstanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallalertinstance.Hooks(f(g(h())))`.
func (c *OncallAlertInstanceClient) Use(hooks ...Hook) {
	c.hooks.OncallAlertInstance = append(c.hooks.OncallAlertInstance, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallalertinstance.Intercept(f(g(h())))`.
func (c *OncallAlertInstanceClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallAlertInstance = append(c.inters.OncallAlertInstance, interceptors...)
}

// Create returns a builder for creating a OncallAlertInstance entity.
func (c *OncallAlertInstanceClient) Create() *OncallAlertInstanceCreate {
	mutation := newOncallAlertInstanceMutation(c.config, OpCreate)
	return &OncallAlertInstanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallAlertInstance entities.
func (c *OncallAlertInstanceClient) CreateBulk(builders ...*OncallAlertInstanceCreate) *OncallAlertInstanceCreateBulk {
	return &OncallAlertInstanceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallAlertInstanceClient) MapCreateBulk(slice any, setFunc func(*OncallAlertInstanceCreate, int)) *OncallAlertInstanceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallAlertInstanceCreateBulk{err: fmt.Errorf("calling to OncallAlertInstanceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallAlertInstanceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallAlertInstanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallAlertInstance.
func (c *OncallAlertInstanceClient) Update() *OncallAlertInstanceUpdate {
	mutation := newOncallAlertInstanceMutation(c.config, OpUpdate)
	return &OncallAlertInstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallAlertInstanceClient) UpdateOne(oai *OncallAlertInstance) *OncallAlertInstanceUpdateOne {
	mutation := newOncallAlertInstanceMutation(c.config, OpUpdateOne, withOncallAlertInstance(oai))
	return &OncallAlertInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallAlertInstanceClient) UpdateOneID(id uuid.UUID) *OncallAlertInstanceUpdateOne {
	mutation := newOncallAlertInstanceMutation(c.config, OpUpdateOne, withOncallAlertInstanceID(id))
	return &OncallAlertInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallAlertInstance.
func (c *OncallAlertInstanceClient) Delete() *OncallAlertInstanceDelete {
	mutation := newOncallAlertInstanceMutation(c.config, OpDelete)
	return &OncallAlertInstanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallAlertInstanceClient) DeleteOne(oai *OncallAlertInstance) *OncallAlertInstanceDeleteOne {
	return c.DeleteOneID(oai.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallAlertInstanceClient) DeleteOneID(id uuid.UUID) *OncallAlertInstanceDeleteOne {
	builder := c.Delete().Where(oncallalertinstance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallAlertInstanceDeleteOne{builder}
}

// Query returns a query builder for OncallAlertInstance.
func (c *OncallAlertInstanceClient) Query() *OncallAlertInstanceQuery {
	return &OncallAlertInstanceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallAlertInstance},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallAlertInstance entity by its id.
func (c *OncallAlertInstanceClient) Get(ctx context.Context, id uuid.UUID) (*OncallAlertInstance, error) {
	return c.Query().Where(oncallalertinstance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallAlertInstanceClient) GetX(ctx context.Context, id uuid.UUID) *OncallAlertInstance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAlert queries the alert edge of a OncallAlertInstance.
func (c *OncallAlertInstanceClient) QueryAlert(oai *OncallAlertInstance) *OncallAlertQuery {
	query := (&OncallAlertClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oai.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallalertinstance.Table, oncallalertinstance.FieldID, id),
			sqlgraph.To(oncallalert.Table, oncallalert.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oncallalertinstance.AlertTable, oncallalertinstance.AlertColumn),
		)
		fromV = sqlgraph.Neighbors(oai.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReceiver queries the receiver edge of a OncallAlertInstance.
func (c *OncallAlertInstanceClient) QueryReceiver(oai *OncallAlertInstance) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oai.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallalertinstance.Table, oncallalertinstance.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallalertinstance.ReceiverTable, oncallalertinstance.ReceiverColumn),
		)
		fromV = sqlgraph.Neighbors(oai.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallAlertInstanceClient) Hooks() []Hook {
	return c.hooks.OncallAlertInstance
}

// Interceptors returns the client interceptors.
func (c *OncallAlertInstanceClient) Interceptors() []Interceptor {
	return c.inters.OncallAlertInstance
}

func (c *OncallAlertInstanceClient) mutate(ctx context.Context, m *OncallAlertInstanceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallAlertInstanceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallAlertInstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallAlertInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallAlertInstanceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallAlertInstance mutation op: %q", m.Op())
	}
}

// OncallHandoverTemplateClient is a client for the OncallHandoverTemplate schema.
type OncallHandoverTemplateClient struct {
	config
}

// NewOncallHandoverTemplateClient returns a client for the OncallHandoverTemplate from the given config.
func NewOncallHandoverTemplateClient(c config) *OncallHandoverTemplateClient {
	return &OncallHandoverTemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallhandovertemplate.Hooks(f(g(h())))`.
func (c *OncallHandoverTemplateClient) Use(hooks ...Hook) {
	c.hooks.OncallHandoverTemplate = append(c.hooks.OncallHandoverTemplate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallhandovertemplate.Intercept(f(g(h())))`.
func (c *OncallHandoverTemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallHandoverTemplate = append(c.inters.OncallHandoverTemplate, interceptors...)
}

// Create returns a builder for creating a OncallHandoverTemplate entity.
func (c *OncallHandoverTemplateClient) Create() *OncallHandoverTemplateCreate {
	mutation := newOncallHandoverTemplateMutation(c.config, OpCreate)
	return &OncallHandoverTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallHandoverTemplate entities.
func (c *OncallHandoverTemplateClient) CreateBulk(builders ...*OncallHandoverTemplateCreate) *OncallHandoverTemplateCreateBulk {
	return &OncallHandoverTemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallHandoverTemplateClient) MapCreateBulk(slice any, setFunc func(*OncallHandoverTemplateCreate, int)) *OncallHandoverTemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallHandoverTemplateCreateBulk{err: fmt.Errorf("calling to OncallHandoverTemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallHandoverTemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallHandoverTemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallHandoverTemplate.
func (c *OncallHandoverTemplateClient) Update() *OncallHandoverTemplateUpdate {
	mutation := newOncallHandoverTemplateMutation(c.config, OpUpdate)
	return &OncallHandoverTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallHandoverTemplateClient) UpdateOne(oht *OncallHandoverTemplate) *OncallHandoverTemplateUpdateOne {
	mutation := newOncallHandoverTemplateMutation(c.config, OpUpdateOne, withOncallHandoverTemplate(oht))
	return &OncallHandoverTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallHandoverTemplateClient) UpdateOneID(id uuid.UUID) *OncallHandoverTemplateUpdateOne {
	mutation := newOncallHandoverTemplateMutation(c.config, OpUpdateOne, withOncallHandoverTemplateID(id))
	return &OncallHandoverTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallHandoverTemplate.
func (c *OncallHandoverTemplateClient) Delete() *OncallHandoverTemplateDelete {
	mutation := newOncallHandoverTemplateMutation(c.config, OpDelete)
	return &OncallHandoverTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallHandoverTemplateClient) DeleteOne(oht *OncallHandoverTemplate) *OncallHandoverTemplateDeleteOne {
	return c.DeleteOneID(oht.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallHandoverTemplateClient) DeleteOneID(id uuid.UUID) *OncallHandoverTemplateDeleteOne {
	builder := c.Delete().Where(oncallhandovertemplate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallHandoverTemplateDeleteOne{builder}
}

// Query returns a query builder for OncallHandoverTemplate.
func (c *OncallHandoverTemplateClient) Query() *OncallHandoverTemplateQuery {
	return &OncallHandoverTemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallHandoverTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallHandoverTemplate entity by its id.
func (c *OncallHandoverTemplateClient) Get(ctx context.Context, id uuid.UUID) (*OncallHandoverTemplate, error) {
	return c.Query().Where(oncallhandovertemplate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallHandoverTemplateClient) GetX(ctx context.Context, id uuid.UUID) *OncallHandoverTemplate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoster queries the roster edge of a OncallHandoverTemplate.
func (c *OncallHandoverTemplateClient) QueryRoster(oht *OncallHandoverTemplate) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oht.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallhandovertemplate.Table, oncallhandovertemplate.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oncallhandovertemplate.RosterTable, oncallhandovertemplate.RosterColumn),
		)
		fromV = sqlgraph.Neighbors(oht.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallHandoverTemplateClient) Hooks() []Hook {
	return c.hooks.OncallHandoverTemplate
}

// Interceptors returns the client interceptors.
func (c *OncallHandoverTemplateClient) Interceptors() []Interceptor {
	return c.inters.OncallHandoverTemplate
}

func (c *OncallHandoverTemplateClient) mutate(ctx context.Context, m *OncallHandoverTemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallHandoverTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallHandoverTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallHandoverTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallHandoverTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallHandoverTemplate mutation op: %q", m.Op())
	}
}

// OncallRosterClient is a client for the OncallRoster schema.
type OncallRosterClient struct {
	config
}

// NewOncallRosterClient returns a client for the OncallRoster from the given config.
func NewOncallRosterClient(c config) *OncallRosterClient {
	return &OncallRosterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallroster.Hooks(f(g(h())))`.
func (c *OncallRosterClient) Use(hooks ...Hook) {
	c.hooks.OncallRoster = append(c.hooks.OncallRoster, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallroster.Intercept(f(g(h())))`.
func (c *OncallRosterClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallRoster = append(c.inters.OncallRoster, interceptors...)
}

// Create returns a builder for creating a OncallRoster entity.
func (c *OncallRosterClient) Create() *OncallRosterCreate {
	mutation := newOncallRosterMutation(c.config, OpCreate)
	return &OncallRosterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallRoster entities.
func (c *OncallRosterClient) CreateBulk(builders ...*OncallRosterCreate) *OncallRosterCreateBulk {
	return &OncallRosterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallRosterClient) MapCreateBulk(slice any, setFunc func(*OncallRosterCreate, int)) *OncallRosterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallRosterCreateBulk{err: fmt.Errorf("calling to OncallRosterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallRosterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallRosterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallRoster.
func (c *OncallRosterClient) Update() *OncallRosterUpdate {
	mutation := newOncallRosterMutation(c.config, OpUpdate)
	return &OncallRosterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallRosterClient) UpdateOne(or *OncallRoster) *OncallRosterUpdateOne {
	mutation := newOncallRosterMutation(c.config, OpUpdateOne, withOncallRoster(or))
	return &OncallRosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallRosterClient) UpdateOneID(id uuid.UUID) *OncallRosterUpdateOne {
	mutation := newOncallRosterMutation(c.config, OpUpdateOne, withOncallRosterID(id))
	return &OncallRosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallRoster.
func (c *OncallRosterClient) Delete() *OncallRosterDelete {
	mutation := newOncallRosterMutation(c.config, OpDelete)
	return &OncallRosterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallRosterClient) DeleteOne(or *OncallRoster) *OncallRosterDeleteOne {
	return c.DeleteOneID(or.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallRosterClient) DeleteOneID(id uuid.UUID) *OncallRosterDeleteOne {
	builder := c.Delete().Where(oncallroster.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallRosterDeleteOne{builder}
}

// Query returns a query builder for OncallRoster.
func (c *OncallRosterClient) Query() *OncallRosterQuery {
	return &OncallRosterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallRoster},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallRoster entity by its id.
func (c *OncallRosterClient) Get(ctx context.Context, id uuid.UUID) (*OncallRoster, error) {
	return c.Query().Where(oncallroster.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallRosterClient) GetX(ctx context.Context, id uuid.UUID) *OncallRoster {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySchedules queries the schedules edge of a OncallRoster.
func (c *OncallRosterClient) QuerySchedules(or *OncallRoster) *OncallScheduleQuery {
	query := (&OncallScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(oncallschedule.Table, oncallschedule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oncallroster.SchedulesTable, oncallroster.SchedulesColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHandoverTemplate queries the handover_template edge of a OncallRoster.
func (c *OncallRosterClient) QueryHandoverTemplate(or *OncallRoster) *OncallHandoverTemplateQuery {
	query := (&OncallHandoverTemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(oncallhandovertemplate.Table, oncallhandovertemplate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oncallroster.HandoverTemplateTable, oncallroster.HandoverTemplateColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the teams edge of a OncallRoster.
func (c *OncallRosterClient) QueryTeams(or *OncallRoster) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, oncallroster.TeamsTable, oncallroster.TeamsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShifts queries the shifts edge of a OncallRoster.
func (c *OncallRosterClient) QueryShifts(or *OncallRoster) *OncallUserShiftQuery {
	query := (&OncallUserShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(oncallusershift.Table, oncallusershift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, oncallroster.ShiftsTable, oncallroster.ShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlerts queries the alerts edge of a OncallRoster.
func (c *OncallRosterClient) QueryAlerts(or *OncallRoster) *OncallAlertQuery {
	query := (&OncallAlertClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallroster.Table, oncallroster.FieldID, id),
			sqlgraph.To(oncallalert.Table, oncallalert.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, oncallroster.AlertsTable, oncallroster.AlertsColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallRosterClient) Hooks() []Hook {
	hooks := c.hooks.OncallRoster
	return append(hooks[:len(hooks):len(hooks)], oncallroster.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallRosterClient) Interceptors() []Interceptor {
	inters := c.inters.OncallRoster
	return append(inters[:len(inters):len(inters)], oncallroster.Interceptors[:]...)
}

func (c *OncallRosterClient) mutate(ctx context.Context, m *OncallRosterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallRosterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallRosterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallRosterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallRosterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallRoster mutation op: %q", m.Op())
	}
}

// OncallScheduleClient is a client for the OncallSchedule schema.
type OncallScheduleClient struct {
	config
}

// NewOncallScheduleClient returns a client for the OncallSchedule from the given config.
func NewOncallScheduleClient(c config) *OncallScheduleClient {
	return &OncallScheduleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallschedule.Hooks(f(g(h())))`.
func (c *OncallScheduleClient) Use(hooks ...Hook) {
	c.hooks.OncallSchedule = append(c.hooks.OncallSchedule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallschedule.Intercept(f(g(h())))`.
func (c *OncallScheduleClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallSchedule = append(c.inters.OncallSchedule, interceptors...)
}

// Create returns a builder for creating a OncallSchedule entity.
func (c *OncallScheduleClient) Create() *OncallScheduleCreate {
	mutation := newOncallScheduleMutation(c.config, OpCreate)
	return &OncallScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallSchedule entities.
func (c *OncallScheduleClient) CreateBulk(builders ...*OncallScheduleCreate) *OncallScheduleCreateBulk {
	return &OncallScheduleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallScheduleClient) MapCreateBulk(slice any, setFunc func(*OncallScheduleCreate, int)) *OncallScheduleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallScheduleCreateBulk{err: fmt.Errorf("calling to OncallScheduleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallScheduleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallScheduleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallSchedule.
func (c *OncallScheduleClient) Update() *OncallScheduleUpdate {
	mutation := newOncallScheduleMutation(c.config, OpUpdate)
	return &OncallScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallScheduleClient) UpdateOne(os *OncallSchedule) *OncallScheduleUpdateOne {
	mutation := newOncallScheduleMutation(c.config, OpUpdateOne, withOncallSchedule(os))
	return &OncallScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallScheduleClient) UpdateOneID(id uuid.UUID) *OncallScheduleUpdateOne {
	mutation := newOncallScheduleMutation(c.config, OpUpdateOne, withOncallScheduleID(id))
	return &OncallScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallSchedule.
func (c *OncallScheduleClient) Delete() *OncallScheduleDelete {
	mutation := newOncallScheduleMutation(c.config, OpDelete)
	return &OncallScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallScheduleClient) DeleteOne(os *OncallSchedule) *OncallScheduleDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallScheduleClient) DeleteOneID(id uuid.UUID) *OncallScheduleDeleteOne {
	builder := c.Delete().Where(oncallschedule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallScheduleDeleteOne{builder}
}

// Query returns a query builder for OncallSchedule.
func (c *OncallScheduleClient) Query() *OncallScheduleQuery {
	return &OncallScheduleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallSchedule},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallSchedule entity by its id.
func (c *OncallScheduleClient) Get(ctx context.Context, id uuid.UUID) (*OncallSchedule, error) {
	return c.Query().Where(oncallschedule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallScheduleClient) GetX(ctx context.Context, id uuid.UUID) *OncallSchedule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParticipants queries the participants edge of a OncallSchedule.
func (c *OncallScheduleClient) QueryParticipants(os *OncallSchedule) *OncallScheduleParticipantQuery {
	query := (&OncallScheduleParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallschedule.Table, oncallschedule.FieldID, id),
			sqlgraph.To(oncallscheduleparticipant.Table, oncallscheduleparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oncallschedule.ParticipantsTable, oncallschedule.ParticipantsColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoster queries the roster edge of a OncallSchedule.
func (c *OncallScheduleClient) QueryRoster(os *OncallSchedule) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallschedule.Table, oncallschedule.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oncallschedule.RosterTable, oncallschedule.RosterColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallScheduleClient) Hooks() []Hook {
	hooks := c.hooks.OncallSchedule
	return append(hooks[:len(hooks):len(hooks)], oncallschedule.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OncallScheduleClient) Interceptors() []Interceptor {
	inters := c.inters.OncallSchedule
	return append(inters[:len(inters):len(inters)], oncallschedule.Interceptors[:]...)
}

func (c *OncallScheduleClient) mutate(ctx context.Context, m *OncallScheduleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallSchedule mutation op: %q", m.Op())
	}
}

// OncallScheduleParticipantClient is a client for the OncallScheduleParticipant schema.
type OncallScheduleParticipantClient struct {
	config
}

// NewOncallScheduleParticipantClient returns a client for the OncallScheduleParticipant from the given config.
func NewOncallScheduleParticipantClient(c config) *OncallScheduleParticipantClient {
	return &OncallScheduleParticipantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallscheduleparticipant.Hooks(f(g(h())))`.
func (c *OncallScheduleParticipantClient) Use(hooks ...Hook) {
	c.hooks.OncallScheduleParticipant = append(c.hooks.OncallScheduleParticipant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallscheduleparticipant.Intercept(f(g(h())))`.
func (c *OncallScheduleParticipantClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallScheduleParticipant = append(c.inters.OncallScheduleParticipant, interceptors...)
}

// Create returns a builder for creating a OncallScheduleParticipant entity.
func (c *OncallScheduleParticipantClient) Create() *OncallScheduleParticipantCreate {
	mutation := newOncallScheduleParticipantMutation(c.config, OpCreate)
	return &OncallScheduleParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallScheduleParticipant entities.
func (c *OncallScheduleParticipantClient) CreateBulk(builders ...*OncallScheduleParticipantCreate) *OncallScheduleParticipantCreateBulk {
	return &OncallScheduleParticipantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallScheduleParticipantClient) MapCreateBulk(slice any, setFunc func(*OncallScheduleParticipantCreate, int)) *OncallScheduleParticipantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallScheduleParticipantCreateBulk{err: fmt.Errorf("calling to OncallScheduleParticipantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallScheduleParticipantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallScheduleParticipantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallScheduleParticipant.
func (c *OncallScheduleParticipantClient) Update() *OncallScheduleParticipantUpdate {
	mutation := newOncallScheduleParticipantMutation(c.config, OpUpdate)
	return &OncallScheduleParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallScheduleParticipantClient) UpdateOne(osp *OncallScheduleParticipant) *OncallScheduleParticipantUpdateOne {
	mutation := newOncallScheduleParticipantMutation(c.config, OpUpdateOne, withOncallScheduleParticipant(osp))
	return &OncallScheduleParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallScheduleParticipantClient) UpdateOneID(id uuid.UUID) *OncallScheduleParticipantUpdateOne {
	mutation := newOncallScheduleParticipantMutation(c.config, OpUpdateOne, withOncallScheduleParticipantID(id))
	return &OncallScheduleParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallScheduleParticipant.
func (c *OncallScheduleParticipantClient) Delete() *OncallScheduleParticipantDelete {
	mutation := newOncallScheduleParticipantMutation(c.config, OpDelete)
	return &OncallScheduleParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallScheduleParticipantClient) DeleteOne(osp *OncallScheduleParticipant) *OncallScheduleParticipantDeleteOne {
	return c.DeleteOneID(osp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallScheduleParticipantClient) DeleteOneID(id uuid.UUID) *OncallScheduleParticipantDeleteOne {
	builder := c.Delete().Where(oncallscheduleparticipant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallScheduleParticipantDeleteOne{builder}
}

// Query returns a query builder for OncallScheduleParticipant.
func (c *OncallScheduleParticipantClient) Query() *OncallScheduleParticipantQuery {
	return &OncallScheduleParticipantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallScheduleParticipant},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallScheduleParticipant entity by its id.
func (c *OncallScheduleParticipantClient) Get(ctx context.Context, id uuid.UUID) (*OncallScheduleParticipant, error) {
	return c.Query().Where(oncallscheduleparticipant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallScheduleParticipantClient) GetX(ctx context.Context, id uuid.UUID) *OncallScheduleParticipant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySchedule queries the schedule edge of a OncallScheduleParticipant.
func (c *OncallScheduleParticipantClient) QuerySchedule(osp *OncallScheduleParticipant) *OncallScheduleQuery {
	query := (&OncallScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := osp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallscheduleparticipant.Table, oncallscheduleparticipant.FieldID, id),
			sqlgraph.To(oncallschedule.Table, oncallschedule.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oncallscheduleparticipant.ScheduleTable, oncallscheduleparticipant.ScheduleColumn),
		)
		fromV = sqlgraph.Neighbors(osp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OncallScheduleParticipant.
func (c *OncallScheduleParticipantClient) QueryUser(osp *OncallScheduleParticipant) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := osp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallscheduleparticipant.Table, oncallscheduleparticipant.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallscheduleparticipant.UserTable, oncallscheduleparticipant.UserColumn),
		)
		fromV = sqlgraph.Neighbors(osp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallScheduleParticipantClient) Hooks() []Hook {
	return c.hooks.OncallScheduleParticipant
}

// Interceptors returns the client interceptors.
func (c *OncallScheduleParticipantClient) Interceptors() []Interceptor {
	return c.inters.OncallScheduleParticipant
}

func (c *OncallScheduleParticipantClient) mutate(ctx context.Context, m *OncallScheduleParticipantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallScheduleParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallScheduleParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallScheduleParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallScheduleParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallScheduleParticipant mutation op: %q", m.Op())
	}
}

// OncallUserShiftClient is a client for the OncallUserShift schema.
type OncallUserShiftClient struct {
	config
}

// NewOncallUserShiftClient returns a client for the OncallUserShift from the given config.
func NewOncallUserShiftClient(c config) *OncallUserShiftClient {
	return &OncallUserShiftClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallusershift.Hooks(f(g(h())))`.
func (c *OncallUserShiftClient) Use(hooks ...Hook) {
	c.hooks.OncallUserShift = append(c.hooks.OncallUserShift, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallusershift.Intercept(f(g(h())))`.
func (c *OncallUserShiftClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallUserShift = append(c.inters.OncallUserShift, interceptors...)
}

// Create returns a builder for creating a OncallUserShift entity.
func (c *OncallUserShiftClient) Create() *OncallUserShiftCreate {
	mutation := newOncallUserShiftMutation(c.config, OpCreate)
	return &OncallUserShiftCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallUserShift entities.
func (c *OncallUserShiftClient) CreateBulk(builders ...*OncallUserShiftCreate) *OncallUserShiftCreateBulk {
	return &OncallUserShiftCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallUserShiftClient) MapCreateBulk(slice any, setFunc func(*OncallUserShiftCreate, int)) *OncallUserShiftCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallUserShiftCreateBulk{err: fmt.Errorf("calling to OncallUserShiftClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallUserShiftCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallUserShiftCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallUserShift.
func (c *OncallUserShiftClient) Update() *OncallUserShiftUpdate {
	mutation := newOncallUserShiftMutation(c.config, OpUpdate)
	return &OncallUserShiftUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallUserShiftClient) UpdateOne(ous *OncallUserShift) *OncallUserShiftUpdateOne {
	mutation := newOncallUserShiftMutation(c.config, OpUpdateOne, withOncallUserShift(ous))
	return &OncallUserShiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallUserShiftClient) UpdateOneID(id uuid.UUID) *OncallUserShiftUpdateOne {
	mutation := newOncallUserShiftMutation(c.config, OpUpdateOne, withOncallUserShiftID(id))
	return &OncallUserShiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallUserShift.
func (c *OncallUserShiftClient) Delete() *OncallUserShiftDelete {
	mutation := newOncallUserShiftMutation(c.config, OpDelete)
	return &OncallUserShiftDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallUserShiftClient) DeleteOne(ous *OncallUserShift) *OncallUserShiftDeleteOne {
	return c.DeleteOneID(ous.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallUserShiftClient) DeleteOneID(id uuid.UUID) *OncallUserShiftDeleteOne {
	builder := c.Delete().Where(oncallusershift.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallUserShiftDeleteOne{builder}
}

// Query returns a query builder for OncallUserShift.
func (c *OncallUserShiftClient) Query() *OncallUserShiftQuery {
	return &OncallUserShiftQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallUserShift},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallUserShift entity by its id.
func (c *OncallUserShiftClient) Get(ctx context.Context, id uuid.UUID) (*OncallUserShift, error) {
	return c.Query().Where(oncallusershift.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallUserShiftClient) GetX(ctx context.Context, id uuid.UUID) *OncallUserShift {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a OncallUserShift.
func (c *OncallUserShiftClient) QueryUser(ous *OncallUserShift) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ous.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershift.Table, oncallusershift.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallusershift.UserTable, oncallusershift.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ous.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoster queries the roster edge of a OncallUserShift.
func (c *OncallUserShiftClient) QueryRoster(ous *OncallUserShift) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ous.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershift.Table, oncallusershift.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallusershift.RosterTable, oncallusershift.RosterColumn),
		)
		fromV = sqlgraph.Neighbors(ous.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCovers queries the covers edge of a OncallUserShift.
func (c *OncallUserShiftClient) QueryCovers(ous *OncallUserShift) *OncallUserShiftCoverQuery {
	query := (&OncallUserShiftCoverClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ous.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershift.Table, oncallusershift.FieldID, id),
			sqlgraph.To(oncallusershiftcover.Table, oncallusershiftcover.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oncallusershift.CoversTable, oncallusershift.CoversColumn),
		)
		fromV = sqlgraph.Neighbors(ous.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnnotations queries the annotations edge of a OncallUserShift.
func (c *OncallUserShiftClient) QueryAnnotations(ous *OncallUserShift) *OncallUserShiftAnnotationQuery {
	query := (&OncallUserShiftAnnotationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ous.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershift.Table, oncallusershift.FieldID, id),
			sqlgraph.To(oncallusershiftannotation.Table, oncallusershiftannotation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oncallusershift.AnnotationsTable, oncallusershift.AnnotationsColumn),
		)
		fromV = sqlgraph.Neighbors(ous.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHandover queries the handover edge of a OncallUserShift.
func (c *OncallUserShiftClient) QueryHandover(ous *OncallUserShift) *OncallUserShiftHandoverQuery {
	query := (&OncallUserShiftHandoverClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ous.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershift.Table, oncallusershift.FieldID, id),
			sqlgraph.To(oncallusershifthandover.Table, oncallusershifthandover.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oncallusershift.HandoverTable, oncallusershift.HandoverColumn),
		)
		fromV = sqlgraph.Neighbors(ous.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallUserShiftClient) Hooks() []Hook {
	return c.hooks.OncallUserShift
}

// Interceptors returns the client interceptors.
func (c *OncallUserShiftClient) Interceptors() []Interceptor {
	return c.inters.OncallUserShift
}

func (c *OncallUserShiftClient) mutate(ctx context.Context, m *OncallUserShiftMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallUserShiftCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallUserShiftUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallUserShiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallUserShiftDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallUserShift mutation op: %q", m.Op())
	}
}

// OncallUserShiftAnnotationClient is a client for the OncallUserShiftAnnotation schema.
type OncallUserShiftAnnotationClient struct {
	config
}

// NewOncallUserShiftAnnotationClient returns a client for the OncallUserShiftAnnotation from the given config.
func NewOncallUserShiftAnnotationClient(c config) *OncallUserShiftAnnotationClient {
	return &OncallUserShiftAnnotationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallusershiftannotation.Hooks(f(g(h())))`.
func (c *OncallUserShiftAnnotationClient) Use(hooks ...Hook) {
	c.hooks.OncallUserShiftAnnotation = append(c.hooks.OncallUserShiftAnnotation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallusershiftannotation.Intercept(f(g(h())))`.
func (c *OncallUserShiftAnnotationClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallUserShiftAnnotation = append(c.inters.OncallUserShiftAnnotation, interceptors...)
}

// Create returns a builder for creating a OncallUserShiftAnnotation entity.
func (c *OncallUserShiftAnnotationClient) Create() *OncallUserShiftAnnotationCreate {
	mutation := newOncallUserShiftAnnotationMutation(c.config, OpCreate)
	return &OncallUserShiftAnnotationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallUserShiftAnnotation entities.
func (c *OncallUserShiftAnnotationClient) CreateBulk(builders ...*OncallUserShiftAnnotationCreate) *OncallUserShiftAnnotationCreateBulk {
	return &OncallUserShiftAnnotationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallUserShiftAnnotationClient) MapCreateBulk(slice any, setFunc func(*OncallUserShiftAnnotationCreate, int)) *OncallUserShiftAnnotationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallUserShiftAnnotationCreateBulk{err: fmt.Errorf("calling to OncallUserShiftAnnotationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallUserShiftAnnotationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallUserShiftAnnotationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallUserShiftAnnotation.
func (c *OncallUserShiftAnnotationClient) Update() *OncallUserShiftAnnotationUpdate {
	mutation := newOncallUserShiftAnnotationMutation(c.config, OpUpdate)
	return &OncallUserShiftAnnotationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallUserShiftAnnotationClient) UpdateOne(ousa *OncallUserShiftAnnotation) *OncallUserShiftAnnotationUpdateOne {
	mutation := newOncallUserShiftAnnotationMutation(c.config, OpUpdateOne, withOncallUserShiftAnnotation(ousa))
	return &OncallUserShiftAnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallUserShiftAnnotationClient) UpdateOneID(id uuid.UUID) *OncallUserShiftAnnotationUpdateOne {
	mutation := newOncallUserShiftAnnotationMutation(c.config, OpUpdateOne, withOncallUserShiftAnnotationID(id))
	return &OncallUserShiftAnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallUserShiftAnnotation.
func (c *OncallUserShiftAnnotationClient) Delete() *OncallUserShiftAnnotationDelete {
	mutation := newOncallUserShiftAnnotationMutation(c.config, OpDelete)
	return &OncallUserShiftAnnotationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallUserShiftAnnotationClient) DeleteOne(ousa *OncallUserShiftAnnotation) *OncallUserShiftAnnotationDeleteOne {
	return c.DeleteOneID(ousa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallUserShiftAnnotationClient) DeleteOneID(id uuid.UUID) *OncallUserShiftAnnotationDeleteOne {
	builder := c.Delete().Where(oncallusershiftannotation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallUserShiftAnnotationDeleteOne{builder}
}

// Query returns a query builder for OncallUserShiftAnnotation.
func (c *OncallUserShiftAnnotationClient) Query() *OncallUserShiftAnnotationQuery {
	return &OncallUserShiftAnnotationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallUserShiftAnnotation},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallUserShiftAnnotation entity by its id.
func (c *OncallUserShiftAnnotationClient) Get(ctx context.Context, id uuid.UUID) (*OncallUserShiftAnnotation, error) {
	return c.Query().Where(oncallusershiftannotation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallUserShiftAnnotationClient) GetX(ctx context.Context, id uuid.UUID) *OncallUserShiftAnnotation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryShift queries the shift edge of a OncallUserShiftAnnotation.
func (c *OncallUserShiftAnnotationClient) QueryShift(ousa *OncallUserShiftAnnotation) *OncallUserShiftQuery {
	query := (&OncallUserShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ousa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershiftannotation.Table, oncallusershiftannotation.FieldID, id),
			sqlgraph.To(oncallusershift.Table, oncallusershift.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oncallusershiftannotation.ShiftTable, oncallusershiftannotation.ShiftColumn),
		)
		fromV = sqlgraph.Neighbors(ousa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallUserShiftAnnotationClient) Hooks() []Hook {
	return c.hooks.OncallUserShiftAnnotation
}

// Interceptors returns the client interceptors.
func (c *OncallUserShiftAnnotationClient) Interceptors() []Interceptor {
	return c.inters.OncallUserShiftAnnotation
}

func (c *OncallUserShiftAnnotationClient) mutate(ctx context.Context, m *OncallUserShiftAnnotationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallUserShiftAnnotationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallUserShiftAnnotationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallUserShiftAnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallUserShiftAnnotationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallUserShiftAnnotation mutation op: %q", m.Op())
	}
}

// OncallUserShiftCoverClient is a client for the OncallUserShiftCover schema.
type OncallUserShiftCoverClient struct {
	config
}

// NewOncallUserShiftCoverClient returns a client for the OncallUserShiftCover from the given config.
func NewOncallUserShiftCoverClient(c config) *OncallUserShiftCoverClient {
	return &OncallUserShiftCoverClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallusershiftcover.Hooks(f(g(h())))`.
func (c *OncallUserShiftCoverClient) Use(hooks ...Hook) {
	c.hooks.OncallUserShiftCover = append(c.hooks.OncallUserShiftCover, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallusershiftcover.Intercept(f(g(h())))`.
func (c *OncallUserShiftCoverClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallUserShiftCover = append(c.inters.OncallUserShiftCover, interceptors...)
}

// Create returns a builder for creating a OncallUserShiftCover entity.
func (c *OncallUserShiftCoverClient) Create() *OncallUserShiftCoverCreate {
	mutation := newOncallUserShiftCoverMutation(c.config, OpCreate)
	return &OncallUserShiftCoverCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallUserShiftCover entities.
func (c *OncallUserShiftCoverClient) CreateBulk(builders ...*OncallUserShiftCoverCreate) *OncallUserShiftCoverCreateBulk {
	return &OncallUserShiftCoverCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallUserShiftCoverClient) MapCreateBulk(slice any, setFunc func(*OncallUserShiftCoverCreate, int)) *OncallUserShiftCoverCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallUserShiftCoverCreateBulk{err: fmt.Errorf("calling to OncallUserShiftCoverClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallUserShiftCoverCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallUserShiftCoverCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallUserShiftCover.
func (c *OncallUserShiftCoverClient) Update() *OncallUserShiftCoverUpdate {
	mutation := newOncallUserShiftCoverMutation(c.config, OpUpdate)
	return &OncallUserShiftCoverUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallUserShiftCoverClient) UpdateOne(ousc *OncallUserShiftCover) *OncallUserShiftCoverUpdateOne {
	mutation := newOncallUserShiftCoverMutation(c.config, OpUpdateOne, withOncallUserShiftCover(ousc))
	return &OncallUserShiftCoverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallUserShiftCoverClient) UpdateOneID(id uuid.UUID) *OncallUserShiftCoverUpdateOne {
	mutation := newOncallUserShiftCoverMutation(c.config, OpUpdateOne, withOncallUserShiftCoverID(id))
	return &OncallUserShiftCoverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallUserShiftCover.
func (c *OncallUserShiftCoverClient) Delete() *OncallUserShiftCoverDelete {
	mutation := newOncallUserShiftCoverMutation(c.config, OpDelete)
	return &OncallUserShiftCoverDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallUserShiftCoverClient) DeleteOne(ousc *OncallUserShiftCover) *OncallUserShiftCoverDeleteOne {
	return c.DeleteOneID(ousc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallUserShiftCoverClient) DeleteOneID(id uuid.UUID) *OncallUserShiftCoverDeleteOne {
	builder := c.Delete().Where(oncallusershiftcover.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallUserShiftCoverDeleteOne{builder}
}

// Query returns a query builder for OncallUserShiftCover.
func (c *OncallUserShiftCoverClient) Query() *OncallUserShiftCoverQuery {
	return &OncallUserShiftCoverQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallUserShiftCover},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallUserShiftCover entity by its id.
func (c *OncallUserShiftCoverClient) Get(ctx context.Context, id uuid.UUID) (*OncallUserShiftCover, error) {
	return c.Query().Where(oncallusershiftcover.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallUserShiftCoverClient) GetX(ctx context.Context, id uuid.UUID) *OncallUserShiftCover {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a OncallUserShiftCover.
func (c *OncallUserShiftCoverClient) QueryUser(ousc *OncallUserShiftCover) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ousc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershiftcover.Table, oncallusershiftcover.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oncallusershiftcover.UserTable, oncallusershiftcover.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ousc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShift queries the shift edge of a OncallUserShiftCover.
func (c *OncallUserShiftCoverClient) QueryShift(ousc *OncallUserShiftCover) *OncallUserShiftQuery {
	query := (&OncallUserShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ousc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershiftcover.Table, oncallusershiftcover.FieldID, id),
			sqlgraph.To(oncallusershift.Table, oncallusershift.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oncallusershiftcover.ShiftTable, oncallusershiftcover.ShiftColumn),
		)
		fromV = sqlgraph.Neighbors(ousc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallUserShiftCoverClient) Hooks() []Hook {
	return c.hooks.OncallUserShiftCover
}

// Interceptors returns the client interceptors.
func (c *OncallUserShiftCoverClient) Interceptors() []Interceptor {
	return c.inters.OncallUserShiftCover
}

func (c *OncallUserShiftCoverClient) mutate(ctx context.Context, m *OncallUserShiftCoverMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallUserShiftCoverCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallUserShiftCoverUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallUserShiftCoverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallUserShiftCoverDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallUserShiftCover mutation op: %q", m.Op())
	}
}

// OncallUserShiftHandoverClient is a client for the OncallUserShiftHandover schema.
type OncallUserShiftHandoverClient struct {
	config
}

// NewOncallUserShiftHandoverClient returns a client for the OncallUserShiftHandover from the given config.
func NewOncallUserShiftHandoverClient(c config) *OncallUserShiftHandoverClient {
	return &OncallUserShiftHandoverClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oncallusershifthandover.Hooks(f(g(h())))`.
func (c *OncallUserShiftHandoverClient) Use(hooks ...Hook) {
	c.hooks.OncallUserShiftHandover = append(c.hooks.OncallUserShiftHandover, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oncallusershifthandover.Intercept(f(g(h())))`.
func (c *OncallUserShiftHandoverClient) Intercept(interceptors ...Interceptor) {
	c.inters.OncallUserShiftHandover = append(c.inters.OncallUserShiftHandover, interceptors...)
}

// Create returns a builder for creating a OncallUserShiftHandover entity.
func (c *OncallUserShiftHandoverClient) Create() *OncallUserShiftHandoverCreate {
	mutation := newOncallUserShiftHandoverMutation(c.config, OpCreate)
	return &OncallUserShiftHandoverCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OncallUserShiftHandover entities.
func (c *OncallUserShiftHandoverClient) CreateBulk(builders ...*OncallUserShiftHandoverCreate) *OncallUserShiftHandoverCreateBulk {
	return &OncallUserShiftHandoverCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OncallUserShiftHandoverClient) MapCreateBulk(slice any, setFunc func(*OncallUserShiftHandoverCreate, int)) *OncallUserShiftHandoverCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OncallUserShiftHandoverCreateBulk{err: fmt.Errorf("calling to OncallUserShiftHandoverClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OncallUserShiftHandoverCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OncallUserShiftHandoverCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OncallUserShiftHandover.
func (c *OncallUserShiftHandoverClient) Update() *OncallUserShiftHandoverUpdate {
	mutation := newOncallUserShiftHandoverMutation(c.config, OpUpdate)
	return &OncallUserShiftHandoverUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OncallUserShiftHandoverClient) UpdateOne(oush *OncallUserShiftHandover) *OncallUserShiftHandoverUpdateOne {
	mutation := newOncallUserShiftHandoverMutation(c.config, OpUpdateOne, withOncallUserShiftHandover(oush))
	return &OncallUserShiftHandoverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OncallUserShiftHandoverClient) UpdateOneID(id uuid.UUID) *OncallUserShiftHandoverUpdateOne {
	mutation := newOncallUserShiftHandoverMutation(c.config, OpUpdateOne, withOncallUserShiftHandoverID(id))
	return &OncallUserShiftHandoverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OncallUserShiftHandover.
func (c *OncallUserShiftHandoverClient) Delete() *OncallUserShiftHandoverDelete {
	mutation := newOncallUserShiftHandoverMutation(c.config, OpDelete)
	return &OncallUserShiftHandoverDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OncallUserShiftHandoverClient) DeleteOne(oush *OncallUserShiftHandover) *OncallUserShiftHandoverDeleteOne {
	return c.DeleteOneID(oush.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OncallUserShiftHandoverClient) DeleteOneID(id uuid.UUID) *OncallUserShiftHandoverDeleteOne {
	builder := c.Delete().Where(oncallusershifthandover.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OncallUserShiftHandoverDeleteOne{builder}
}

// Query returns a query builder for OncallUserShiftHandover.
func (c *OncallUserShiftHandoverClient) Query() *OncallUserShiftHandoverQuery {
	return &OncallUserShiftHandoverQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOncallUserShiftHandover},
		inters: c.Interceptors(),
	}
}

// Get returns a OncallUserShiftHandover entity by its id.
func (c *OncallUserShiftHandoverClient) Get(ctx context.Context, id uuid.UUID) (*OncallUserShiftHandover, error) {
	return c.Query().Where(oncallusershifthandover.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OncallUserShiftHandoverClient) GetX(ctx context.Context, id uuid.UUID) *OncallUserShiftHandover {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryShift queries the shift edge of a OncallUserShiftHandover.
func (c *OncallUserShiftHandoverClient) QueryShift(oush *OncallUserShiftHandover) *OncallUserShiftQuery {
	query := (&OncallUserShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oush.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oncallusershifthandover.Table, oncallusershifthandover.FieldID, id),
			sqlgraph.To(oncallusershift.Table, oncallusershift.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, oncallusershifthandover.ShiftTable, oncallusershifthandover.ShiftColumn),
		)
		fromV = sqlgraph.Neighbors(oush.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OncallUserShiftHandoverClient) Hooks() []Hook {
	return c.hooks.OncallUserShiftHandover
}

// Interceptors returns the client interceptors.
func (c *OncallUserShiftHandoverClient) Interceptors() []Interceptor {
	return c.inters.OncallUserShiftHandover
}

func (c *OncallUserShiftHandoverClient) mutate(ctx context.Context, m *OncallUserShiftHandoverMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OncallUserShiftHandoverCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OncallUserShiftHandoverUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OncallUserShiftHandoverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OncallUserShiftHandoverDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OncallUserShiftHandover mutation op: %q", m.Op())
	}
}

// ProviderConfigClient is a client for the ProviderConfig schema.
type ProviderConfigClient struct {
	config
}

// NewProviderConfigClient returns a client for the ProviderConfig from the given config.
func NewProviderConfigClient(c config) *ProviderConfigClient {
	return &ProviderConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `providerconfig.Hooks(f(g(h())))`.
func (c *ProviderConfigClient) Use(hooks ...Hook) {
	c.hooks.ProviderConfig = append(c.hooks.ProviderConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `providerconfig.Intercept(f(g(h())))`.
func (c *ProviderConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProviderConfig = append(c.inters.ProviderConfig, interceptors...)
}

// Create returns a builder for creating a ProviderConfig entity.
func (c *ProviderConfigClient) Create() *ProviderConfigCreate {
	mutation := newProviderConfigMutation(c.config, OpCreate)
	return &ProviderConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProviderConfig entities.
func (c *ProviderConfigClient) CreateBulk(builders ...*ProviderConfigCreate) *ProviderConfigCreateBulk {
	return &ProviderConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProviderConfigClient) MapCreateBulk(slice any, setFunc func(*ProviderConfigCreate, int)) *ProviderConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProviderConfigCreateBulk{err: fmt.Errorf("calling to ProviderConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProviderConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProviderConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProviderConfig.
func (c *ProviderConfigClient) Update() *ProviderConfigUpdate {
	mutation := newProviderConfigMutation(c.config, OpUpdate)
	return &ProviderConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProviderConfigClient) UpdateOne(pc *ProviderConfig) *ProviderConfigUpdateOne {
	mutation := newProviderConfigMutation(c.config, OpUpdateOne, withProviderConfig(pc))
	return &ProviderConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProviderConfigClient) UpdateOneID(id uuid.UUID) *ProviderConfigUpdateOne {
	mutation := newProviderConfigMutation(c.config, OpUpdateOne, withProviderConfigID(id))
	return &ProviderConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProviderConfig.
func (c *ProviderConfigClient) Delete() *ProviderConfigDelete {
	mutation := newProviderConfigMutation(c.config, OpDelete)
	return &ProviderConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProviderConfigClient) DeleteOne(pc *ProviderConfig) *ProviderConfigDeleteOne {
	return c.DeleteOneID(pc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProviderConfigClient) DeleteOneID(id uuid.UUID) *ProviderConfigDeleteOne {
	builder := c.Delete().Where(providerconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProviderConfigDeleteOne{builder}
}

// Query returns a query builder for ProviderConfig.
func (c *ProviderConfigClient) Query() *ProviderConfigQuery {
	return &ProviderConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProviderConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a ProviderConfig entity by its id.
func (c *ProviderConfigClient) Get(ctx context.Context, id uuid.UUID) (*ProviderConfig, error) {
	return c.Query().Where(providerconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProviderConfigClient) GetX(ctx context.Context, id uuid.UUID) *ProviderConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProviderConfigClient) Hooks() []Hook {
	return c.hooks.ProviderConfig
}

// Interceptors returns the client interceptors.
func (c *ProviderConfigClient) Interceptors() []Interceptor {
	return c.inters.ProviderConfig
}

func (c *ProviderConfigClient) mutate(ctx context.Context, m *ProviderConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProviderConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProviderConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProviderConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProviderConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProviderConfig mutation op: %q", m.Op())
	}
}

// ProviderSyncHistoryClient is a client for the ProviderSyncHistory schema.
type ProviderSyncHistoryClient struct {
	config
}

// NewProviderSyncHistoryClient returns a client for the ProviderSyncHistory from the given config.
func NewProviderSyncHistoryClient(c config) *ProviderSyncHistoryClient {
	return &ProviderSyncHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `providersynchistory.Hooks(f(g(h())))`.
func (c *ProviderSyncHistoryClient) Use(hooks ...Hook) {
	c.hooks.ProviderSyncHistory = append(c.hooks.ProviderSyncHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `providersynchistory.Intercept(f(g(h())))`.
func (c *ProviderSyncHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProviderSyncHistory = append(c.inters.ProviderSyncHistory, interceptors...)
}

// Create returns a builder for creating a ProviderSyncHistory entity.
func (c *ProviderSyncHistoryClient) Create() *ProviderSyncHistoryCreate {
	mutation := newProviderSyncHistoryMutation(c.config, OpCreate)
	return &ProviderSyncHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProviderSyncHistory entities.
func (c *ProviderSyncHistoryClient) CreateBulk(builders ...*ProviderSyncHistoryCreate) *ProviderSyncHistoryCreateBulk {
	return &ProviderSyncHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProviderSyncHistoryClient) MapCreateBulk(slice any, setFunc func(*ProviderSyncHistoryCreate, int)) *ProviderSyncHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProviderSyncHistoryCreateBulk{err: fmt.Errorf("calling to ProviderSyncHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProviderSyncHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProviderSyncHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProviderSyncHistory.
func (c *ProviderSyncHistoryClient) Update() *ProviderSyncHistoryUpdate {
	mutation := newProviderSyncHistoryMutation(c.config, OpUpdate)
	return &ProviderSyncHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProviderSyncHistoryClient) UpdateOne(psh *ProviderSyncHistory) *ProviderSyncHistoryUpdateOne {
	mutation := newProviderSyncHistoryMutation(c.config, OpUpdateOne, withProviderSyncHistory(psh))
	return &ProviderSyncHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProviderSyncHistoryClient) UpdateOneID(id uuid.UUID) *ProviderSyncHistoryUpdateOne {
	mutation := newProviderSyncHistoryMutation(c.config, OpUpdateOne, withProviderSyncHistoryID(id))
	return &ProviderSyncHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProviderSyncHistory.
func (c *ProviderSyncHistoryClient) Delete() *ProviderSyncHistoryDelete {
	mutation := newProviderSyncHistoryMutation(c.config, OpDelete)
	return &ProviderSyncHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProviderSyncHistoryClient) DeleteOne(psh *ProviderSyncHistory) *ProviderSyncHistoryDeleteOne {
	return c.DeleteOneID(psh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProviderSyncHistoryClient) DeleteOneID(id uuid.UUID) *ProviderSyncHistoryDeleteOne {
	builder := c.Delete().Where(providersynchistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProviderSyncHistoryDeleteOne{builder}
}

// Query returns a query builder for ProviderSyncHistory.
func (c *ProviderSyncHistoryClient) Query() *ProviderSyncHistoryQuery {
	return &ProviderSyncHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProviderSyncHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ProviderSyncHistory entity by its id.
func (c *ProviderSyncHistoryClient) Get(ctx context.Context, id uuid.UUID) (*ProviderSyncHistory, error) {
	return c.Query().Where(providersynchistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProviderSyncHistoryClient) GetX(ctx context.Context, id uuid.UUID) *ProviderSyncHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProviderSyncHistoryClient) Hooks() []Hook {
	return c.hooks.ProviderSyncHistory
}

// Interceptors returns the client interceptors.
func (c *ProviderSyncHistoryClient) Interceptors() []Interceptor {
	return c.inters.ProviderSyncHistory
}

func (c *ProviderSyncHistoryClient) mutate(ctx context.Context, m *ProviderSyncHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProviderSyncHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProviderSyncHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProviderSyncHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProviderSyncHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProviderSyncHistory mutation op: %q", m.Op())
	}
}

// RetrospectiveClient is a client for the Retrospective schema.
type RetrospectiveClient struct {
	config
}

// NewRetrospectiveClient returns a client for the Retrospective from the given config.
func NewRetrospectiveClient(c config) *RetrospectiveClient {
	return &RetrospectiveClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `retrospective.Hooks(f(g(h())))`.
func (c *RetrospectiveClient) Use(hooks ...Hook) {
	c.hooks.Retrospective = append(c.hooks.Retrospective, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `retrospective.Intercept(f(g(h())))`.
func (c *RetrospectiveClient) Intercept(interceptors ...Interceptor) {
	c.inters.Retrospective = append(c.inters.Retrospective, interceptors...)
}

// Create returns a builder for creating a Retrospective entity.
func (c *RetrospectiveClient) Create() *RetrospectiveCreate {
	mutation := newRetrospectiveMutation(c.config, OpCreate)
	return &RetrospectiveCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Retrospective entities.
func (c *RetrospectiveClient) CreateBulk(builders ...*RetrospectiveCreate) *RetrospectiveCreateBulk {
	return &RetrospectiveCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RetrospectiveClient) MapCreateBulk(slice any, setFunc func(*RetrospectiveCreate, int)) *RetrospectiveCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RetrospectiveCreateBulk{err: fmt.Errorf("calling to RetrospectiveClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RetrospectiveCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RetrospectiveCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Retrospective.
func (c *RetrospectiveClient) Update() *RetrospectiveUpdate {
	mutation := newRetrospectiveMutation(c.config, OpUpdate)
	return &RetrospectiveUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RetrospectiveClient) UpdateOne(r *Retrospective) *RetrospectiveUpdateOne {
	mutation := newRetrospectiveMutation(c.config, OpUpdateOne, withRetrospective(r))
	return &RetrospectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RetrospectiveClient) UpdateOneID(id uuid.UUID) *RetrospectiveUpdateOne {
	mutation := newRetrospectiveMutation(c.config, OpUpdateOne, withRetrospectiveID(id))
	return &RetrospectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Retrospective.
func (c *RetrospectiveClient) Delete() *RetrospectiveDelete {
	mutation := newRetrospectiveMutation(c.config, OpDelete)
	return &RetrospectiveDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RetrospectiveClient) DeleteOne(r *Retrospective) *RetrospectiveDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RetrospectiveClient) DeleteOneID(id uuid.UUID) *RetrospectiveDeleteOne {
	builder := c.Delete().Where(retrospective.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RetrospectiveDeleteOne{builder}
}

// Query returns a query builder for Retrospective.
func (c *RetrospectiveClient) Query() *RetrospectiveQuery {
	return &RetrospectiveQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRetrospective},
		inters: c.Interceptors(),
	}
}

// Get returns a Retrospective entity by its id.
func (c *RetrospectiveClient) Get(ctx context.Context, id uuid.UUID) (*Retrospective, error) {
	return c.Query().Where(retrospective.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RetrospectiveClient) GetX(ctx context.Context, id uuid.UUID) *Retrospective {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a Retrospective.
func (c *RetrospectiveClient) QueryIncident(r *Retrospective) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospective.Table, retrospective.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, retrospective.IncidentTable, retrospective.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscussions queries the discussions edge of a Retrospective.
func (c *RetrospectiveClient) QueryDiscussions(r *Retrospective) *RetrospectiveDiscussionQuery {
	query := (&RetrospectiveDiscussionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospective.Table, retrospective.FieldID, id),
			sqlgraph.To(retrospectivediscussion.Table, retrospectivediscussion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, retrospective.DiscussionsTable, retrospective.DiscussionsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RetrospectiveClient) Hooks() []Hook {
	return c.hooks.Retrospective
}

// Interceptors returns the client interceptors.
func (c *RetrospectiveClient) Interceptors() []Interceptor {
	return c.inters.Retrospective
}

func (c *RetrospectiveClient) mutate(ctx context.Context, m *RetrospectiveMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RetrospectiveCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RetrospectiveUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RetrospectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RetrospectiveDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Retrospective mutation op: %q", m.Op())
	}
}

// RetrospectiveDiscussionClient is a client for the RetrospectiveDiscussion schema.
type RetrospectiveDiscussionClient struct {
	config
}

// NewRetrospectiveDiscussionClient returns a client for the RetrospectiveDiscussion from the given config.
func NewRetrospectiveDiscussionClient(c config) *RetrospectiveDiscussionClient {
	return &RetrospectiveDiscussionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `retrospectivediscussion.Hooks(f(g(h())))`.
func (c *RetrospectiveDiscussionClient) Use(hooks ...Hook) {
	c.hooks.RetrospectiveDiscussion = append(c.hooks.RetrospectiveDiscussion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `retrospectivediscussion.Intercept(f(g(h())))`.
func (c *RetrospectiveDiscussionClient) Intercept(interceptors ...Interceptor) {
	c.inters.RetrospectiveDiscussion = append(c.inters.RetrospectiveDiscussion, interceptors...)
}

// Create returns a builder for creating a RetrospectiveDiscussion entity.
func (c *RetrospectiveDiscussionClient) Create() *RetrospectiveDiscussionCreate {
	mutation := newRetrospectiveDiscussionMutation(c.config, OpCreate)
	return &RetrospectiveDiscussionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RetrospectiveDiscussion entities.
func (c *RetrospectiveDiscussionClient) CreateBulk(builders ...*RetrospectiveDiscussionCreate) *RetrospectiveDiscussionCreateBulk {
	return &RetrospectiveDiscussionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RetrospectiveDiscussionClient) MapCreateBulk(slice any, setFunc func(*RetrospectiveDiscussionCreate, int)) *RetrospectiveDiscussionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RetrospectiveDiscussionCreateBulk{err: fmt.Errorf("calling to RetrospectiveDiscussionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RetrospectiveDiscussionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RetrospectiveDiscussionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) Update() *RetrospectiveDiscussionUpdate {
	mutation := newRetrospectiveDiscussionMutation(c.config, OpUpdate)
	return &RetrospectiveDiscussionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RetrospectiveDiscussionClient) UpdateOne(rd *RetrospectiveDiscussion) *RetrospectiveDiscussionUpdateOne {
	mutation := newRetrospectiveDiscussionMutation(c.config, OpUpdateOne, withRetrospectiveDiscussion(rd))
	return &RetrospectiveDiscussionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RetrospectiveDiscussionClient) UpdateOneID(id uuid.UUID) *RetrospectiveDiscussionUpdateOne {
	mutation := newRetrospectiveDiscussionMutation(c.config, OpUpdateOne, withRetrospectiveDiscussionID(id))
	return &RetrospectiveDiscussionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) Delete() *RetrospectiveDiscussionDelete {
	mutation := newRetrospectiveDiscussionMutation(c.config, OpDelete)
	return &RetrospectiveDiscussionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RetrospectiveDiscussionClient) DeleteOne(rd *RetrospectiveDiscussion) *RetrospectiveDiscussionDeleteOne {
	return c.DeleteOneID(rd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RetrospectiveDiscussionClient) DeleteOneID(id uuid.UUID) *RetrospectiveDiscussionDeleteOne {
	builder := c.Delete().Where(retrospectivediscussion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RetrospectiveDiscussionDeleteOne{builder}
}

// Query returns a query builder for RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) Query() *RetrospectiveDiscussionQuery {
	return &RetrospectiveDiscussionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRetrospectiveDiscussion},
		inters: c.Interceptors(),
	}
}

// Get returns a RetrospectiveDiscussion entity by its id.
func (c *RetrospectiveDiscussionClient) Get(ctx context.Context, id uuid.UUID) (*RetrospectiveDiscussion, error) {
	return c.Query().Where(retrospectivediscussion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RetrospectiveDiscussionClient) GetX(ctx context.Context, id uuid.UUID) *RetrospectiveDiscussion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRetrospective queries the retrospective edge of a RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) QueryRetrospective(rd *RetrospectiveDiscussion) *RetrospectiveQuery {
	query := (&RetrospectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussion.Table, retrospectivediscussion.FieldID, id),
			sqlgraph.To(retrospective.Table, retrospective.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivediscussion.RetrospectiveTable, retrospectivediscussion.RetrospectiveColumn),
		)
		fromV = sqlgraph.Neighbors(rd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReplies queries the replies edge of a RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) QueryReplies(rd *RetrospectiveDiscussion) *RetrospectiveDiscussionReplyQuery {
	query := (&RetrospectiveDiscussionReplyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussion.Table, retrospectivediscussion.FieldID, id),
			sqlgraph.To(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, retrospectivediscussion.RepliesTable, retrospectivediscussion.RepliesColumn),
		)
		fromV = sqlgraph.Neighbors(rd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReview queries the review edge of a RetrospectiveDiscussion.
func (c *RetrospectiveDiscussionClient) QueryReview(rd *RetrospectiveDiscussion) *RetrospectiveReviewQuery {
	query := (&RetrospectiveReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussion.Table, retrospectivediscussion.FieldID, id),
			sqlgraph.To(retrospectivereview.Table, retrospectivereview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, retrospectivediscussion.ReviewTable, retrospectivediscussion.ReviewColumn),
		)
		fromV = sqlgraph.Neighbors(rd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RetrospectiveDiscussionClient) Hooks() []Hook {
	return c.hooks.RetrospectiveDiscussion
}

// Interceptors returns the client interceptors.
func (c *RetrospectiveDiscussionClient) Interceptors() []Interceptor {
	return c.inters.RetrospectiveDiscussion
}

func (c *RetrospectiveDiscussionClient) mutate(ctx context.Context, m *RetrospectiveDiscussionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RetrospectiveDiscussionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RetrospectiveDiscussionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RetrospectiveDiscussionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RetrospectiveDiscussionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RetrospectiveDiscussion mutation op: %q", m.Op())
	}
}

// RetrospectiveDiscussionReplyClient is a client for the RetrospectiveDiscussionReply schema.
type RetrospectiveDiscussionReplyClient struct {
	config
}

// NewRetrospectiveDiscussionReplyClient returns a client for the RetrospectiveDiscussionReply from the given config.
func NewRetrospectiveDiscussionReplyClient(c config) *RetrospectiveDiscussionReplyClient {
	return &RetrospectiveDiscussionReplyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `retrospectivediscussionreply.Hooks(f(g(h())))`.
func (c *RetrospectiveDiscussionReplyClient) Use(hooks ...Hook) {
	c.hooks.RetrospectiveDiscussionReply = append(c.hooks.RetrospectiveDiscussionReply, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `retrospectivediscussionreply.Intercept(f(g(h())))`.
func (c *RetrospectiveDiscussionReplyClient) Intercept(interceptors ...Interceptor) {
	c.inters.RetrospectiveDiscussionReply = append(c.inters.RetrospectiveDiscussionReply, interceptors...)
}

// Create returns a builder for creating a RetrospectiveDiscussionReply entity.
func (c *RetrospectiveDiscussionReplyClient) Create() *RetrospectiveDiscussionReplyCreate {
	mutation := newRetrospectiveDiscussionReplyMutation(c.config, OpCreate)
	return &RetrospectiveDiscussionReplyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RetrospectiveDiscussionReply entities.
func (c *RetrospectiveDiscussionReplyClient) CreateBulk(builders ...*RetrospectiveDiscussionReplyCreate) *RetrospectiveDiscussionReplyCreateBulk {
	return &RetrospectiveDiscussionReplyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RetrospectiveDiscussionReplyClient) MapCreateBulk(slice any, setFunc func(*RetrospectiveDiscussionReplyCreate, int)) *RetrospectiveDiscussionReplyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RetrospectiveDiscussionReplyCreateBulk{err: fmt.Errorf("calling to RetrospectiveDiscussionReplyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RetrospectiveDiscussionReplyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RetrospectiveDiscussionReplyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) Update() *RetrospectiveDiscussionReplyUpdate {
	mutation := newRetrospectiveDiscussionReplyMutation(c.config, OpUpdate)
	return &RetrospectiveDiscussionReplyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RetrospectiveDiscussionReplyClient) UpdateOne(rdr *RetrospectiveDiscussionReply) *RetrospectiveDiscussionReplyUpdateOne {
	mutation := newRetrospectiveDiscussionReplyMutation(c.config, OpUpdateOne, withRetrospectiveDiscussionReply(rdr))
	return &RetrospectiveDiscussionReplyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RetrospectiveDiscussionReplyClient) UpdateOneID(id uuid.UUID) *RetrospectiveDiscussionReplyUpdateOne {
	mutation := newRetrospectiveDiscussionReplyMutation(c.config, OpUpdateOne, withRetrospectiveDiscussionReplyID(id))
	return &RetrospectiveDiscussionReplyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) Delete() *RetrospectiveDiscussionReplyDelete {
	mutation := newRetrospectiveDiscussionReplyMutation(c.config, OpDelete)
	return &RetrospectiveDiscussionReplyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RetrospectiveDiscussionReplyClient) DeleteOne(rdr *RetrospectiveDiscussionReply) *RetrospectiveDiscussionReplyDeleteOne {
	return c.DeleteOneID(rdr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RetrospectiveDiscussionReplyClient) DeleteOneID(id uuid.UUID) *RetrospectiveDiscussionReplyDeleteOne {
	builder := c.Delete().Where(retrospectivediscussionreply.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RetrospectiveDiscussionReplyDeleteOne{builder}
}

// Query returns a query builder for RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) Query() *RetrospectiveDiscussionReplyQuery {
	return &RetrospectiveDiscussionReplyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRetrospectiveDiscussionReply},
		inters: c.Interceptors(),
	}
}

// Get returns a RetrospectiveDiscussionReply entity by its id.
func (c *RetrospectiveDiscussionReplyClient) Get(ctx context.Context, id uuid.UUID) (*RetrospectiveDiscussionReply, error) {
	return c.Query().Where(retrospectivediscussionreply.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RetrospectiveDiscussionReplyClient) GetX(ctx context.Context, id uuid.UUID) *RetrospectiveDiscussionReply {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDiscussion queries the discussion edge of a RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) QueryDiscussion(rdr *RetrospectiveDiscussionReply) *RetrospectiveDiscussionQuery {
	query := (&RetrospectiveDiscussionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rdr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID, id),
			sqlgraph.To(retrospectivediscussion.Table, retrospectivediscussion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivediscussionreply.DiscussionTable, retrospectivediscussionreply.DiscussionColumn),
		)
		fromV = sqlgraph.Neighbors(rdr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentReply queries the parent_reply edge of a RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) QueryParentReply(rdr *RetrospectiveDiscussionReply) *RetrospectiveDiscussionReplyQuery {
	query := (&RetrospectiveDiscussionReplyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rdr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID, id),
			sqlgraph.To(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, retrospectivediscussionreply.ParentReplyTable, retrospectivediscussionreply.ParentReplyColumn),
		)
		fromV = sqlgraph.Neighbors(rdr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReplies queries the replies edge of a RetrospectiveDiscussionReply.
func (c *RetrospectiveDiscussionReplyClient) QueryReplies(rdr *RetrospectiveDiscussionReply) *RetrospectiveDiscussionReplyQuery {
	query := (&RetrospectiveDiscussionReplyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rdr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID, id),
			sqlgraph.To(retrospectivediscussionreply.Table, retrospectivediscussionreply.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, retrospectivediscussionreply.RepliesTable, retrospectivediscussionreply.RepliesColumn),
		)
		fromV = sqlgraph.Neighbors(rdr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RetrospectiveDiscussionReplyClient) Hooks() []Hook {
	return c.hooks.RetrospectiveDiscussionReply
}

// Interceptors returns the client interceptors.
func (c *RetrospectiveDiscussionReplyClient) Interceptors() []Interceptor {
	return c.inters.RetrospectiveDiscussionReply
}

func (c *RetrospectiveDiscussionReplyClient) mutate(ctx context.Context, m *RetrospectiveDiscussionReplyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RetrospectiveDiscussionReplyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RetrospectiveDiscussionReplyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RetrospectiveDiscussionReplyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RetrospectiveDiscussionReplyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RetrospectiveDiscussionReply mutation op: %q", m.Op())
	}
}

// RetrospectiveReviewClient is a client for the RetrospectiveReview schema.
type RetrospectiveReviewClient struct {
	config
}

// NewRetrospectiveReviewClient returns a client for the RetrospectiveReview from the given config.
func NewRetrospectiveReviewClient(c config) *RetrospectiveReviewClient {
	return &RetrospectiveReviewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `retrospectivereview.Hooks(f(g(h())))`.
func (c *RetrospectiveReviewClient) Use(hooks ...Hook) {
	c.hooks.RetrospectiveReview = append(c.hooks.RetrospectiveReview, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `retrospectivereview.Intercept(f(g(h())))`.
func (c *RetrospectiveReviewClient) Intercept(interceptors ...Interceptor) {
	c.inters.RetrospectiveReview = append(c.inters.RetrospectiveReview, interceptors...)
}

// Create returns a builder for creating a RetrospectiveReview entity.
func (c *RetrospectiveReviewClient) Create() *RetrospectiveReviewCreate {
	mutation := newRetrospectiveReviewMutation(c.config, OpCreate)
	return &RetrospectiveReviewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RetrospectiveReview entities.
func (c *RetrospectiveReviewClient) CreateBulk(builders ...*RetrospectiveReviewCreate) *RetrospectiveReviewCreateBulk {
	return &RetrospectiveReviewCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RetrospectiveReviewClient) MapCreateBulk(slice any, setFunc func(*RetrospectiveReviewCreate, int)) *RetrospectiveReviewCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RetrospectiveReviewCreateBulk{err: fmt.Errorf("calling to RetrospectiveReviewClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RetrospectiveReviewCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RetrospectiveReviewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RetrospectiveReview.
func (c *RetrospectiveReviewClient) Update() *RetrospectiveReviewUpdate {
	mutation := newRetrospectiveReviewMutation(c.config, OpUpdate)
	return &RetrospectiveReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RetrospectiveReviewClient) UpdateOne(rr *RetrospectiveReview) *RetrospectiveReviewUpdateOne {
	mutation := newRetrospectiveReviewMutation(c.config, OpUpdateOne, withRetrospectiveReview(rr))
	return &RetrospectiveReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RetrospectiveReviewClient) UpdateOneID(id uuid.UUID) *RetrospectiveReviewUpdateOne {
	mutation := newRetrospectiveReviewMutation(c.config, OpUpdateOne, withRetrospectiveReviewID(id))
	return &RetrospectiveReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RetrospectiveReview.
func (c *RetrospectiveReviewClient) Delete() *RetrospectiveReviewDelete {
	mutation := newRetrospectiveReviewMutation(c.config, OpDelete)
	return &RetrospectiveReviewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RetrospectiveReviewClient) DeleteOne(rr *RetrospectiveReview) *RetrospectiveReviewDeleteOne {
	return c.DeleteOneID(rr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RetrospectiveReviewClient) DeleteOneID(id uuid.UUID) *RetrospectiveReviewDeleteOne {
	builder := c.Delete().Where(retrospectivereview.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RetrospectiveReviewDeleteOne{builder}
}

// Query returns a query builder for RetrospectiveReview.
func (c *RetrospectiveReviewClient) Query() *RetrospectiveReviewQuery {
	return &RetrospectiveReviewQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRetrospectiveReview},
		inters: c.Interceptors(),
	}
}

// Get returns a RetrospectiveReview entity by its id.
func (c *RetrospectiveReviewClient) Get(ctx context.Context, id uuid.UUID) (*RetrospectiveReview, error) {
	return c.Query().Where(retrospectivereview.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RetrospectiveReviewClient) GetX(ctx context.Context, id uuid.UUID) *RetrospectiveReview {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRetrospective queries the retrospective edge of a RetrospectiveReview.
func (c *RetrospectiveReviewClient) QueryRetrospective(rr *RetrospectiveReview) *RetrospectiveQuery {
	query := (&RetrospectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivereview.Table, retrospectivereview.FieldID, id),
			sqlgraph.To(retrospective.Table, retrospective.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivereview.RetrospectiveTable, retrospectivereview.RetrospectiveColumn),
		)
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRequester queries the requester edge of a RetrospectiveReview.
func (c *RetrospectiveReviewClient) QueryRequester(rr *RetrospectiveReview) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivereview.Table, retrospectivereview.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivereview.RequesterTable, retrospectivereview.RequesterColumn),
		)
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviewer queries the reviewer edge of a RetrospectiveReview.
func (c *RetrospectiveReviewClient) QueryReviewer(rr *RetrospectiveReview) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivereview.Table, retrospectivereview.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivereview.ReviewerTable, retrospectivereview.ReviewerColumn),
		)
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscussion queries the discussion edge of a RetrospectiveReview.
func (c *RetrospectiveReviewClient) QueryDiscussion(rr *RetrospectiveReview) *RetrospectiveDiscussionQuery {
	query := (&RetrospectiveDiscussionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(retrospectivereview.Table, retrospectivereview.FieldID, id),
			sqlgraph.To(retrospectivediscussion.Table, retrospectivediscussion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, retrospectivereview.DiscussionTable, retrospectivereview.DiscussionColumn),
		)
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RetrospectiveReviewClient) Hooks() []Hook {
	return c.hooks.RetrospectiveReview
}

// Interceptors returns the client interceptors.
func (c *RetrospectiveReviewClient) Interceptors() []Interceptor {
	return c.inters.RetrospectiveReview
}

func (c *RetrospectiveReviewClient) mutate(ctx context.Context, m *RetrospectiveReviewMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RetrospectiveReviewCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RetrospectiveReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RetrospectiveReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RetrospectiveReviewDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RetrospectiveReview mutation op: %q", m.Op())
	}
}

// ServiceClient is a client for the Service schema.
type ServiceClient struct {
	config
}

// NewServiceClient returns a client for the Service from the given config.
func NewServiceClient(c config) *ServiceClient {
	return &ServiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `service.Hooks(f(g(h())))`.
func (c *ServiceClient) Use(hooks ...Hook) {
	c.hooks.Service = append(c.hooks.Service, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `service.Intercept(f(g(h())))`.
func (c *ServiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Service = append(c.inters.Service, interceptors...)
}

// Create returns a builder for creating a Service entity.
func (c *ServiceClient) Create() *ServiceCreate {
	mutation := newServiceMutation(c.config, OpCreate)
	return &ServiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Service entities.
func (c *ServiceClient) CreateBulk(builders ...*ServiceCreate) *ServiceCreateBulk {
	return &ServiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceClient) MapCreateBulk(slice any, setFunc func(*ServiceCreate, int)) *ServiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceCreateBulk{err: fmt.Errorf("calling to ServiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Service.
func (c *ServiceClient) Update() *ServiceUpdate {
	mutation := newServiceMutation(c.config, OpUpdate)
	return &ServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceClient) UpdateOne(s *Service) *ServiceUpdateOne {
	mutation := newServiceMutation(c.config, OpUpdateOne, withService(s))
	return &ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceClient) UpdateOneID(id uuid.UUID) *ServiceUpdateOne {
	mutation := newServiceMutation(c.config, OpUpdateOne, withServiceID(id))
	return &ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Service.
func (c *ServiceClient) Delete() *ServiceDelete {
	mutation := newServiceMutation(c.config, OpDelete)
	return &ServiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceClient) DeleteOne(s *Service) *ServiceDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceClient) DeleteOneID(id uuid.UUID) *ServiceDeleteOne {
	builder := c.Delete().Where(service.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceDeleteOne{builder}
}

// Query returns a query builder for Service.
func (c *ServiceClient) Query() *ServiceQuery {
	return &ServiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeService},
		inters: c.Interceptors(),
	}
}

// Get returns a Service entity by its id.
func (c *ServiceClient) Get(ctx context.Context, id uuid.UUID) (*Service, error) {
	return c.Query().Where(service.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceClient) GetX(ctx context.Context, id uuid.UUID) *Service {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncidents queries the incidents edge of a Service.
func (c *ServiceClient) QueryIncidents(s *Service) *IncidentResourceImpactQuery {
	query := (&IncidentResourceImpactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(incidentresourceimpact.Table, incidentresourceimpact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, service.IncidentsTable, service.IncidentsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnerTeam queries the owner_team edge of a Service.
func (c *ServiceClient) QueryOwnerTeam(s *Service) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, service.OwnerTeamTable, service.OwnerTeamColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceClient) Hooks() []Hook {
	return c.hooks.Service
}

// Interceptors returns the client interceptors.
func (c *ServiceClient) Interceptors() []Interceptor {
	return c.inters.Service
}

func (c *ServiceClient) mutate(ctx context.Context, m *ServiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Service mutation op: %q", m.Op())
	}
}

// SubscriptionClient is a client for the Subscription schema.
type SubscriptionClient struct {
	config
}

// NewSubscriptionClient returns a client for the Subscription from the given config.
func NewSubscriptionClient(c config) *SubscriptionClient {
	return &SubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscription.Hooks(f(g(h())))`.
func (c *SubscriptionClient) Use(hooks ...Hook) {
	c.hooks.Subscription = append(c.hooks.Subscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscription.Intercept(f(g(h())))`.
func (c *SubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subscription = append(c.inters.Subscription, interceptors...)
}

// Create returns a builder for creating a Subscription entity.
func (c *SubscriptionClient) Create() *SubscriptionCreate {
	mutation := newSubscriptionMutation(c.config, OpCreate)
	return &SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subscription entities.
func (c *SubscriptionClient) CreateBulk(builders ...*SubscriptionCreate) *SubscriptionCreateBulk {
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriptionClient) MapCreateBulk(slice any, setFunc func(*SubscriptionCreate, int)) *SubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriptionCreateBulk{err: fmt.Errorf("calling to SubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subscription.
func (c *SubscriptionClient) Update() *SubscriptionUpdate {
	mutation := newSubscriptionMutation(c.config, OpUpdate)
	return &SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriptionClient) UpdateOne(s *Subscription) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscription(s))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriptionClient) UpdateOneID(id uuid.UUID) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscriptionID(id))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subscription.
func (c *SubscriptionClient) Delete() *SubscriptionDelete {
	mutation := newSubscriptionMutation(c.config, OpDelete)
	return &SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriptionClient) DeleteOne(s *Subscription) *SubscriptionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriptionClient) DeleteOneID(id uuid.UUID) *SubscriptionDeleteOne {
	builder := c.Delete().Where(subscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriptionDeleteOne{builder}
}

// Query returns a query builder for Subscription.
func (c *SubscriptionClient) Query() *SubscriptionQuery {
	return &SubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a Subscription entity by its id.
func (c *SubscriptionClient) Get(ctx context.Context, id uuid.UUID) (*Subscription, error) {
	return c.Query().Where(subscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriptionClient) GetX(ctx context.Context, id uuid.UUID) *Subscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Subscription.
func (c *SubscriptionClient) QueryUser(s *Subscription) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subscription.UserTable, subscription.UserColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a Subscription.
func (c *SubscriptionClient) QueryTeam(s *Subscription) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subscription.TeamTable, subscription.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncident queries the incident edge of a Subscription.
func (c *SubscriptionClient) QueryIncident(s *Subscription) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subscription.IncidentTable, subscription.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubscriptionClient) Hooks() []Hook {
	return c.hooks.Subscription
}

// Interceptors returns the client interceptors.
func (c *SubscriptionClient) Interceptors() []Interceptor {
	return c.inters.Subscription
}

func (c *SubscriptionClient) mutate(ctx context.Context, m *SubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Subscription mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id uuid.UUID) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id uuid.UUID) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id uuid.UUID) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id uuid.UUID) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a Task.
func (c *TaskClient) QueryIncident(t *Task) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.IncidentTable, task.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignee queries the assignee edge of a Task.
func (c *TaskClient) QueryAssignee(t *Task) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.AssigneeTable, task.AssigneeColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a Task.
func (c *TaskClient) QueryCreator(t *Task) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.CreatorTable, task.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	return c.hooks.Task
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	return c.inters.Task
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// TeamClient is a client for the Team schema.
type TeamClient struct {
	config
}

// NewTeamClient returns a client for the Team from the given config.
func NewTeamClient(c config) *TeamClient {
	return &TeamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `team.Hooks(f(g(h())))`.
func (c *TeamClient) Use(hooks ...Hook) {
	c.hooks.Team = append(c.hooks.Team, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `team.Intercept(f(g(h())))`.
func (c *TeamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Team = append(c.inters.Team, interceptors...)
}

// Create returns a builder for creating a Team entity.
func (c *TeamClient) Create() *TeamCreate {
	mutation := newTeamMutation(c.config, OpCreate)
	return &TeamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Team entities.
func (c *TeamClient) CreateBulk(builders ...*TeamCreate) *TeamCreateBulk {
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamClient) MapCreateBulk(slice any, setFunc func(*TeamCreate, int)) *TeamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamCreateBulk{err: fmt.Errorf("calling to TeamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Team.
func (c *TeamClient) Update() *TeamUpdate {
	mutation := newTeamMutation(c.config, OpUpdate)
	return &TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamClient) UpdateOne(t *Team) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeam(t))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamClient) UpdateOneID(id uuid.UUID) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeamID(id))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Team.
func (c *TeamClient) Delete() *TeamDelete {
	mutation := newTeamMutation(c.config, OpDelete)
	return &TeamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamClient) DeleteOne(t *Team) *TeamDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamClient) DeleteOneID(id uuid.UUID) *TeamDeleteOne {
	builder := c.Delete().Where(team.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamDeleteOne{builder}
}

// Query returns a query builder for Team.
func (c *TeamClient) Query() *TeamQuery {
	return &TeamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeam},
		inters: c.Interceptors(),
	}
}

// Get returns a Team entity by its id.
func (c *TeamClient) Get(ctx context.Context, id uuid.UUID) (*Team, error) {
	return c.Query().Where(team.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamClient) GetX(ctx context.Context, id uuid.UUID) *Team {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Team.
func (c *TeamClient) QueryUsers(t *Team) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, team.UsersTable, team.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServices queries the services edge of a Team.
func (c *TeamClient) QueryServices(t *Team) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, team.ServicesTable, team.ServicesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOncallRosters queries the oncall_rosters edge of a Team.
func (c *TeamClient) QueryOncallRosters(t *Team) *OncallRosterQuery {
	query := (&OncallRosterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(oncallroster.Table, oncallroster.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, team.OncallRostersTable, team.OncallRostersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a Team.
func (c *TeamClient) QuerySubscriptions(t *Team) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, team.SubscriptionsTable, team.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentAssignments queries the incident_assignments edge of a Team.
func (c *TeamClient) QueryIncidentAssignments(t *Team) *IncidentTeamAssignmentQuery {
	query := (&IncidentTeamAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(incidentteamassignment.Table, incidentteamassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, team.IncidentAssignmentsTable, team.IncidentAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledMeetings queries the scheduled_meetings edge of a Team.
func (c *TeamClient) QueryScheduledMeetings(t *Team) *MeetingScheduleQuery {
	query := (&MeetingScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(meetingschedule.Table, meetingschedule.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, team.ScheduledMeetingsTable, team.ScheduledMeetingsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamClient) Hooks() []Hook {
	return c.hooks.Team
}

// Interceptors returns the client interceptors.
func (c *TeamClient) Interceptors() []Interceptor {
	return c.inters.Team
}

func (c *TeamClient) mutate(ctx context.Context, m *TeamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Team mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeams queries the teams edge of a User.
func (c *UserClient) QueryTeams(u *User) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.TeamsTable, user.TeamsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOncallSchedules queries the oncall_schedules edge of a User.
func (c *UserClient) QueryOncallSchedules(u *User) *OncallScheduleParticipantQuery {
	query := (&OncallScheduleParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(oncallscheduleparticipant.Table, oncallscheduleparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.OncallSchedulesTable, user.OncallSchedulesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOncallShifts queries the oncall_shifts edge of a User.
func (c *UserClient) QueryOncallShifts(u *User) *OncallUserShiftQuery {
	query := (&OncallUserShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(oncallusershift.Table, oncallusershift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.OncallShiftsTable, user.OncallShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOncallShiftCovers queries the oncall_shift_covers edge of a User.
func (c *UserClient) QueryOncallShiftCovers(u *User) *OncallUserShiftCoverQuery {
	query := (&OncallUserShiftCoverClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(oncallusershiftcover.Table, oncallusershiftcover.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.OncallShiftCoversTable, user.OncallShiftCoversColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlertsReceived queries the alerts_received edge of a User.
func (c *UserClient) QueryAlertsReceived(u *User) *OncallAlertInstanceQuery {
	query := (&OncallAlertInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(oncallalertinstance.Table, oncallalertinstance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.AlertsReceivedTable, user.AlertsReceivedColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a User.
func (c *UserClient) QuerySubscriptions(u *User) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.SubscriptionsTable, user.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentRoleAssignments queries the incident_role_assignments edge of a User.
func (c *UserClient) QueryIncidentRoleAssignments(u *User) *IncidentRoleAssignmentQuery {
	query := (&IncidentRoleAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(incidentroleassignment.Table, incidentroleassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.IncidentRoleAssignmentsTable, user.IncidentRoleAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidentDebriefs queries the incident_debriefs edge of a User.
func (c *UserClient) QueryIncidentDebriefs(u *User) *IncidentDebriefQuery {
	query := (&IncidentDebriefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(incidentdebrief.Table, incidentdebrief.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.IncidentDebriefsTable, user.IncidentDebriefsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedTasks queries the assigned_tasks edge of a User.
func (c *UserClient) QueryAssignedTasks(u *User) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssignedTasksTable, user.AssignedTasksColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedTasks queries the created_tasks edge of a User.
func (c *UserClient) QueryCreatedTasks(u *User) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedTasksTable, user.CreatedTasksColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRetrospectiveReviewRequests queries the retrospective_review_requests edge of a User.
func (c *UserClient) QueryRetrospectiveReviewRequests(u *User) *RetrospectiveReviewQuery {
	query := (&RetrospectiveReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(retrospectivereview.Table, retrospectivereview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.RetrospectiveReviewRequestsTable, user.RetrospectiveReviewRequestsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRetrospectiveReviewResponses queries the retrospective_review_responses edge of a User.
func (c *UserClient) QueryRetrospectiveReviewResponses(u *User) *RetrospectiveReviewQuery {
	query := (&RetrospectiveReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(retrospectivereview.Table, retrospectivereview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.RetrospectiveReviewResponsesTable, user.RetrospectiveReviewResponsesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Environment, Functionality, Incident, IncidentDebrief, IncidentDebriefMessage,
		IncidentDebriefQuestion, IncidentDebriefSuggestion, IncidentEvent,
		IncidentField, IncidentFieldOption, IncidentLink, IncidentResourceImpact,
		IncidentRole, IncidentRoleAssignment, IncidentSeverity, IncidentTag,
		IncidentTeamAssignment, IncidentType, MeetingSchedule, MeetingSession,
		OncallAlert, OncallAlertInstance, OncallHandoverTemplate, OncallRoster,
		OncallSchedule, OncallScheduleParticipant, OncallUserShift,
		OncallUserShiftAnnotation, OncallUserShiftCover, OncallUserShiftHandover,
		ProviderConfig, ProviderSyncHistory, Retrospective, RetrospectiveDiscussion,
		RetrospectiveDiscussionReply, RetrospectiveReview, Service, Subscription, Task,
		Team, User []ent.Hook
	}
	inters struct {
		Environment, Functionality, Incident, IncidentDebrief, IncidentDebriefMessage,
		IncidentDebriefQuestion, IncidentDebriefSuggestion, IncidentEvent,
		IncidentField, IncidentFieldOption, IncidentLink, IncidentResourceImpact,
		IncidentRole, IncidentRoleAssignment, IncidentSeverity, IncidentTag,
		IncidentTeamAssignment, IncidentType, MeetingSchedule, MeetingSession,
		OncallAlert, OncallAlertInstance, OncallHandoverTemplate, OncallRoster,
		OncallSchedule, OncallScheduleParticipant, OncallUserShift,
		OncallUserShiftAnnotation, OncallUserShiftCover, OncallUserShiftHandover,
		ProviderConfig, ProviderSyncHistory, Retrospective, RetrospectiveDiscussion,
		RetrospectiveDiscussionReply, RetrospectiveReview, Service, Subscription, Task,
		Team, User []ent.Interceptor
	}
)
