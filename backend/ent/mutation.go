// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/rezible/rezible/ent/environment"
	"github.com/rezible/rezible/ent/functionality"
	"github.com/rezible/rezible/ent/incident"
	"github.com/rezible/rezible/ent/incidentdebrief"
	"github.com/rezible/rezible/ent/incidentdebriefmessage"
	"github.com/rezible/rezible/ent/incidentdebriefquestion"
	"github.com/rezible/rezible/ent/incidentdebriefsuggestion"
	"github.com/rezible/rezible/ent/incidentevent"
	"github.com/rezible/rezible/ent/incidenteventcontext"
	"github.com/rezible/rezible/ent/incidenteventcontributingfactor"
	"github.com/rezible/rezible/ent/incidenteventevidence"
	"github.com/rezible/rezible/ent/incidentfield"
	"github.com/rezible/rezible/ent/incidentfieldoption"
	"github.com/rezible/rezible/ent/incidentlink"
	"github.com/rezible/rezible/ent/incidentmilestone"
	"github.com/rezible/rezible/ent/incidentrole"
	"github.com/rezible/rezible/ent/incidentroleassignment"
	"github.com/rezible/rezible/ent/incidentseverity"
	"github.com/rezible/rezible/ent/incidenttag"
	"github.com/rezible/rezible/ent/incidentteamassignment"
	"github.com/rezible/rezible/ent/incidenttype"
	"github.com/rezible/rezible/ent/meetingschedule"
	"github.com/rezible/rezible/ent/meetingsession"
	"github.com/rezible/rezible/ent/oncallalert"
	"github.com/rezible/rezible/ent/oncallalertinstance"
	"github.com/rezible/rezible/ent/oncallhandovertemplate"
	"github.com/rezible/rezible/ent/oncallroster"
	"github.com/rezible/rezible/ent/oncallschedule"
	"github.com/rezible/rezible/ent/oncallscheduleparticipant"
	"github.com/rezible/rezible/ent/oncallusershift"
	"github.com/rezible/rezible/ent/oncallusershiftannotation"
	"github.com/rezible/rezible/ent/oncallusershiftcover"
	"github.com/rezible/rezible/ent/oncallusershifthandover"
	"github.com/rezible/rezible/ent/predicate"
	"github.com/rezible/rezible/ent/providerconfig"
	"github.com/rezible/rezible/ent/providersynchistory"
	"github.com/rezible/rezible/ent/retrospective"
	"github.com/rezible/rezible/ent/retrospectivediscussion"
	"github.com/rezible/rezible/ent/retrospectivediscussionreply"
	"github.com/rezible/rezible/ent/retrospectivereview"
	"github.com/rezible/rezible/ent/systemcomponent"
	"github.com/rezible/rezible/ent/systemcomponentcontrolrelationship"
	"github.com/rezible/rezible/ent/systemcomponentfeedbackrelationship"
	"github.com/rezible/rezible/ent/task"
	"github.com/rezible/rezible/ent/team"
	"github.com/rezible/rezible/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEnvironment                         = "Environment"
	TypeFunctionality                       = "Functionality"
	TypeIncident                            = "Incident"
	TypeIncidentDebrief                     = "IncidentDebrief"
	TypeIncidentDebriefMessage              = "IncidentDebriefMessage"
	TypeIncidentDebriefQuestion             = "IncidentDebriefQuestion"
	TypeIncidentDebriefSuggestion           = "IncidentDebriefSuggestion"
	TypeIncidentEvent                       = "IncidentEvent"
	TypeIncidentEventContext                = "IncidentEventContext"
	TypeIncidentEventContributingFactor     = "IncidentEventContributingFactor"
	TypeIncidentEventEvidence               = "IncidentEventEvidence"
	TypeIncidentField                       = "IncidentField"
	TypeIncidentFieldOption                 = "IncidentFieldOption"
	TypeIncidentLink                        = "IncidentLink"
	TypeIncidentMilestone                   = "IncidentMilestone"
	TypeIncidentRole                        = "IncidentRole"
	TypeIncidentRoleAssignment              = "IncidentRoleAssignment"
	TypeIncidentSeverity                    = "IncidentSeverity"
	TypeIncidentTag                         = "IncidentTag"
	TypeIncidentTeamAssignment              = "IncidentTeamAssignment"
	TypeIncidentType                        = "IncidentType"
	TypeMeetingSchedule                     = "MeetingSchedule"
	TypeMeetingSession                      = "MeetingSession"
	TypeOncallAlert                         = "OncallAlert"
	TypeOncallAlertInstance                 = "OncallAlertInstance"
	TypeOncallHandoverTemplate              = "OncallHandoverTemplate"
	TypeOncallRoster                        = "OncallRoster"
	TypeOncallSchedule                      = "OncallSchedule"
	TypeOncallScheduleParticipant           = "OncallScheduleParticipant"
	TypeOncallUserShift                     = "OncallUserShift"
	TypeOncallUserShiftAnnotation           = "OncallUserShiftAnnotation"
	TypeOncallUserShiftCover                = "OncallUserShiftCover"
	TypeOncallUserShiftHandover             = "OncallUserShiftHandover"
	TypeProviderConfig                      = "ProviderConfig"
	TypeProviderSyncHistory                 = "ProviderSyncHistory"
	TypeRetrospective                       = "Retrospective"
	TypeRetrospectiveDiscussion             = "RetrospectiveDiscussion"
	TypeRetrospectiveDiscussionReply        = "RetrospectiveDiscussionReply"
	TypeRetrospectiveReview                 = "RetrospectiveReview"
	TypeSystemComponent                     = "SystemComponent"
	TypeSystemComponentControlRelationship  = "SystemComponentControlRelationship"
	TypeSystemComponentFeedbackRelationship = "SystemComponentFeedbackRelationship"
	TypeTask                                = "Task"
	TypeTeam                                = "Team"
	TypeUser                                = "User"
)

// EnvironmentMutation represents an operation that mutates the Environment nodes in the graph.
type EnvironmentMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	archive_time     *time.Time
	name             *string
	clearedFields    map[string]struct{}
	incidents        map[uuid.UUID]struct{}
	removedincidents map[uuid.UUID]struct{}
	clearedincidents bool
	done             bool
	oldValue         func(context.Context) (*Environment, error)
	predicates       []predicate.Environment
}

var _ ent.Mutation = (*EnvironmentMutation)(nil)

// environmentOption allows management of the mutation configuration using functional options.
type environmentOption func(*EnvironmentMutation)

// newEnvironmentMutation creates new mutation for the Environment entity.
func newEnvironmentMutation(c config, op Op, opts ...environmentOption) *EnvironmentMutation {
	m := &EnvironmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvironmentID sets the ID field of the mutation.
func withEnvironmentID(id uuid.UUID) environmentOption {
	return func(m *EnvironmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Environment
		)
		m.oldValue = func(ctx context.Context) (*Environment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Environment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvironment sets the old Environment of the mutation.
func withEnvironment(node *Environment) environmentOption {
	return func(m *EnvironmentMutation) {
		m.oldValue = func(context.Context) (*Environment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Environment entities.
func (m *EnvironmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvironmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvironmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Environment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchiveTime sets the "archive_time" field.
func (m *EnvironmentMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *EnvironmentMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *EnvironmentMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[environment.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *EnvironmentMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[environment.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *EnvironmentMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, environment.FieldArchiveTime)
}

// SetName sets the "name" field.
func (m *EnvironmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnvironmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnvironmentMutation) ResetName() {
	m.name = nil
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *EnvironmentMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *EnvironmentMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *EnvironmentMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *EnvironmentMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *EnvironmentMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *EnvironmentMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *EnvironmentMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// Where appends a list predicates to the EnvironmentMutation builder.
func (m *EnvironmentMutation) Where(ps ...predicate.Environment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvironmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvironmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Environment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvironmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvironmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Environment).
func (m *EnvironmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvironmentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.archive_time != nil {
		fields = append(fields, environment.FieldArchiveTime)
	}
	if m.name != nil {
		fields = append(fields, environment.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvironmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldArchiveTime:
		return m.ArchiveTime()
	case environment.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvironmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case environment.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case environment.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Environment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environment.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case environment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvironmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvironmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Environment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvironmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(environment.FieldArchiveTime) {
		fields = append(fields, environment.FieldArchiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvironmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentMutation) ClearField(name string) error {
	switch name {
	case environment.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown Environment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvironmentMutation) ResetField(name string) error {
	switch name {
	case environment.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case environment.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvironmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.incidents != nil {
		edges = append(edges, environment.EdgeIncidents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvironmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvironmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedincidents != nil {
		edges = append(edges, environment.EdgeIncidents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvironmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvironmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedincidents {
		edges = append(edges, environment.EdgeIncidents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvironmentMutation) EdgeCleared(name string) bool {
	switch name {
	case environment.EdgeIncidents:
		return m.clearedincidents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvironmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Environment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvironmentMutation) ResetEdge(name string) error {
	switch name {
	case environment.EdgeIncidents:
		m.ResetIncidents()
		return nil
	}
	return fmt.Errorf("unknown Environment edge %s", name)
}

// FunctionalityMutation represents an operation that mutates the Functionality nodes in the graph.
type FunctionalityMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Functionality, error)
	predicates    []predicate.Functionality
}

var _ ent.Mutation = (*FunctionalityMutation)(nil)

// functionalityOption allows management of the mutation configuration using functional options.
type functionalityOption func(*FunctionalityMutation)

// newFunctionalityMutation creates new mutation for the Functionality entity.
func newFunctionalityMutation(c config, op Op, opts ...functionalityOption) *FunctionalityMutation {
	m := &FunctionalityMutation{
		config:        c,
		op:            op,
		typ:           TypeFunctionality,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFunctionalityID sets the ID field of the mutation.
func withFunctionalityID(id uuid.UUID) functionalityOption {
	return func(m *FunctionalityMutation) {
		var (
			err   error
			once  sync.Once
			value *Functionality
		)
		m.oldValue = func(ctx context.Context) (*Functionality, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Functionality.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFunctionality sets the old Functionality of the mutation.
func withFunctionality(node *Functionality) functionalityOption {
	return func(m *FunctionalityMutation) {
		m.oldValue = func(context.Context) (*Functionality, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FunctionalityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FunctionalityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Functionality entities.
func (m *FunctionalityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FunctionalityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FunctionalityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Functionality.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FunctionalityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FunctionalityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Functionality entity.
// If the Functionality object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FunctionalityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FunctionalityMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the FunctionalityMutation builder.
func (m *FunctionalityMutation) Where(ps ...predicate.Functionality) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FunctionalityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FunctionalityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Functionality, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FunctionalityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FunctionalityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Functionality).
func (m *FunctionalityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FunctionalityMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, functionality.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FunctionalityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case functionality.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FunctionalityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case functionality.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Functionality field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FunctionalityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case functionality.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Functionality field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FunctionalityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FunctionalityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FunctionalityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Functionality numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FunctionalityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FunctionalityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FunctionalityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Functionality nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FunctionalityMutation) ResetField(name string) error {
	switch name {
	case functionality.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Functionality field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FunctionalityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FunctionalityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FunctionalityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FunctionalityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FunctionalityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FunctionalityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FunctionalityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Functionality unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FunctionalityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Functionality edge %s", name)
}

// IncidentMutation represents an operation that mutates the Incident nodes in the graph.
type IncidentMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	slug                    *string
	title                   *string
	private                 *bool
	summary                 *string
	opened_at               *time.Time
	modified_at             *time.Time
	closed_at               *time.Time
	provider_id             *string
	chat_channel_id         *string
	clearedFields           map[string]struct{}
	environments            map[uuid.UUID]struct{}
	removedenvironments     map[uuid.UUID]struct{}
	clearedenvironments     bool
	severity                *uuid.UUID
	clearedseverity         bool
	_type                   *uuid.UUID
	cleared_type            bool
	team_assignments        map[int]struct{}
	removedteam_assignments map[int]struct{}
	clearedteam_assignments bool
	role_assignments        map[uuid.UUID]struct{}
	removedrole_assignments map[uuid.UUID]struct{}
	clearedrole_assignments bool
	linked_incidents        map[uuid.UUID]struct{}
	removedlinked_incidents map[uuid.UUID]struct{}
	clearedlinked_incidents bool
	retrospective           *uuid.UUID
	clearedretrospective    bool
	milestones              map[uuid.UUID]struct{}
	removedmilestones       map[uuid.UUID]struct{}
	clearedmilestones       bool
	events                  map[uuid.UUID]struct{}
	removedevents           map[uuid.UUID]struct{}
	clearedevents           bool
	field_selections        map[uuid.UUID]struct{}
	removedfield_selections map[uuid.UUID]struct{}
	clearedfield_selections bool
	tasks                   map[uuid.UUID]struct{}
	removedtasks            map[uuid.UUID]struct{}
	clearedtasks            bool
	tag_assignments         map[uuid.UUID]struct{}
	removedtag_assignments  map[uuid.UUID]struct{}
	clearedtag_assignments  bool
	debriefs                map[uuid.UUID]struct{}
	removeddebriefs         map[uuid.UUID]struct{}
	cleareddebriefs         bool
	review_sessions         map[uuid.UUID]struct{}
	removedreview_sessions  map[uuid.UUID]struct{}
	clearedreview_sessions  bool
	incident_links          map[int]struct{}
	removedincident_links   map[int]struct{}
	clearedincident_links   bool
	done                    bool
	oldValue                func(context.Context) (*Incident, error)
	predicates              []predicate.Incident
}

var _ ent.Mutation = (*IncidentMutation)(nil)

// incidentOption allows management of the mutation configuration using functional options.
type incidentOption func(*IncidentMutation)

// newIncidentMutation creates new mutation for the Incident entity.
func newIncidentMutation(c config, op Op, opts ...incidentOption) *IncidentMutation {
	m := &IncidentMutation{
		config:        c,
		op:            op,
		typ:           TypeIncident,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentID sets the ID field of the mutation.
func withIncidentID(id uuid.UUID) incidentOption {
	return func(m *IncidentMutation) {
		var (
			err   error
			once  sync.Once
			value *Incident
		)
		m.oldValue = func(ctx context.Context) (*Incident, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Incident.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncident sets the old Incident of the mutation.
func withIncident(node *Incident) incidentOption {
	return func(m *IncidentMutation) {
		m.oldValue = func(context.Context) (*Incident, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Incident entities.
func (m *IncidentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Incident.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *IncidentMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *IncidentMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *IncidentMutation) ResetSlug() {
	m.slug = nil
}

// SetTitle sets the "title" field.
func (m *IncidentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IncidentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IncidentMutation) ResetTitle() {
	m.title = nil
}

// SetPrivate sets the "private" field.
func (m *IncidentMutation) SetPrivate(b bool) {
	m.private = &b
}

// Private returns the value of the "private" field in the mutation.
func (m *IncidentMutation) Private() (r bool, exists bool) {
	v := m.private
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivate returns the old "private" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivate: %w", err)
	}
	return oldValue.Private, nil
}

// ResetPrivate resets all changes to the "private" field.
func (m *IncidentMutation) ResetPrivate() {
	m.private = nil
}

// SetSummary sets the "summary" field.
func (m *IncidentMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *IncidentMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ResetSummary resets all changes to the "summary" field.
func (m *IncidentMutation) ResetSummary() {
	m.summary = nil
}

// SetOpenedAt sets the "opened_at" field.
func (m *IncidentMutation) SetOpenedAt(t time.Time) {
	m.opened_at = &t
}

// OpenedAt returns the value of the "opened_at" field in the mutation.
func (m *IncidentMutation) OpenedAt() (r time.Time, exists bool) {
	v := m.opened_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenedAt returns the old "opened_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldOpenedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenedAt: %w", err)
	}
	return oldValue.OpenedAt, nil
}

// ResetOpenedAt resets all changes to the "opened_at" field.
func (m *IncidentMutation) ResetOpenedAt() {
	m.opened_at = nil
}

// SetModifiedAt sets the "modified_at" field.
func (m *IncidentMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the value of the "modified_at" field in the mutation.
func (m *IncidentMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedAt returns the old "modified_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldModifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedAt: %w", err)
	}
	return oldValue.ModifiedAt, nil
}

// ResetModifiedAt resets all changes to the "modified_at" field.
func (m *IncidentMutation) ResetModifiedAt() {
	m.modified_at = nil
}

// SetClosedAt sets the "closed_at" field.
func (m *IncidentMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *IncidentMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldClosedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *IncidentMutation) ResetClosedAt() {
	m.closed_at = nil
}

// SetProviderID sets the "provider_id" field.
func (m *IncidentMutation) SetProviderID(s string) {
	m.provider_id = &s
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *IncidentMutation) ProviderID() (r string, exists bool) {
	v := m.provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *IncidentMutation) ResetProviderID() {
	m.provider_id = nil
}

// SetChatChannelID sets the "chat_channel_id" field.
func (m *IncidentMutation) SetChatChannelID(s string) {
	m.chat_channel_id = &s
}

// ChatChannelID returns the value of the "chat_channel_id" field in the mutation.
func (m *IncidentMutation) ChatChannelID() (r string, exists bool) {
	v := m.chat_channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChatChannelID returns the old "chat_channel_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldChatChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatChannelID: %w", err)
	}
	return oldValue.ChatChannelID, nil
}

// ClearChatChannelID clears the value of the "chat_channel_id" field.
func (m *IncidentMutation) ClearChatChannelID() {
	m.chat_channel_id = nil
	m.clearedFields[incident.FieldChatChannelID] = struct{}{}
}

// ChatChannelIDCleared returns if the "chat_channel_id" field was cleared in this mutation.
func (m *IncidentMutation) ChatChannelIDCleared() bool {
	_, ok := m.clearedFields[incident.FieldChatChannelID]
	return ok
}

// ResetChatChannelID resets all changes to the "chat_channel_id" field.
func (m *IncidentMutation) ResetChatChannelID() {
	m.chat_channel_id = nil
	delete(m.clearedFields, incident.FieldChatChannelID)
}

// SetSeverityID sets the "severity_id" field.
func (m *IncidentMutation) SetSeverityID(u uuid.UUID) {
	m.severity = &u
}

// SeverityID returns the value of the "severity_id" field in the mutation.
func (m *IncidentMutation) SeverityID() (r uuid.UUID, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverityID returns the old "severity_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldSeverityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverityID: %w", err)
	}
	return oldValue.SeverityID, nil
}

// ClearSeverityID clears the value of the "severity_id" field.
func (m *IncidentMutation) ClearSeverityID() {
	m.severity = nil
	m.clearedFields[incident.FieldSeverityID] = struct{}{}
}

// SeverityIDCleared returns if the "severity_id" field was cleared in this mutation.
func (m *IncidentMutation) SeverityIDCleared() bool {
	_, ok := m.clearedFields[incident.FieldSeverityID]
	return ok
}

// ResetSeverityID resets all changes to the "severity_id" field.
func (m *IncidentMutation) ResetSeverityID() {
	m.severity = nil
	delete(m.clearedFields, incident.FieldSeverityID)
}

// SetTypeID sets the "type_id" field.
func (m *IncidentMutation) SetTypeID(u uuid.UUID) {
	m._type = &u
}

// TypeID returns the value of the "type_id" field in the mutation.
func (m *IncidentMutation) TypeID() (r uuid.UUID, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeID returns the old "type_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeID: %w", err)
	}
	return oldValue.TypeID, nil
}

// ClearTypeID clears the value of the "type_id" field.
func (m *IncidentMutation) ClearTypeID() {
	m._type = nil
	m.clearedFields[incident.FieldTypeID] = struct{}{}
}

// TypeIDCleared returns if the "type_id" field was cleared in this mutation.
func (m *IncidentMutation) TypeIDCleared() bool {
	_, ok := m.clearedFields[incident.FieldTypeID]
	return ok
}

// ResetTypeID resets all changes to the "type_id" field.
func (m *IncidentMutation) ResetTypeID() {
	m._type = nil
	delete(m.clearedFields, incident.FieldTypeID)
}

// AddEnvironmentIDs adds the "environments" edge to the Environment entity by ids.
func (m *IncidentMutation) AddEnvironmentIDs(ids ...uuid.UUID) {
	if m.environments == nil {
		m.environments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.environments[ids[i]] = struct{}{}
	}
}

// ClearEnvironments clears the "environments" edge to the Environment entity.
func (m *IncidentMutation) ClearEnvironments() {
	m.clearedenvironments = true
}

// EnvironmentsCleared reports if the "environments" edge to the Environment entity was cleared.
func (m *IncidentMutation) EnvironmentsCleared() bool {
	return m.clearedenvironments
}

// RemoveEnvironmentIDs removes the "environments" edge to the Environment entity by IDs.
func (m *IncidentMutation) RemoveEnvironmentIDs(ids ...uuid.UUID) {
	if m.removedenvironments == nil {
		m.removedenvironments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.environments, ids[i])
		m.removedenvironments[ids[i]] = struct{}{}
	}
}

// RemovedEnvironments returns the removed IDs of the "environments" edge to the Environment entity.
func (m *IncidentMutation) RemovedEnvironmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedenvironments {
		ids = append(ids, id)
	}
	return
}

// EnvironmentsIDs returns the "environments" edge IDs in the mutation.
func (m *IncidentMutation) EnvironmentsIDs() (ids []uuid.UUID) {
	for id := range m.environments {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironments resets all changes to the "environments" edge.
func (m *IncidentMutation) ResetEnvironments() {
	m.environments = nil
	m.clearedenvironments = false
	m.removedenvironments = nil
}

// ClearSeverity clears the "severity" edge to the IncidentSeverity entity.
func (m *IncidentMutation) ClearSeverity() {
	m.clearedseverity = true
	m.clearedFields[incident.FieldSeverityID] = struct{}{}
}

// SeverityCleared reports if the "severity" edge to the IncidentSeverity entity was cleared.
func (m *IncidentMutation) SeverityCleared() bool {
	return m.SeverityIDCleared() || m.clearedseverity
}

// SeverityIDs returns the "severity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeverityID instead. It exists only for internal usage by the builders.
func (m *IncidentMutation) SeverityIDs() (ids []uuid.UUID) {
	if id := m.severity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeverity resets all changes to the "severity" edge.
func (m *IncidentMutation) ResetSeverity() {
	m.severity = nil
	m.clearedseverity = false
}

// ClearType clears the "type" edge to the IncidentType entity.
func (m *IncidentMutation) ClearType() {
	m.cleared_type = true
	m.clearedFields[incident.FieldTypeID] = struct{}{}
}

// TypeCleared reports if the "type" edge to the IncidentType entity was cleared.
func (m *IncidentMutation) TypeCleared() bool {
	return m.TypeIDCleared() || m.cleared_type
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *IncidentMutation) TypeIDs() (ids []uuid.UUID) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *IncidentMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// AddTeamAssignmentIDs adds the "team_assignments" edge to the IncidentTeamAssignment entity by ids.
func (m *IncidentMutation) AddTeamAssignmentIDs(ids ...int) {
	if m.team_assignments == nil {
		m.team_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.team_assignments[ids[i]] = struct{}{}
	}
}

// ClearTeamAssignments clears the "team_assignments" edge to the IncidentTeamAssignment entity.
func (m *IncidentMutation) ClearTeamAssignments() {
	m.clearedteam_assignments = true
}

// TeamAssignmentsCleared reports if the "team_assignments" edge to the IncidentTeamAssignment entity was cleared.
func (m *IncidentMutation) TeamAssignmentsCleared() bool {
	return m.clearedteam_assignments
}

// RemoveTeamAssignmentIDs removes the "team_assignments" edge to the IncidentTeamAssignment entity by IDs.
func (m *IncidentMutation) RemoveTeamAssignmentIDs(ids ...int) {
	if m.removedteam_assignments == nil {
		m.removedteam_assignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.team_assignments, ids[i])
		m.removedteam_assignments[ids[i]] = struct{}{}
	}
}

// RemovedTeamAssignments returns the removed IDs of the "team_assignments" edge to the IncidentTeamAssignment entity.
func (m *IncidentMutation) RemovedTeamAssignmentsIDs() (ids []int) {
	for id := range m.removedteam_assignments {
		ids = append(ids, id)
	}
	return
}

// TeamAssignmentsIDs returns the "team_assignments" edge IDs in the mutation.
func (m *IncidentMutation) TeamAssignmentsIDs() (ids []int) {
	for id := range m.team_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetTeamAssignments resets all changes to the "team_assignments" edge.
func (m *IncidentMutation) ResetTeamAssignments() {
	m.team_assignments = nil
	m.clearedteam_assignments = false
	m.removedteam_assignments = nil
}

// AddRoleAssignmentIDs adds the "role_assignments" edge to the IncidentRoleAssignment entity by ids.
func (m *IncidentMutation) AddRoleAssignmentIDs(ids ...uuid.UUID) {
	if m.role_assignments == nil {
		m.role_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.role_assignments[ids[i]] = struct{}{}
	}
}

// ClearRoleAssignments clears the "role_assignments" edge to the IncidentRoleAssignment entity.
func (m *IncidentMutation) ClearRoleAssignments() {
	m.clearedrole_assignments = true
}

// RoleAssignmentsCleared reports if the "role_assignments" edge to the IncidentRoleAssignment entity was cleared.
func (m *IncidentMutation) RoleAssignmentsCleared() bool {
	return m.clearedrole_assignments
}

// RemoveRoleAssignmentIDs removes the "role_assignments" edge to the IncidentRoleAssignment entity by IDs.
func (m *IncidentMutation) RemoveRoleAssignmentIDs(ids ...uuid.UUID) {
	if m.removedrole_assignments == nil {
		m.removedrole_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.role_assignments, ids[i])
		m.removedrole_assignments[ids[i]] = struct{}{}
	}
}

// RemovedRoleAssignments returns the removed IDs of the "role_assignments" edge to the IncidentRoleAssignment entity.
func (m *IncidentMutation) RemovedRoleAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedrole_assignments {
		ids = append(ids, id)
	}
	return
}

// RoleAssignmentsIDs returns the "role_assignments" edge IDs in the mutation.
func (m *IncidentMutation) RoleAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.role_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetRoleAssignments resets all changes to the "role_assignments" edge.
func (m *IncidentMutation) ResetRoleAssignments() {
	m.role_assignments = nil
	m.clearedrole_assignments = false
	m.removedrole_assignments = nil
}

// AddLinkedIncidentIDs adds the "linked_incidents" edge to the Incident entity by ids.
func (m *IncidentMutation) AddLinkedIncidentIDs(ids ...uuid.UUID) {
	if m.linked_incidents == nil {
		m.linked_incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.linked_incidents[ids[i]] = struct{}{}
	}
}

// ClearLinkedIncidents clears the "linked_incidents" edge to the Incident entity.
func (m *IncidentMutation) ClearLinkedIncidents() {
	m.clearedlinked_incidents = true
}

// LinkedIncidentsCleared reports if the "linked_incidents" edge to the Incident entity was cleared.
func (m *IncidentMutation) LinkedIncidentsCleared() bool {
	return m.clearedlinked_incidents
}

// RemoveLinkedIncidentIDs removes the "linked_incidents" edge to the Incident entity by IDs.
func (m *IncidentMutation) RemoveLinkedIncidentIDs(ids ...uuid.UUID) {
	if m.removedlinked_incidents == nil {
		m.removedlinked_incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.linked_incidents, ids[i])
		m.removedlinked_incidents[ids[i]] = struct{}{}
	}
}

// RemovedLinkedIncidents returns the removed IDs of the "linked_incidents" edge to the Incident entity.
func (m *IncidentMutation) RemovedLinkedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedlinked_incidents {
		ids = append(ids, id)
	}
	return
}

// LinkedIncidentsIDs returns the "linked_incidents" edge IDs in the mutation.
func (m *IncidentMutation) LinkedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.linked_incidents {
		ids = append(ids, id)
	}
	return
}

// ResetLinkedIncidents resets all changes to the "linked_incidents" edge.
func (m *IncidentMutation) ResetLinkedIncidents() {
	m.linked_incidents = nil
	m.clearedlinked_incidents = false
	m.removedlinked_incidents = nil
}

// SetRetrospectiveID sets the "retrospective" edge to the Retrospective entity by id.
func (m *IncidentMutation) SetRetrospectiveID(id uuid.UUID) {
	m.retrospective = &id
}

// ClearRetrospective clears the "retrospective" edge to the Retrospective entity.
func (m *IncidentMutation) ClearRetrospective() {
	m.clearedretrospective = true
}

// RetrospectiveCleared reports if the "retrospective" edge to the Retrospective entity was cleared.
func (m *IncidentMutation) RetrospectiveCleared() bool {
	return m.clearedretrospective
}

// RetrospectiveID returns the "retrospective" edge ID in the mutation.
func (m *IncidentMutation) RetrospectiveID() (id uuid.UUID, exists bool) {
	if m.retrospective != nil {
		return *m.retrospective, true
	}
	return
}

// RetrospectiveIDs returns the "retrospective" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RetrospectiveID instead. It exists only for internal usage by the builders.
func (m *IncidentMutation) RetrospectiveIDs() (ids []uuid.UUID) {
	if id := m.retrospective; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRetrospective resets all changes to the "retrospective" edge.
func (m *IncidentMutation) ResetRetrospective() {
	m.retrospective = nil
	m.clearedretrospective = false
}

// AddMilestoneIDs adds the "milestones" edge to the IncidentMilestone entity by ids.
func (m *IncidentMutation) AddMilestoneIDs(ids ...uuid.UUID) {
	if m.milestones == nil {
		m.milestones = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.milestones[ids[i]] = struct{}{}
	}
}

// ClearMilestones clears the "milestones" edge to the IncidentMilestone entity.
func (m *IncidentMutation) ClearMilestones() {
	m.clearedmilestones = true
}

// MilestonesCleared reports if the "milestones" edge to the IncidentMilestone entity was cleared.
func (m *IncidentMutation) MilestonesCleared() bool {
	return m.clearedmilestones
}

// RemoveMilestoneIDs removes the "milestones" edge to the IncidentMilestone entity by IDs.
func (m *IncidentMutation) RemoveMilestoneIDs(ids ...uuid.UUID) {
	if m.removedmilestones == nil {
		m.removedmilestones = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.milestones, ids[i])
		m.removedmilestones[ids[i]] = struct{}{}
	}
}

// RemovedMilestones returns the removed IDs of the "milestones" edge to the IncidentMilestone entity.
func (m *IncidentMutation) RemovedMilestonesIDs() (ids []uuid.UUID) {
	for id := range m.removedmilestones {
		ids = append(ids, id)
	}
	return
}

// MilestonesIDs returns the "milestones" edge IDs in the mutation.
func (m *IncidentMutation) MilestonesIDs() (ids []uuid.UUID) {
	for id := range m.milestones {
		ids = append(ids, id)
	}
	return
}

// ResetMilestones resets all changes to the "milestones" edge.
func (m *IncidentMutation) ResetMilestones() {
	m.milestones = nil
	m.clearedmilestones = false
	m.removedmilestones = nil
}

// AddEventIDs adds the "events" edge to the IncidentEvent entity by ids.
func (m *IncidentMutation) AddEventIDs(ids ...uuid.UUID) {
	if m.events == nil {
		m.events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the IncidentEvent entity.
func (m *IncidentMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the IncidentEvent entity was cleared.
func (m *IncidentMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the IncidentEvent entity by IDs.
func (m *IncidentMutation) RemoveEventIDs(ids ...uuid.UUID) {
	if m.removedevents == nil {
		m.removedevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the IncidentEvent entity.
func (m *IncidentMutation) RemovedEventsIDs() (ids []uuid.UUID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *IncidentMutation) EventsIDs() (ids []uuid.UUID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *IncidentMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddFieldSelectionIDs adds the "field_selections" edge to the IncidentFieldOption entity by ids.
func (m *IncidentMutation) AddFieldSelectionIDs(ids ...uuid.UUID) {
	if m.field_selections == nil {
		m.field_selections = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.field_selections[ids[i]] = struct{}{}
	}
}

// ClearFieldSelections clears the "field_selections" edge to the IncidentFieldOption entity.
func (m *IncidentMutation) ClearFieldSelections() {
	m.clearedfield_selections = true
}

// FieldSelectionsCleared reports if the "field_selections" edge to the IncidentFieldOption entity was cleared.
func (m *IncidentMutation) FieldSelectionsCleared() bool {
	return m.clearedfield_selections
}

// RemoveFieldSelectionIDs removes the "field_selections" edge to the IncidentFieldOption entity by IDs.
func (m *IncidentMutation) RemoveFieldSelectionIDs(ids ...uuid.UUID) {
	if m.removedfield_selections == nil {
		m.removedfield_selections = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.field_selections, ids[i])
		m.removedfield_selections[ids[i]] = struct{}{}
	}
}

// RemovedFieldSelections returns the removed IDs of the "field_selections" edge to the IncidentFieldOption entity.
func (m *IncidentMutation) RemovedFieldSelectionsIDs() (ids []uuid.UUID) {
	for id := range m.removedfield_selections {
		ids = append(ids, id)
	}
	return
}

// FieldSelectionsIDs returns the "field_selections" edge IDs in the mutation.
func (m *IncidentMutation) FieldSelectionsIDs() (ids []uuid.UUID) {
	for id := range m.field_selections {
		ids = append(ids, id)
	}
	return
}

// ResetFieldSelections resets all changes to the "field_selections" edge.
func (m *IncidentMutation) ResetFieldSelections() {
	m.field_selections = nil
	m.clearedfield_selections = false
	m.removedfield_selections = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *IncidentMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m.tasks == nil {
		m.tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *IncidentMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *IncidentMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *IncidentMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *IncidentMutation) RemovedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *IncidentMutation) TasksIDs() (ids []uuid.UUID) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *IncidentMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddTagAssignmentIDs adds the "tag_assignments" edge to the IncidentTag entity by ids.
func (m *IncidentMutation) AddTagAssignmentIDs(ids ...uuid.UUID) {
	if m.tag_assignments == nil {
		m.tag_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tag_assignments[ids[i]] = struct{}{}
	}
}

// ClearTagAssignments clears the "tag_assignments" edge to the IncidentTag entity.
func (m *IncidentMutation) ClearTagAssignments() {
	m.clearedtag_assignments = true
}

// TagAssignmentsCleared reports if the "tag_assignments" edge to the IncidentTag entity was cleared.
func (m *IncidentMutation) TagAssignmentsCleared() bool {
	return m.clearedtag_assignments
}

// RemoveTagAssignmentIDs removes the "tag_assignments" edge to the IncidentTag entity by IDs.
func (m *IncidentMutation) RemoveTagAssignmentIDs(ids ...uuid.UUID) {
	if m.removedtag_assignments == nil {
		m.removedtag_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tag_assignments, ids[i])
		m.removedtag_assignments[ids[i]] = struct{}{}
	}
}

// RemovedTagAssignments returns the removed IDs of the "tag_assignments" edge to the IncidentTag entity.
func (m *IncidentMutation) RemovedTagAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedtag_assignments {
		ids = append(ids, id)
	}
	return
}

// TagAssignmentsIDs returns the "tag_assignments" edge IDs in the mutation.
func (m *IncidentMutation) TagAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.tag_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetTagAssignments resets all changes to the "tag_assignments" edge.
func (m *IncidentMutation) ResetTagAssignments() {
	m.tag_assignments = nil
	m.clearedtag_assignments = false
	m.removedtag_assignments = nil
}

// AddDebriefIDs adds the "debriefs" edge to the IncidentDebrief entity by ids.
func (m *IncidentMutation) AddDebriefIDs(ids ...uuid.UUID) {
	if m.debriefs == nil {
		m.debriefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debriefs[ids[i]] = struct{}{}
	}
}

// ClearDebriefs clears the "debriefs" edge to the IncidentDebrief entity.
func (m *IncidentMutation) ClearDebriefs() {
	m.cleareddebriefs = true
}

// DebriefsCleared reports if the "debriefs" edge to the IncidentDebrief entity was cleared.
func (m *IncidentMutation) DebriefsCleared() bool {
	return m.cleareddebriefs
}

// RemoveDebriefIDs removes the "debriefs" edge to the IncidentDebrief entity by IDs.
func (m *IncidentMutation) RemoveDebriefIDs(ids ...uuid.UUID) {
	if m.removeddebriefs == nil {
		m.removeddebriefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debriefs, ids[i])
		m.removeddebriefs[ids[i]] = struct{}{}
	}
}

// RemovedDebriefs returns the removed IDs of the "debriefs" edge to the IncidentDebrief entity.
func (m *IncidentMutation) RemovedDebriefsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebriefs {
		ids = append(ids, id)
	}
	return
}

// DebriefsIDs returns the "debriefs" edge IDs in the mutation.
func (m *IncidentMutation) DebriefsIDs() (ids []uuid.UUID) {
	for id := range m.debriefs {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefs resets all changes to the "debriefs" edge.
func (m *IncidentMutation) ResetDebriefs() {
	m.debriefs = nil
	m.cleareddebriefs = false
	m.removeddebriefs = nil
}

// AddReviewSessionIDs adds the "review_sessions" edge to the MeetingSession entity by ids.
func (m *IncidentMutation) AddReviewSessionIDs(ids ...uuid.UUID) {
	if m.review_sessions == nil {
		m.review_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.review_sessions[ids[i]] = struct{}{}
	}
}

// ClearReviewSessions clears the "review_sessions" edge to the MeetingSession entity.
func (m *IncidentMutation) ClearReviewSessions() {
	m.clearedreview_sessions = true
}

// ReviewSessionsCleared reports if the "review_sessions" edge to the MeetingSession entity was cleared.
func (m *IncidentMutation) ReviewSessionsCleared() bool {
	return m.clearedreview_sessions
}

// RemoveReviewSessionIDs removes the "review_sessions" edge to the MeetingSession entity by IDs.
func (m *IncidentMutation) RemoveReviewSessionIDs(ids ...uuid.UUID) {
	if m.removedreview_sessions == nil {
		m.removedreview_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.review_sessions, ids[i])
		m.removedreview_sessions[ids[i]] = struct{}{}
	}
}

// RemovedReviewSessions returns the removed IDs of the "review_sessions" edge to the MeetingSession entity.
func (m *IncidentMutation) RemovedReviewSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedreview_sessions {
		ids = append(ids, id)
	}
	return
}

// ReviewSessionsIDs returns the "review_sessions" edge IDs in the mutation.
func (m *IncidentMutation) ReviewSessionsIDs() (ids []uuid.UUID) {
	for id := range m.review_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetReviewSessions resets all changes to the "review_sessions" edge.
func (m *IncidentMutation) ResetReviewSessions() {
	m.review_sessions = nil
	m.clearedreview_sessions = false
	m.removedreview_sessions = nil
}

// AddIncidentLinkIDs adds the "incident_links" edge to the IncidentLink entity by ids.
func (m *IncidentMutation) AddIncidentLinkIDs(ids ...int) {
	if m.incident_links == nil {
		m.incident_links = make(map[int]struct{})
	}
	for i := range ids {
		m.incident_links[ids[i]] = struct{}{}
	}
}

// ClearIncidentLinks clears the "incident_links" edge to the IncidentLink entity.
func (m *IncidentMutation) ClearIncidentLinks() {
	m.clearedincident_links = true
}

// IncidentLinksCleared reports if the "incident_links" edge to the IncidentLink entity was cleared.
func (m *IncidentMutation) IncidentLinksCleared() bool {
	return m.clearedincident_links
}

// RemoveIncidentLinkIDs removes the "incident_links" edge to the IncidentLink entity by IDs.
func (m *IncidentMutation) RemoveIncidentLinkIDs(ids ...int) {
	if m.removedincident_links == nil {
		m.removedincident_links = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.incident_links, ids[i])
		m.removedincident_links[ids[i]] = struct{}{}
	}
}

// RemovedIncidentLinks returns the removed IDs of the "incident_links" edge to the IncidentLink entity.
func (m *IncidentMutation) RemovedIncidentLinksIDs() (ids []int) {
	for id := range m.removedincident_links {
		ids = append(ids, id)
	}
	return
}

// IncidentLinksIDs returns the "incident_links" edge IDs in the mutation.
func (m *IncidentMutation) IncidentLinksIDs() (ids []int) {
	for id := range m.incident_links {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentLinks resets all changes to the "incident_links" edge.
func (m *IncidentMutation) ResetIncidentLinks() {
	m.incident_links = nil
	m.clearedincident_links = false
	m.removedincident_links = nil
}

// Where appends a list predicates to the IncidentMutation builder.
func (m *IncidentMutation) Where(ps ...predicate.Incident) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Incident, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Incident).
func (m *IncidentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.slug != nil {
		fields = append(fields, incident.FieldSlug)
	}
	if m.title != nil {
		fields = append(fields, incident.FieldTitle)
	}
	if m.private != nil {
		fields = append(fields, incident.FieldPrivate)
	}
	if m.summary != nil {
		fields = append(fields, incident.FieldSummary)
	}
	if m.opened_at != nil {
		fields = append(fields, incident.FieldOpenedAt)
	}
	if m.modified_at != nil {
		fields = append(fields, incident.FieldModifiedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, incident.FieldClosedAt)
	}
	if m.provider_id != nil {
		fields = append(fields, incident.FieldProviderID)
	}
	if m.chat_channel_id != nil {
		fields = append(fields, incident.FieldChatChannelID)
	}
	if m.severity != nil {
		fields = append(fields, incident.FieldSeverityID)
	}
	if m._type != nil {
		fields = append(fields, incident.FieldTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incident.FieldSlug:
		return m.Slug()
	case incident.FieldTitle:
		return m.Title()
	case incident.FieldPrivate:
		return m.Private()
	case incident.FieldSummary:
		return m.Summary()
	case incident.FieldOpenedAt:
		return m.OpenedAt()
	case incident.FieldModifiedAt:
		return m.ModifiedAt()
	case incident.FieldClosedAt:
		return m.ClosedAt()
	case incident.FieldProviderID:
		return m.ProviderID()
	case incident.FieldChatChannelID:
		return m.ChatChannelID()
	case incident.FieldSeverityID:
		return m.SeverityID()
	case incident.FieldTypeID:
		return m.TypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incident.FieldSlug:
		return m.OldSlug(ctx)
	case incident.FieldTitle:
		return m.OldTitle(ctx)
	case incident.FieldPrivate:
		return m.OldPrivate(ctx)
	case incident.FieldSummary:
		return m.OldSummary(ctx)
	case incident.FieldOpenedAt:
		return m.OldOpenedAt(ctx)
	case incident.FieldModifiedAt:
		return m.OldModifiedAt(ctx)
	case incident.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case incident.FieldProviderID:
		return m.OldProviderID(ctx)
	case incident.FieldChatChannelID:
		return m.OldChatChannelID(ctx)
	case incident.FieldSeverityID:
		return m.OldSeverityID(ctx)
	case incident.FieldTypeID:
		return m.OldTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown Incident field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incident.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case incident.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case incident.FieldPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivate(v)
		return nil
	case incident.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case incident.FieldOpenedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenedAt(v)
		return nil
	case incident.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	case incident.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case incident.FieldProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case incident.FieldChatChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatChannelID(v)
		return nil
	case incident.FieldSeverityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverityID(v)
		return nil
	case incident.FieldTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Incident numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incident.FieldChatChannelID) {
		fields = append(fields, incident.FieldChatChannelID)
	}
	if m.FieldCleared(incident.FieldSeverityID) {
		fields = append(fields, incident.FieldSeverityID)
	}
	if m.FieldCleared(incident.FieldTypeID) {
		fields = append(fields, incident.FieldTypeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentMutation) ClearField(name string) error {
	switch name {
	case incident.FieldChatChannelID:
		m.ClearChatChannelID()
		return nil
	case incident.FieldSeverityID:
		m.ClearSeverityID()
		return nil
	case incident.FieldTypeID:
		m.ClearTypeID()
		return nil
	}
	return fmt.Errorf("unknown Incident nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentMutation) ResetField(name string) error {
	switch name {
	case incident.FieldSlug:
		m.ResetSlug()
		return nil
	case incident.FieldTitle:
		m.ResetTitle()
		return nil
	case incident.FieldPrivate:
		m.ResetPrivate()
		return nil
	case incident.FieldSummary:
		m.ResetSummary()
		return nil
	case incident.FieldOpenedAt:
		m.ResetOpenedAt()
		return nil
	case incident.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	case incident.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case incident.FieldProviderID:
		m.ResetProviderID()
		return nil
	case incident.FieldChatChannelID:
		m.ResetChatChannelID()
		return nil
	case incident.FieldSeverityID:
		m.ResetSeverityID()
		return nil
	case incident.FieldTypeID:
		m.ResetTypeID()
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.environments != nil {
		edges = append(edges, incident.EdgeEnvironments)
	}
	if m.severity != nil {
		edges = append(edges, incident.EdgeSeverity)
	}
	if m._type != nil {
		edges = append(edges, incident.EdgeType)
	}
	if m.team_assignments != nil {
		edges = append(edges, incident.EdgeTeamAssignments)
	}
	if m.role_assignments != nil {
		edges = append(edges, incident.EdgeRoleAssignments)
	}
	if m.linked_incidents != nil {
		edges = append(edges, incident.EdgeLinkedIncidents)
	}
	if m.retrospective != nil {
		edges = append(edges, incident.EdgeRetrospective)
	}
	if m.milestones != nil {
		edges = append(edges, incident.EdgeMilestones)
	}
	if m.events != nil {
		edges = append(edges, incident.EdgeEvents)
	}
	if m.field_selections != nil {
		edges = append(edges, incident.EdgeFieldSelections)
	}
	if m.tasks != nil {
		edges = append(edges, incident.EdgeTasks)
	}
	if m.tag_assignments != nil {
		edges = append(edges, incident.EdgeTagAssignments)
	}
	if m.debriefs != nil {
		edges = append(edges, incident.EdgeDebriefs)
	}
	if m.review_sessions != nil {
		edges = append(edges, incident.EdgeReviewSessions)
	}
	if m.incident_links != nil {
		edges = append(edges, incident.EdgeIncidentLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incident.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.environments))
		for id := range m.environments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeSeverity:
		if id := m.severity; id != nil {
			return []ent.Value{*id}
		}
	case incident.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case incident.EdgeTeamAssignments:
		ids := make([]ent.Value, 0, len(m.team_assignments))
		for id := range m.team_assignments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeRoleAssignments:
		ids := make([]ent.Value, 0, len(m.role_assignments))
		for id := range m.role_assignments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeLinkedIncidents:
		ids := make([]ent.Value, 0, len(m.linked_incidents))
		for id := range m.linked_incidents {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeRetrospective:
		if id := m.retrospective; id != nil {
			return []ent.Value{*id}
		}
	case incident.EdgeMilestones:
		ids := make([]ent.Value, 0, len(m.milestones))
		for id := range m.milestones {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeFieldSelections:
		ids := make([]ent.Value, 0, len(m.field_selections))
		for id := range m.field_selections {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeTagAssignments:
		ids := make([]ent.Value, 0, len(m.tag_assignments))
		for id := range m.tag_assignments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeDebriefs:
		ids := make([]ent.Value, 0, len(m.debriefs))
		for id := range m.debriefs {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeReviewSessions:
		ids := make([]ent.Value, 0, len(m.review_sessions))
		for id := range m.review_sessions {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeIncidentLinks:
		ids := make([]ent.Value, 0, len(m.incident_links))
		for id := range m.incident_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedenvironments != nil {
		edges = append(edges, incident.EdgeEnvironments)
	}
	if m.removedteam_assignments != nil {
		edges = append(edges, incident.EdgeTeamAssignments)
	}
	if m.removedrole_assignments != nil {
		edges = append(edges, incident.EdgeRoleAssignments)
	}
	if m.removedlinked_incidents != nil {
		edges = append(edges, incident.EdgeLinkedIncidents)
	}
	if m.removedmilestones != nil {
		edges = append(edges, incident.EdgeMilestones)
	}
	if m.removedevents != nil {
		edges = append(edges, incident.EdgeEvents)
	}
	if m.removedfield_selections != nil {
		edges = append(edges, incident.EdgeFieldSelections)
	}
	if m.removedtasks != nil {
		edges = append(edges, incident.EdgeTasks)
	}
	if m.removedtag_assignments != nil {
		edges = append(edges, incident.EdgeTagAssignments)
	}
	if m.removeddebriefs != nil {
		edges = append(edges, incident.EdgeDebriefs)
	}
	if m.removedreview_sessions != nil {
		edges = append(edges, incident.EdgeReviewSessions)
	}
	if m.removedincident_links != nil {
		edges = append(edges, incident.EdgeIncidentLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incident.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.removedenvironments))
		for id := range m.removedenvironments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeTeamAssignments:
		ids := make([]ent.Value, 0, len(m.removedteam_assignments))
		for id := range m.removedteam_assignments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeRoleAssignments:
		ids := make([]ent.Value, 0, len(m.removedrole_assignments))
		for id := range m.removedrole_assignments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeLinkedIncidents:
		ids := make([]ent.Value, 0, len(m.removedlinked_incidents))
		for id := range m.removedlinked_incidents {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeMilestones:
		ids := make([]ent.Value, 0, len(m.removedmilestones))
		for id := range m.removedmilestones {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeFieldSelections:
		ids := make([]ent.Value, 0, len(m.removedfield_selections))
		for id := range m.removedfield_selections {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeTagAssignments:
		ids := make([]ent.Value, 0, len(m.removedtag_assignments))
		for id := range m.removedtag_assignments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeDebriefs:
		ids := make([]ent.Value, 0, len(m.removeddebriefs))
		for id := range m.removeddebriefs {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeReviewSessions:
		ids := make([]ent.Value, 0, len(m.removedreview_sessions))
		for id := range m.removedreview_sessions {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeIncidentLinks:
		ids := make([]ent.Value, 0, len(m.removedincident_links))
		for id := range m.removedincident_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedenvironments {
		edges = append(edges, incident.EdgeEnvironments)
	}
	if m.clearedseverity {
		edges = append(edges, incident.EdgeSeverity)
	}
	if m.cleared_type {
		edges = append(edges, incident.EdgeType)
	}
	if m.clearedteam_assignments {
		edges = append(edges, incident.EdgeTeamAssignments)
	}
	if m.clearedrole_assignments {
		edges = append(edges, incident.EdgeRoleAssignments)
	}
	if m.clearedlinked_incidents {
		edges = append(edges, incident.EdgeLinkedIncidents)
	}
	if m.clearedretrospective {
		edges = append(edges, incident.EdgeRetrospective)
	}
	if m.clearedmilestones {
		edges = append(edges, incident.EdgeMilestones)
	}
	if m.clearedevents {
		edges = append(edges, incident.EdgeEvents)
	}
	if m.clearedfield_selections {
		edges = append(edges, incident.EdgeFieldSelections)
	}
	if m.clearedtasks {
		edges = append(edges, incident.EdgeTasks)
	}
	if m.clearedtag_assignments {
		edges = append(edges, incident.EdgeTagAssignments)
	}
	if m.cleareddebriefs {
		edges = append(edges, incident.EdgeDebriefs)
	}
	if m.clearedreview_sessions {
		edges = append(edges, incident.EdgeReviewSessions)
	}
	if m.clearedincident_links {
		edges = append(edges, incident.EdgeIncidentLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentMutation) EdgeCleared(name string) bool {
	switch name {
	case incident.EdgeEnvironments:
		return m.clearedenvironments
	case incident.EdgeSeverity:
		return m.clearedseverity
	case incident.EdgeType:
		return m.cleared_type
	case incident.EdgeTeamAssignments:
		return m.clearedteam_assignments
	case incident.EdgeRoleAssignments:
		return m.clearedrole_assignments
	case incident.EdgeLinkedIncidents:
		return m.clearedlinked_incidents
	case incident.EdgeRetrospective:
		return m.clearedretrospective
	case incident.EdgeMilestones:
		return m.clearedmilestones
	case incident.EdgeEvents:
		return m.clearedevents
	case incident.EdgeFieldSelections:
		return m.clearedfield_selections
	case incident.EdgeTasks:
		return m.clearedtasks
	case incident.EdgeTagAssignments:
		return m.clearedtag_assignments
	case incident.EdgeDebriefs:
		return m.cleareddebriefs
	case incident.EdgeReviewSessions:
		return m.clearedreview_sessions
	case incident.EdgeIncidentLinks:
		return m.clearedincident_links
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentMutation) ClearEdge(name string) error {
	switch name {
	case incident.EdgeSeverity:
		m.ClearSeverity()
		return nil
	case incident.EdgeType:
		m.ClearType()
		return nil
	case incident.EdgeRetrospective:
		m.ClearRetrospective()
		return nil
	}
	return fmt.Errorf("unknown Incident unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentMutation) ResetEdge(name string) error {
	switch name {
	case incident.EdgeEnvironments:
		m.ResetEnvironments()
		return nil
	case incident.EdgeSeverity:
		m.ResetSeverity()
		return nil
	case incident.EdgeType:
		m.ResetType()
		return nil
	case incident.EdgeTeamAssignments:
		m.ResetTeamAssignments()
		return nil
	case incident.EdgeRoleAssignments:
		m.ResetRoleAssignments()
		return nil
	case incident.EdgeLinkedIncidents:
		m.ResetLinkedIncidents()
		return nil
	case incident.EdgeRetrospective:
		m.ResetRetrospective()
		return nil
	case incident.EdgeMilestones:
		m.ResetMilestones()
		return nil
	case incident.EdgeEvents:
		m.ResetEvents()
		return nil
	case incident.EdgeFieldSelections:
		m.ResetFieldSelections()
		return nil
	case incident.EdgeTasks:
		m.ResetTasks()
		return nil
	case incident.EdgeTagAssignments:
		m.ResetTagAssignments()
		return nil
	case incident.EdgeDebriefs:
		m.ResetDebriefs()
		return nil
	case incident.EdgeReviewSessions:
		m.ResetReviewSessions()
		return nil
	case incident.EdgeIncidentLinks:
		m.ResetIncidentLinks()
		return nil
	}
	return fmt.Errorf("unknown Incident edge %s", name)
}

// IncidentDebriefMutation represents an operation that mutates the IncidentDebrief nodes in the graph.
type IncidentDebriefMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	required           *bool
	started            *bool
	clearedFields      map[string]struct{}
	incident           *uuid.UUID
	clearedincident    bool
	user               *uuid.UUID
	cleareduser        bool
	messages           map[uuid.UUID]struct{}
	removedmessages    map[uuid.UUID]struct{}
	clearedmessages    bool
	suggestions        map[uuid.UUID]struct{}
	removedsuggestions map[uuid.UUID]struct{}
	clearedsuggestions bool
	done               bool
	oldValue           func(context.Context) (*IncidentDebrief, error)
	predicates         []predicate.IncidentDebrief
}

var _ ent.Mutation = (*IncidentDebriefMutation)(nil)

// incidentdebriefOption allows management of the mutation configuration using functional options.
type incidentdebriefOption func(*IncidentDebriefMutation)

// newIncidentDebriefMutation creates new mutation for the IncidentDebrief entity.
func newIncidentDebriefMutation(c config, op Op, opts ...incidentdebriefOption) *IncidentDebriefMutation {
	m := &IncidentDebriefMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentDebrief,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentDebriefID sets the ID field of the mutation.
func withIncidentDebriefID(id uuid.UUID) incidentdebriefOption {
	return func(m *IncidentDebriefMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentDebrief
		)
		m.oldValue = func(ctx context.Context) (*IncidentDebrief, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentDebrief.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentDebrief sets the old IncidentDebrief of the mutation.
func withIncidentDebrief(node *IncidentDebrief) incidentdebriefOption {
	return func(m *IncidentDebriefMutation) {
		m.oldValue = func(context.Context) (*IncidentDebrief, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentDebriefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentDebriefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentDebrief entities.
func (m *IncidentDebriefMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentDebriefMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentDebriefMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentDebrief.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentDebriefMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentDebriefMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentDebrief entity.
// If the IncidentDebrief object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentDebriefMutation) ResetIncidentID() {
	m.incident = nil
}

// SetUserID sets the "user_id" field.
func (m *IncidentDebriefMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IncidentDebriefMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the IncidentDebrief entity.
// If the IncidentDebrief object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IncidentDebriefMutation) ResetUserID() {
	m.user = nil
}

// SetRequired sets the "required" field.
func (m *IncidentDebriefMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *IncidentDebriefMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the IncidentDebrief entity.
// If the IncidentDebrief object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *IncidentDebriefMutation) ResetRequired() {
	m.required = nil
}

// SetStarted sets the "started" field.
func (m *IncidentDebriefMutation) SetStarted(b bool) {
	m.started = &b
}

// Started returns the value of the "started" field in the mutation.
func (m *IncidentDebriefMutation) Started() (r bool, exists bool) {
	v := m.started
	if v == nil {
		return
	}
	return *v, true
}

// OldStarted returns the old "started" field's value of the IncidentDebrief entity.
// If the IncidentDebrief object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMutation) OldStarted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarted: %w", err)
	}
	return oldValue.Started, nil
}

// ResetStarted resets all changes to the "started" field.
func (m *IncidentDebriefMutation) ResetStarted() {
	m.started = nil
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentDebriefMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentdebrief.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentDebriefMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentDebriefMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *IncidentDebriefMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[incidentdebrief.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *IncidentDebriefMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *IncidentDebriefMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMessageIDs adds the "messages" edge to the IncidentDebriefMessage entity by ids.
func (m *IncidentDebriefMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the IncidentDebriefMessage entity.
func (m *IncidentDebriefMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the IncidentDebriefMessage entity was cleared.
func (m *IncidentDebriefMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the IncidentDebriefMessage entity by IDs.
func (m *IncidentDebriefMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the IncidentDebriefMessage entity.
func (m *IncidentDebriefMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *IncidentDebriefMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *IncidentDebriefMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddSuggestionIDs adds the "suggestions" edge to the IncidentDebriefSuggestion entity by ids.
func (m *IncidentDebriefMutation) AddSuggestionIDs(ids ...uuid.UUID) {
	if m.suggestions == nil {
		m.suggestions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.suggestions[ids[i]] = struct{}{}
	}
}

// ClearSuggestions clears the "suggestions" edge to the IncidentDebriefSuggestion entity.
func (m *IncidentDebriefMutation) ClearSuggestions() {
	m.clearedsuggestions = true
}

// SuggestionsCleared reports if the "suggestions" edge to the IncidentDebriefSuggestion entity was cleared.
func (m *IncidentDebriefMutation) SuggestionsCleared() bool {
	return m.clearedsuggestions
}

// RemoveSuggestionIDs removes the "suggestions" edge to the IncidentDebriefSuggestion entity by IDs.
func (m *IncidentDebriefMutation) RemoveSuggestionIDs(ids ...uuid.UUID) {
	if m.removedsuggestions == nil {
		m.removedsuggestions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.suggestions, ids[i])
		m.removedsuggestions[ids[i]] = struct{}{}
	}
}

// RemovedSuggestions returns the removed IDs of the "suggestions" edge to the IncidentDebriefSuggestion entity.
func (m *IncidentDebriefMutation) RemovedSuggestionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsuggestions {
		ids = append(ids, id)
	}
	return
}

// SuggestionsIDs returns the "suggestions" edge IDs in the mutation.
func (m *IncidentDebriefMutation) SuggestionsIDs() (ids []uuid.UUID) {
	for id := range m.suggestions {
		ids = append(ids, id)
	}
	return
}

// ResetSuggestions resets all changes to the "suggestions" edge.
func (m *IncidentDebriefMutation) ResetSuggestions() {
	m.suggestions = nil
	m.clearedsuggestions = false
	m.removedsuggestions = nil
}

// Where appends a list predicates to the IncidentDebriefMutation builder.
func (m *IncidentDebriefMutation) Where(ps ...predicate.IncidentDebrief) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentDebriefMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentDebriefMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentDebrief, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentDebriefMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentDebriefMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentDebrief).
func (m *IncidentDebriefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentDebriefMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.incident != nil {
		fields = append(fields, incidentdebrief.FieldIncidentID)
	}
	if m.user != nil {
		fields = append(fields, incidentdebrief.FieldUserID)
	}
	if m.required != nil {
		fields = append(fields, incidentdebrief.FieldRequired)
	}
	if m.started != nil {
		fields = append(fields, incidentdebrief.FieldStarted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentDebriefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentdebrief.FieldIncidentID:
		return m.IncidentID()
	case incidentdebrief.FieldUserID:
		return m.UserID()
	case incidentdebrief.FieldRequired:
		return m.Required()
	case incidentdebrief.FieldStarted:
		return m.Started()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentDebriefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentdebrief.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentdebrief.FieldUserID:
		return m.OldUserID(ctx)
	case incidentdebrief.FieldRequired:
		return m.OldRequired(ctx)
	case incidentdebrief.FieldStarted:
		return m.OldStarted(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentDebrief field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentdebrief.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentdebrief.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case incidentdebrief.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	case incidentdebrief.FieldStarted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarted(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentDebrief field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentDebriefMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentDebriefMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentDebrief numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentDebriefMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentDebriefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentDebriefMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentDebrief nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentDebriefMutation) ResetField(name string) error {
	switch name {
	case incidentdebrief.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentdebrief.FieldUserID:
		m.ResetUserID()
		return nil
	case incidentdebrief.FieldRequired:
		m.ResetRequired()
		return nil
	case incidentdebrief.FieldStarted:
		m.ResetStarted()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebrief field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentDebriefMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.incident != nil {
		edges = append(edges, incidentdebrief.EdgeIncident)
	}
	if m.user != nil {
		edges = append(edges, incidentdebrief.EdgeUser)
	}
	if m.messages != nil {
		edges = append(edges, incidentdebrief.EdgeMessages)
	}
	if m.suggestions != nil {
		edges = append(edges, incidentdebrief.EdgeSuggestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentDebriefMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentdebrief.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case incidentdebrief.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case incidentdebrief.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case incidentdebrief.EdgeSuggestions:
		ids := make([]ent.Value, 0, len(m.suggestions))
		for id := range m.suggestions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentDebriefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmessages != nil {
		edges = append(edges, incidentdebrief.EdgeMessages)
	}
	if m.removedsuggestions != nil {
		edges = append(edges, incidentdebrief.EdgeSuggestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentDebriefMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentdebrief.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case incidentdebrief.EdgeSuggestions:
		ids := make([]ent.Value, 0, len(m.removedsuggestions))
		for id := range m.removedsuggestions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentDebriefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedincident {
		edges = append(edges, incidentdebrief.EdgeIncident)
	}
	if m.cleareduser {
		edges = append(edges, incidentdebrief.EdgeUser)
	}
	if m.clearedmessages {
		edges = append(edges, incidentdebrief.EdgeMessages)
	}
	if m.clearedsuggestions {
		edges = append(edges, incidentdebrief.EdgeSuggestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentDebriefMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentdebrief.EdgeIncident:
		return m.clearedincident
	case incidentdebrief.EdgeUser:
		return m.cleareduser
	case incidentdebrief.EdgeMessages:
		return m.clearedmessages
	case incidentdebrief.EdgeSuggestions:
		return m.clearedsuggestions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentDebriefMutation) ClearEdge(name string) error {
	switch name {
	case incidentdebrief.EdgeIncident:
		m.ClearIncident()
		return nil
	case incidentdebrief.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebrief unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentDebriefMutation) ResetEdge(name string) error {
	switch name {
	case incidentdebrief.EdgeIncident:
		m.ResetIncident()
		return nil
	case incidentdebrief.EdgeUser:
		m.ResetUser()
		return nil
	case incidentdebrief.EdgeMessages:
		m.ResetMessages()
		return nil
	case incidentdebrief.EdgeSuggestions:
		m.ResetSuggestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebrief edge %s", name)
}

// IncidentDebriefMessageMutation represents an operation that mutates the IncidentDebriefMessage nodes in the graph.
type IncidentDebriefMessageMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	_type                *incidentdebriefmessage.Type
	requested_tool       *incidentdebriefmessage.RequestedTool
	body                 *string
	clearedFields        map[string]struct{}
	debrief              *uuid.UUID
	cleareddebrief       bool
	from_question        *uuid.UUID
	clearedfrom_question bool
	done                 bool
	oldValue             func(context.Context) (*IncidentDebriefMessage, error)
	predicates           []predicate.IncidentDebriefMessage
}

var _ ent.Mutation = (*IncidentDebriefMessageMutation)(nil)

// incidentdebriefmessageOption allows management of the mutation configuration using functional options.
type incidentdebriefmessageOption func(*IncidentDebriefMessageMutation)

// newIncidentDebriefMessageMutation creates new mutation for the IncidentDebriefMessage entity.
func newIncidentDebriefMessageMutation(c config, op Op, opts ...incidentdebriefmessageOption) *IncidentDebriefMessageMutation {
	m := &IncidentDebriefMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentDebriefMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentDebriefMessageID sets the ID field of the mutation.
func withIncidentDebriefMessageID(id uuid.UUID) incidentdebriefmessageOption {
	return func(m *IncidentDebriefMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentDebriefMessage
		)
		m.oldValue = func(ctx context.Context) (*IncidentDebriefMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentDebriefMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentDebriefMessage sets the old IncidentDebriefMessage of the mutation.
func withIncidentDebriefMessage(node *IncidentDebriefMessage) incidentdebriefmessageOption {
	return func(m *IncidentDebriefMessageMutation) {
		m.oldValue = func(context.Context) (*IncidentDebriefMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentDebriefMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentDebriefMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentDebriefMessage entities.
func (m *IncidentDebriefMessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentDebriefMessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentDebriefMessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentDebriefMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDebriefID sets the "debrief_id" field.
func (m *IncidentDebriefMessageMutation) SetDebriefID(u uuid.UUID) {
	m.debrief = &u
}

// DebriefID returns the value of the "debrief_id" field in the mutation.
func (m *IncidentDebriefMessageMutation) DebriefID() (r uuid.UUID, exists bool) {
	v := m.debrief
	if v == nil {
		return
	}
	return *v, true
}

// OldDebriefID returns the old "debrief_id" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldDebriefID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDebriefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDebriefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebriefID: %w", err)
	}
	return oldValue.DebriefID, nil
}

// ResetDebriefID resets all changes to the "debrief_id" field.
func (m *IncidentDebriefMessageMutation) ResetDebriefID() {
	m.debrief = nil
}

// SetQuestionID sets the "question_id" field.
func (m *IncidentDebriefMessageMutation) SetQuestionID(u uuid.UUID) {
	m.from_question = &u
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *IncidentDebriefMessageMutation) QuestionID() (r uuid.UUID, exists bool) {
	v := m.from_question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldQuestionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ClearQuestionID clears the value of the "question_id" field.
func (m *IncidentDebriefMessageMutation) ClearQuestionID() {
	m.from_question = nil
	m.clearedFields[incidentdebriefmessage.FieldQuestionID] = struct{}{}
}

// QuestionIDCleared returns if the "question_id" field was cleared in this mutation.
func (m *IncidentDebriefMessageMutation) QuestionIDCleared() bool {
	_, ok := m.clearedFields[incidentdebriefmessage.FieldQuestionID]
	return ok
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *IncidentDebriefMessageMutation) ResetQuestionID() {
	m.from_question = nil
	delete(m.clearedFields, incidentdebriefmessage.FieldQuestionID)
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentDebriefMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentDebriefMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentDebriefMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetType sets the "type" field.
func (m *IncidentDebriefMessageMutation) SetType(i incidentdebriefmessage.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *IncidentDebriefMessageMutation) GetType() (r incidentdebriefmessage.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldType(ctx context.Context) (v incidentdebriefmessage.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *IncidentDebriefMessageMutation) ResetType() {
	m._type = nil
}

// SetRequestedTool sets the "requested_tool" field.
func (m *IncidentDebriefMessageMutation) SetRequestedTool(it incidentdebriefmessage.RequestedTool) {
	m.requested_tool = &it
}

// RequestedTool returns the value of the "requested_tool" field in the mutation.
func (m *IncidentDebriefMessageMutation) RequestedTool() (r incidentdebriefmessage.RequestedTool, exists bool) {
	v := m.requested_tool
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedTool returns the old "requested_tool" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldRequestedTool(ctx context.Context) (v incidentdebriefmessage.RequestedTool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedTool: %w", err)
	}
	return oldValue.RequestedTool, nil
}

// ClearRequestedTool clears the value of the "requested_tool" field.
func (m *IncidentDebriefMessageMutation) ClearRequestedTool() {
	m.requested_tool = nil
	m.clearedFields[incidentdebriefmessage.FieldRequestedTool] = struct{}{}
}

// RequestedToolCleared returns if the "requested_tool" field was cleared in this mutation.
func (m *IncidentDebriefMessageMutation) RequestedToolCleared() bool {
	_, ok := m.clearedFields[incidentdebriefmessage.FieldRequestedTool]
	return ok
}

// ResetRequestedTool resets all changes to the "requested_tool" field.
func (m *IncidentDebriefMessageMutation) ResetRequestedTool() {
	m.requested_tool = nil
	delete(m.clearedFields, incidentdebriefmessage.FieldRequestedTool)
}

// SetBody sets the "body" field.
func (m *IncidentDebriefMessageMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *IncidentDebriefMessageMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *IncidentDebriefMessageMutation) ResetBody() {
	m.body = nil
}

// ClearDebrief clears the "debrief" edge to the IncidentDebrief entity.
func (m *IncidentDebriefMessageMutation) ClearDebrief() {
	m.cleareddebrief = true
	m.clearedFields[incidentdebriefmessage.FieldDebriefID] = struct{}{}
}

// DebriefCleared reports if the "debrief" edge to the IncidentDebrief entity was cleared.
func (m *IncidentDebriefMessageMutation) DebriefCleared() bool {
	return m.cleareddebrief
}

// DebriefIDs returns the "debrief" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DebriefID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefMessageMutation) DebriefIDs() (ids []uuid.UUID) {
	if id := m.debrief; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDebrief resets all changes to the "debrief" edge.
func (m *IncidentDebriefMessageMutation) ResetDebrief() {
	m.debrief = nil
	m.cleareddebrief = false
}

// SetFromQuestionID sets the "from_question" edge to the IncidentDebriefQuestion entity by id.
func (m *IncidentDebriefMessageMutation) SetFromQuestionID(id uuid.UUID) {
	m.from_question = &id
}

// ClearFromQuestion clears the "from_question" edge to the IncidentDebriefQuestion entity.
func (m *IncidentDebriefMessageMutation) ClearFromQuestion() {
	m.clearedfrom_question = true
	m.clearedFields[incidentdebriefmessage.FieldQuestionID] = struct{}{}
}

// FromQuestionCleared reports if the "from_question" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentDebriefMessageMutation) FromQuestionCleared() bool {
	return m.QuestionIDCleared() || m.clearedfrom_question
}

// FromQuestionID returns the "from_question" edge ID in the mutation.
func (m *IncidentDebriefMessageMutation) FromQuestionID() (id uuid.UUID, exists bool) {
	if m.from_question != nil {
		return *m.from_question, true
	}
	return
}

// FromQuestionIDs returns the "from_question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromQuestionID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefMessageMutation) FromQuestionIDs() (ids []uuid.UUID) {
	if id := m.from_question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromQuestion resets all changes to the "from_question" edge.
func (m *IncidentDebriefMessageMutation) ResetFromQuestion() {
	m.from_question = nil
	m.clearedfrom_question = false
}

// Where appends a list predicates to the IncidentDebriefMessageMutation builder.
func (m *IncidentDebriefMessageMutation) Where(ps ...predicate.IncidentDebriefMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentDebriefMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentDebriefMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentDebriefMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentDebriefMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentDebriefMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentDebriefMessage).
func (m *IncidentDebriefMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentDebriefMessageMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.debrief != nil {
		fields = append(fields, incidentdebriefmessage.FieldDebriefID)
	}
	if m.from_question != nil {
		fields = append(fields, incidentdebriefmessage.FieldQuestionID)
	}
	if m.created_at != nil {
		fields = append(fields, incidentdebriefmessage.FieldCreatedAt)
	}
	if m._type != nil {
		fields = append(fields, incidentdebriefmessage.FieldType)
	}
	if m.requested_tool != nil {
		fields = append(fields, incidentdebriefmessage.FieldRequestedTool)
	}
	if m.body != nil {
		fields = append(fields, incidentdebriefmessage.FieldBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentDebriefMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentdebriefmessage.FieldDebriefID:
		return m.DebriefID()
	case incidentdebriefmessage.FieldQuestionID:
		return m.QuestionID()
	case incidentdebriefmessage.FieldCreatedAt:
		return m.CreatedAt()
	case incidentdebriefmessage.FieldType:
		return m.GetType()
	case incidentdebriefmessage.FieldRequestedTool:
		return m.RequestedTool()
	case incidentdebriefmessage.FieldBody:
		return m.Body()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentDebriefMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentdebriefmessage.FieldDebriefID:
		return m.OldDebriefID(ctx)
	case incidentdebriefmessage.FieldQuestionID:
		return m.OldQuestionID(ctx)
	case incidentdebriefmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incidentdebriefmessage.FieldType:
		return m.OldType(ctx)
	case incidentdebriefmessage.FieldRequestedTool:
		return m.OldRequestedTool(ctx)
	case incidentdebriefmessage.FieldBody:
		return m.OldBody(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentDebriefMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentdebriefmessage.FieldDebriefID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebriefID(v)
		return nil
	case incidentdebriefmessage.FieldQuestionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	case incidentdebriefmessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incidentdebriefmessage.FieldType:
		v, ok := value.(incidentdebriefmessage.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case incidentdebriefmessage.FieldRequestedTool:
		v, ok := value.(incidentdebriefmessage.RequestedTool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedTool(v)
		return nil
	case incidentdebriefmessage.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentDebriefMessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentDebriefMessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentDebriefMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentDebriefMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentdebriefmessage.FieldQuestionID) {
		fields = append(fields, incidentdebriefmessage.FieldQuestionID)
	}
	if m.FieldCleared(incidentdebriefmessage.FieldRequestedTool) {
		fields = append(fields, incidentdebriefmessage.FieldRequestedTool)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentDebriefMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentDebriefMessageMutation) ClearField(name string) error {
	switch name {
	case incidentdebriefmessage.FieldQuestionID:
		m.ClearQuestionID()
		return nil
	case incidentdebriefmessage.FieldRequestedTool:
		m.ClearRequestedTool()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentDebriefMessageMutation) ResetField(name string) error {
	switch name {
	case incidentdebriefmessage.FieldDebriefID:
		m.ResetDebriefID()
		return nil
	case incidentdebriefmessage.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	case incidentdebriefmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incidentdebriefmessage.FieldType:
		m.ResetType()
		return nil
	case incidentdebriefmessage.FieldRequestedTool:
		m.ResetRequestedTool()
		return nil
	case incidentdebriefmessage.FieldBody:
		m.ResetBody()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentDebriefMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.debrief != nil {
		edges = append(edges, incidentdebriefmessage.EdgeDebrief)
	}
	if m.from_question != nil {
		edges = append(edges, incidentdebriefmessage.EdgeFromQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentDebriefMessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentdebriefmessage.EdgeDebrief:
		if id := m.debrief; id != nil {
			return []ent.Value{*id}
		}
	case incidentdebriefmessage.EdgeFromQuestion:
		if id := m.from_question; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentDebriefMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentDebriefMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentDebriefMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddebrief {
		edges = append(edges, incidentdebriefmessage.EdgeDebrief)
	}
	if m.clearedfrom_question {
		edges = append(edges, incidentdebriefmessage.EdgeFromQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentDebriefMessageMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentdebriefmessage.EdgeDebrief:
		return m.cleareddebrief
	case incidentdebriefmessage.EdgeFromQuestion:
		return m.clearedfrom_question
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentDebriefMessageMutation) ClearEdge(name string) error {
	switch name {
	case incidentdebriefmessage.EdgeDebrief:
		m.ClearDebrief()
		return nil
	case incidentdebriefmessage.EdgeFromQuestion:
		m.ClearFromQuestion()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentDebriefMessageMutation) ResetEdge(name string) error {
	switch name {
	case incidentdebriefmessage.EdgeDebrief:
		m.ResetDebrief()
		return nil
	case incidentdebriefmessage.EdgeFromQuestion:
		m.ResetFromQuestion()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefMessage edge %s", name)
}

// IncidentDebriefQuestionMutation represents an operation that mutates the IncidentDebriefQuestion nodes in the graph.
type IncidentDebriefQuestionMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	content                    *string
	clearedFields              map[string]struct{}
	messages                   map[uuid.UUID]struct{}
	removedmessages            map[uuid.UUID]struct{}
	clearedmessages            bool
	incident_fields            map[uuid.UUID]struct{}
	removedincident_fields     map[uuid.UUID]struct{}
	clearedincident_fields     bool
	incident_roles             map[uuid.UUID]struct{}
	removedincident_roles      map[uuid.UUID]struct{}
	clearedincident_roles      bool
	incident_severities        map[uuid.UUID]struct{}
	removedincident_severities map[uuid.UUID]struct{}
	clearedincident_severities bool
	incident_tags              map[uuid.UUID]struct{}
	removedincident_tags       map[uuid.UUID]struct{}
	clearedincident_tags       bool
	incident_types             map[uuid.UUID]struct{}
	removedincident_types      map[uuid.UUID]struct{}
	clearedincident_types      bool
	done                       bool
	oldValue                   func(context.Context) (*IncidentDebriefQuestion, error)
	predicates                 []predicate.IncidentDebriefQuestion
}

var _ ent.Mutation = (*IncidentDebriefQuestionMutation)(nil)

// incidentdebriefquestionOption allows management of the mutation configuration using functional options.
type incidentdebriefquestionOption func(*IncidentDebriefQuestionMutation)

// newIncidentDebriefQuestionMutation creates new mutation for the IncidentDebriefQuestion entity.
func newIncidentDebriefQuestionMutation(c config, op Op, opts ...incidentdebriefquestionOption) *IncidentDebriefQuestionMutation {
	m := &IncidentDebriefQuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentDebriefQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentDebriefQuestionID sets the ID field of the mutation.
func withIncidentDebriefQuestionID(id uuid.UUID) incidentdebriefquestionOption {
	return func(m *IncidentDebriefQuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentDebriefQuestion
		)
		m.oldValue = func(ctx context.Context) (*IncidentDebriefQuestion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentDebriefQuestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentDebriefQuestion sets the old IncidentDebriefQuestion of the mutation.
func withIncidentDebriefQuestion(node *IncidentDebriefQuestion) incidentdebriefquestionOption {
	return func(m *IncidentDebriefQuestionMutation) {
		m.oldValue = func(context.Context) (*IncidentDebriefQuestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentDebriefQuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentDebriefQuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentDebriefQuestion entities.
func (m *IncidentDebriefQuestionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentDebriefQuestionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentDebriefQuestionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentDebriefQuestion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *IncidentDebriefQuestionMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *IncidentDebriefQuestionMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the IncidentDebriefQuestion entity.
// If the IncidentDebriefQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefQuestionMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *IncidentDebriefQuestionMutation) ResetContent() {
	m.content = nil
}

// AddMessageIDs adds the "messages" edge to the IncidentDebriefMessage entity by ids.
func (m *IncidentDebriefQuestionMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the IncidentDebriefMessage entity.
func (m *IncidentDebriefQuestionMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the IncidentDebriefMessage entity was cleared.
func (m *IncidentDebriefQuestionMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the IncidentDebriefMessage entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the IncidentDebriefMessage entity.
func (m *IncidentDebriefQuestionMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *IncidentDebriefQuestionMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddIncidentFieldIDs adds the "incident_fields" edge to the IncidentField entity by ids.
func (m *IncidentDebriefQuestionMutation) AddIncidentFieldIDs(ids ...uuid.UUID) {
	if m.incident_fields == nil {
		m.incident_fields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_fields[ids[i]] = struct{}{}
	}
}

// ClearIncidentFields clears the "incident_fields" edge to the IncidentField entity.
func (m *IncidentDebriefQuestionMutation) ClearIncidentFields() {
	m.clearedincident_fields = true
}

// IncidentFieldsCleared reports if the "incident_fields" edge to the IncidentField entity was cleared.
func (m *IncidentDebriefQuestionMutation) IncidentFieldsCleared() bool {
	return m.clearedincident_fields
}

// RemoveIncidentFieldIDs removes the "incident_fields" edge to the IncidentField entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveIncidentFieldIDs(ids ...uuid.UUID) {
	if m.removedincident_fields == nil {
		m.removedincident_fields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_fields, ids[i])
		m.removedincident_fields[ids[i]] = struct{}{}
	}
}

// RemovedIncidentFields returns the removed IDs of the "incident_fields" edge to the IncidentField entity.
func (m *IncidentDebriefQuestionMutation) RemovedIncidentFieldsIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_fields {
		ids = append(ids, id)
	}
	return
}

// IncidentFieldsIDs returns the "incident_fields" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) IncidentFieldsIDs() (ids []uuid.UUID) {
	for id := range m.incident_fields {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentFields resets all changes to the "incident_fields" edge.
func (m *IncidentDebriefQuestionMutation) ResetIncidentFields() {
	m.incident_fields = nil
	m.clearedincident_fields = false
	m.removedincident_fields = nil
}

// AddIncidentRoleIDs adds the "incident_roles" edge to the IncidentRole entity by ids.
func (m *IncidentDebriefQuestionMutation) AddIncidentRoleIDs(ids ...uuid.UUID) {
	if m.incident_roles == nil {
		m.incident_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_roles[ids[i]] = struct{}{}
	}
}

// ClearIncidentRoles clears the "incident_roles" edge to the IncidentRole entity.
func (m *IncidentDebriefQuestionMutation) ClearIncidentRoles() {
	m.clearedincident_roles = true
}

// IncidentRolesCleared reports if the "incident_roles" edge to the IncidentRole entity was cleared.
func (m *IncidentDebriefQuestionMutation) IncidentRolesCleared() bool {
	return m.clearedincident_roles
}

// RemoveIncidentRoleIDs removes the "incident_roles" edge to the IncidentRole entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveIncidentRoleIDs(ids ...uuid.UUID) {
	if m.removedincident_roles == nil {
		m.removedincident_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_roles, ids[i])
		m.removedincident_roles[ids[i]] = struct{}{}
	}
}

// RemovedIncidentRoles returns the removed IDs of the "incident_roles" edge to the IncidentRole entity.
func (m *IncidentDebriefQuestionMutation) RemovedIncidentRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_roles {
		ids = append(ids, id)
	}
	return
}

// IncidentRolesIDs returns the "incident_roles" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) IncidentRolesIDs() (ids []uuid.UUID) {
	for id := range m.incident_roles {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentRoles resets all changes to the "incident_roles" edge.
func (m *IncidentDebriefQuestionMutation) ResetIncidentRoles() {
	m.incident_roles = nil
	m.clearedincident_roles = false
	m.removedincident_roles = nil
}

// AddIncidentSeverityIDs adds the "incident_severities" edge to the IncidentSeverity entity by ids.
func (m *IncidentDebriefQuestionMutation) AddIncidentSeverityIDs(ids ...uuid.UUID) {
	if m.incident_severities == nil {
		m.incident_severities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_severities[ids[i]] = struct{}{}
	}
}

// ClearIncidentSeverities clears the "incident_severities" edge to the IncidentSeverity entity.
func (m *IncidentDebriefQuestionMutation) ClearIncidentSeverities() {
	m.clearedincident_severities = true
}

// IncidentSeveritiesCleared reports if the "incident_severities" edge to the IncidentSeverity entity was cleared.
func (m *IncidentDebriefQuestionMutation) IncidentSeveritiesCleared() bool {
	return m.clearedincident_severities
}

// RemoveIncidentSeverityIDs removes the "incident_severities" edge to the IncidentSeverity entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveIncidentSeverityIDs(ids ...uuid.UUID) {
	if m.removedincident_severities == nil {
		m.removedincident_severities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_severities, ids[i])
		m.removedincident_severities[ids[i]] = struct{}{}
	}
}

// RemovedIncidentSeverities returns the removed IDs of the "incident_severities" edge to the IncidentSeverity entity.
func (m *IncidentDebriefQuestionMutation) RemovedIncidentSeveritiesIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_severities {
		ids = append(ids, id)
	}
	return
}

// IncidentSeveritiesIDs returns the "incident_severities" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) IncidentSeveritiesIDs() (ids []uuid.UUID) {
	for id := range m.incident_severities {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentSeverities resets all changes to the "incident_severities" edge.
func (m *IncidentDebriefQuestionMutation) ResetIncidentSeverities() {
	m.incident_severities = nil
	m.clearedincident_severities = false
	m.removedincident_severities = nil
}

// AddIncidentTagIDs adds the "incident_tags" edge to the IncidentTag entity by ids.
func (m *IncidentDebriefQuestionMutation) AddIncidentTagIDs(ids ...uuid.UUID) {
	if m.incident_tags == nil {
		m.incident_tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_tags[ids[i]] = struct{}{}
	}
}

// ClearIncidentTags clears the "incident_tags" edge to the IncidentTag entity.
func (m *IncidentDebriefQuestionMutation) ClearIncidentTags() {
	m.clearedincident_tags = true
}

// IncidentTagsCleared reports if the "incident_tags" edge to the IncidentTag entity was cleared.
func (m *IncidentDebriefQuestionMutation) IncidentTagsCleared() bool {
	return m.clearedincident_tags
}

// RemoveIncidentTagIDs removes the "incident_tags" edge to the IncidentTag entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveIncidentTagIDs(ids ...uuid.UUID) {
	if m.removedincident_tags == nil {
		m.removedincident_tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_tags, ids[i])
		m.removedincident_tags[ids[i]] = struct{}{}
	}
}

// RemovedIncidentTags returns the removed IDs of the "incident_tags" edge to the IncidentTag entity.
func (m *IncidentDebriefQuestionMutation) RemovedIncidentTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_tags {
		ids = append(ids, id)
	}
	return
}

// IncidentTagsIDs returns the "incident_tags" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) IncidentTagsIDs() (ids []uuid.UUID) {
	for id := range m.incident_tags {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentTags resets all changes to the "incident_tags" edge.
func (m *IncidentDebriefQuestionMutation) ResetIncidentTags() {
	m.incident_tags = nil
	m.clearedincident_tags = false
	m.removedincident_tags = nil
}

// AddIncidentTypeIDs adds the "incident_types" edge to the IncidentType entity by ids.
func (m *IncidentDebriefQuestionMutation) AddIncidentTypeIDs(ids ...uuid.UUID) {
	if m.incident_types == nil {
		m.incident_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_types[ids[i]] = struct{}{}
	}
}

// ClearIncidentTypes clears the "incident_types" edge to the IncidentType entity.
func (m *IncidentDebriefQuestionMutation) ClearIncidentTypes() {
	m.clearedincident_types = true
}

// IncidentTypesCleared reports if the "incident_types" edge to the IncidentType entity was cleared.
func (m *IncidentDebriefQuestionMutation) IncidentTypesCleared() bool {
	return m.clearedincident_types
}

// RemoveIncidentTypeIDs removes the "incident_types" edge to the IncidentType entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveIncidentTypeIDs(ids ...uuid.UUID) {
	if m.removedincident_types == nil {
		m.removedincident_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_types, ids[i])
		m.removedincident_types[ids[i]] = struct{}{}
	}
}

// RemovedIncidentTypes returns the removed IDs of the "incident_types" edge to the IncidentType entity.
func (m *IncidentDebriefQuestionMutation) RemovedIncidentTypesIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_types {
		ids = append(ids, id)
	}
	return
}

// IncidentTypesIDs returns the "incident_types" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) IncidentTypesIDs() (ids []uuid.UUID) {
	for id := range m.incident_types {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentTypes resets all changes to the "incident_types" edge.
func (m *IncidentDebriefQuestionMutation) ResetIncidentTypes() {
	m.incident_types = nil
	m.clearedincident_types = false
	m.removedincident_types = nil
}

// Where appends a list predicates to the IncidentDebriefQuestionMutation builder.
func (m *IncidentDebriefQuestionMutation) Where(ps ...predicate.IncidentDebriefQuestion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentDebriefQuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentDebriefQuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentDebriefQuestion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentDebriefQuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentDebriefQuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentDebriefQuestion).
func (m *IncidentDebriefQuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentDebriefQuestionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.content != nil {
		fields = append(fields, incidentdebriefquestion.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentDebriefQuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentdebriefquestion.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentDebriefQuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentdebriefquestion.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentDebriefQuestion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefQuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentdebriefquestion.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefQuestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentDebriefQuestionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentDebriefQuestionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefQuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentDebriefQuestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentDebriefQuestionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentDebriefQuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentDebriefQuestionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentDebriefQuestion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentDebriefQuestionMutation) ResetField(name string) error {
	switch name {
	case incidentdebriefquestion.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefQuestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentDebriefQuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.messages != nil {
		edges = append(edges, incidentdebriefquestion.EdgeMessages)
	}
	if m.incident_fields != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentFields)
	}
	if m.incident_roles != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentRoles)
	}
	if m.incident_severities != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentSeverities)
	}
	if m.incident_tags != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTags)
	}
	if m.incident_types != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentDebriefQuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentdebriefquestion.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentFields:
		ids := make([]ent.Value, 0, len(m.incident_fields))
		for id := range m.incident_fields {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentRoles:
		ids := make([]ent.Value, 0, len(m.incident_roles))
		for id := range m.incident_roles {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentSeverities:
		ids := make([]ent.Value, 0, len(m.incident_severities))
		for id := range m.incident_severities {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentTags:
		ids := make([]ent.Value, 0, len(m.incident_tags))
		for id := range m.incident_tags {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentTypes:
		ids := make([]ent.Value, 0, len(m.incident_types))
		for id := range m.incident_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentDebriefQuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedmessages != nil {
		edges = append(edges, incidentdebriefquestion.EdgeMessages)
	}
	if m.removedincident_fields != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentFields)
	}
	if m.removedincident_roles != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentRoles)
	}
	if m.removedincident_severities != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentSeverities)
	}
	if m.removedincident_tags != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTags)
	}
	if m.removedincident_types != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentDebriefQuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentdebriefquestion.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentFields:
		ids := make([]ent.Value, 0, len(m.removedincident_fields))
		for id := range m.removedincident_fields {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentRoles:
		ids := make([]ent.Value, 0, len(m.removedincident_roles))
		for id := range m.removedincident_roles {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentSeverities:
		ids := make([]ent.Value, 0, len(m.removedincident_severities))
		for id := range m.removedincident_severities {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentTags:
		ids := make([]ent.Value, 0, len(m.removedincident_tags))
		for id := range m.removedincident_tags {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentTypes:
		ids := make([]ent.Value, 0, len(m.removedincident_types))
		for id := range m.removedincident_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentDebriefQuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedmessages {
		edges = append(edges, incidentdebriefquestion.EdgeMessages)
	}
	if m.clearedincident_fields {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentFields)
	}
	if m.clearedincident_roles {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentRoles)
	}
	if m.clearedincident_severities {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentSeverities)
	}
	if m.clearedincident_tags {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTags)
	}
	if m.clearedincident_types {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentDebriefQuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentdebriefquestion.EdgeMessages:
		return m.clearedmessages
	case incidentdebriefquestion.EdgeIncidentFields:
		return m.clearedincident_fields
	case incidentdebriefquestion.EdgeIncidentRoles:
		return m.clearedincident_roles
	case incidentdebriefquestion.EdgeIncidentSeverities:
		return m.clearedincident_severities
	case incidentdebriefquestion.EdgeIncidentTags:
		return m.clearedincident_tags
	case incidentdebriefquestion.EdgeIncidentTypes:
		return m.clearedincident_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentDebriefQuestionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentDebriefQuestion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentDebriefQuestionMutation) ResetEdge(name string) error {
	switch name {
	case incidentdebriefquestion.EdgeMessages:
		m.ResetMessages()
		return nil
	case incidentdebriefquestion.EdgeIncidentFields:
		m.ResetIncidentFields()
		return nil
	case incidentdebriefquestion.EdgeIncidentRoles:
		m.ResetIncidentRoles()
		return nil
	case incidentdebriefquestion.EdgeIncidentSeverities:
		m.ResetIncidentSeverities()
		return nil
	case incidentdebriefquestion.EdgeIncidentTags:
		m.ResetIncidentTags()
		return nil
	case incidentdebriefquestion.EdgeIncidentTypes:
		m.ResetIncidentTypes()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefQuestion edge %s", name)
}

// IncidentDebriefSuggestionMutation represents an operation that mutates the IncidentDebriefSuggestion nodes in the graph.
type IncidentDebriefSuggestionMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	content        *string
	clearedFields  map[string]struct{}
	debrief        *uuid.UUID
	cleareddebrief bool
	done           bool
	oldValue       func(context.Context) (*IncidentDebriefSuggestion, error)
	predicates     []predicate.IncidentDebriefSuggestion
}

var _ ent.Mutation = (*IncidentDebriefSuggestionMutation)(nil)

// incidentdebriefsuggestionOption allows management of the mutation configuration using functional options.
type incidentdebriefsuggestionOption func(*IncidentDebriefSuggestionMutation)

// newIncidentDebriefSuggestionMutation creates new mutation for the IncidentDebriefSuggestion entity.
func newIncidentDebriefSuggestionMutation(c config, op Op, opts ...incidentdebriefsuggestionOption) *IncidentDebriefSuggestionMutation {
	m := &IncidentDebriefSuggestionMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentDebriefSuggestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentDebriefSuggestionID sets the ID field of the mutation.
func withIncidentDebriefSuggestionID(id uuid.UUID) incidentdebriefsuggestionOption {
	return func(m *IncidentDebriefSuggestionMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentDebriefSuggestion
		)
		m.oldValue = func(ctx context.Context) (*IncidentDebriefSuggestion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentDebriefSuggestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentDebriefSuggestion sets the old IncidentDebriefSuggestion of the mutation.
func withIncidentDebriefSuggestion(node *IncidentDebriefSuggestion) incidentdebriefsuggestionOption {
	return func(m *IncidentDebriefSuggestionMutation) {
		m.oldValue = func(context.Context) (*IncidentDebriefSuggestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentDebriefSuggestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentDebriefSuggestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentDebriefSuggestion entities.
func (m *IncidentDebriefSuggestionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentDebriefSuggestionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentDebriefSuggestionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentDebriefSuggestion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *IncidentDebriefSuggestionMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *IncidentDebriefSuggestionMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the IncidentDebriefSuggestion entity.
// If the IncidentDebriefSuggestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefSuggestionMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *IncidentDebriefSuggestionMutation) ResetContent() {
	m.content = nil
}

// SetDebriefID sets the "debrief" edge to the IncidentDebrief entity by id.
func (m *IncidentDebriefSuggestionMutation) SetDebriefID(id uuid.UUID) {
	m.debrief = &id
}

// ClearDebrief clears the "debrief" edge to the IncidentDebrief entity.
func (m *IncidentDebriefSuggestionMutation) ClearDebrief() {
	m.cleareddebrief = true
}

// DebriefCleared reports if the "debrief" edge to the IncidentDebrief entity was cleared.
func (m *IncidentDebriefSuggestionMutation) DebriefCleared() bool {
	return m.cleareddebrief
}

// DebriefID returns the "debrief" edge ID in the mutation.
func (m *IncidentDebriefSuggestionMutation) DebriefID() (id uuid.UUID, exists bool) {
	if m.debrief != nil {
		return *m.debrief, true
	}
	return
}

// DebriefIDs returns the "debrief" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DebriefID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefSuggestionMutation) DebriefIDs() (ids []uuid.UUID) {
	if id := m.debrief; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDebrief resets all changes to the "debrief" edge.
func (m *IncidentDebriefSuggestionMutation) ResetDebrief() {
	m.debrief = nil
	m.cleareddebrief = false
}

// Where appends a list predicates to the IncidentDebriefSuggestionMutation builder.
func (m *IncidentDebriefSuggestionMutation) Where(ps ...predicate.IncidentDebriefSuggestion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentDebriefSuggestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentDebriefSuggestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentDebriefSuggestion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentDebriefSuggestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentDebriefSuggestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentDebriefSuggestion).
func (m *IncidentDebriefSuggestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentDebriefSuggestionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.content != nil {
		fields = append(fields, incidentdebriefsuggestion.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentDebriefSuggestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentdebriefsuggestion.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentDebriefSuggestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentdebriefsuggestion.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentDebriefSuggestion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefSuggestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentdebriefsuggestion.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefSuggestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentDebriefSuggestionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentDebriefSuggestionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefSuggestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentDebriefSuggestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentDebriefSuggestionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentDebriefSuggestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentDebriefSuggestionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentDebriefSuggestion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentDebriefSuggestionMutation) ResetField(name string) error {
	switch name {
	case incidentdebriefsuggestion.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefSuggestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentDebriefSuggestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.debrief != nil {
		edges = append(edges, incidentdebriefsuggestion.EdgeDebrief)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentDebriefSuggestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentdebriefsuggestion.EdgeDebrief:
		if id := m.debrief; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentDebriefSuggestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentDebriefSuggestionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentDebriefSuggestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddebrief {
		edges = append(edges, incidentdebriefsuggestion.EdgeDebrief)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentDebriefSuggestionMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentdebriefsuggestion.EdgeDebrief:
		return m.cleareddebrief
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentDebriefSuggestionMutation) ClearEdge(name string) error {
	switch name {
	case incidentdebriefsuggestion.EdgeDebrief:
		m.ClearDebrief()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefSuggestion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentDebriefSuggestionMutation) ResetEdge(name string) error {
	switch name {
	case incidentdebriefsuggestion.EdgeDebrief:
		m.ResetDebrief()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefSuggestion edge %s", name)
}

// IncidentEventMutation represents an operation that mutates the IncidentEvent nodes in the graph.
type IncidentEventMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	timestamp       *time.Time
	_type           *incidentevent.Type
	title           *string
	description     *string
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *uuid.UUID
	sequence        *int
	addsequence     *int
	is_draft        *bool
	clearedFields   map[string]struct{}
	incident        *uuid.UUID
	clearedincident bool
	context         *uuid.UUID
	clearedcontext  bool
	factors         map[uuid.UUID]struct{}
	removedfactors  map[uuid.UUID]struct{}
	clearedfactors  bool
	evidence        map[uuid.UUID]struct{}
	removedevidence map[uuid.UUID]struct{}
	clearedevidence bool
	done            bool
	oldValue        func(context.Context) (*IncidentEvent, error)
	predicates      []predicate.IncidentEvent
}

var _ ent.Mutation = (*IncidentEventMutation)(nil)

// incidenteventOption allows management of the mutation configuration using functional options.
type incidenteventOption func(*IncidentEventMutation)

// newIncidentEventMutation creates new mutation for the IncidentEvent entity.
func newIncidentEventMutation(c config, op Op, opts ...incidenteventOption) *IncidentEventMutation {
	m := &IncidentEventMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentEventID sets the ID field of the mutation.
func withIncidentEventID(id uuid.UUID) incidenteventOption {
	return func(m *IncidentEventMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentEvent
		)
		m.oldValue = func(ctx context.Context) (*IncidentEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentEvent sets the old IncidentEvent of the mutation.
func withIncidentEvent(node *IncidentEvent) incidenteventOption {
	return func(m *IncidentEventMutation) {
		m.oldValue = func(context.Context) (*IncidentEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentEvent entities.
func (m *IncidentEventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentEventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentEventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentEventMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentEventMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentEventMutation) ResetIncidentID() {
	m.incident = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *IncidentEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *IncidentEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldTimestamp(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ClearTimestamp clears the value of the "timestamp" field.
func (m *IncidentEventMutation) ClearTimestamp() {
	m.timestamp = nil
	m.clearedFields[incidentevent.FieldTimestamp] = struct{}{}
}

// TimestampCleared returns if the "timestamp" field was cleared in this mutation.
func (m *IncidentEventMutation) TimestampCleared() bool {
	_, ok := m.clearedFields[incidentevent.FieldTimestamp]
	return ok
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *IncidentEventMutation) ResetTimestamp() {
	m.timestamp = nil
	delete(m.clearedFields, incidentevent.FieldTimestamp)
}

// SetType sets the "type" field.
func (m *IncidentEventMutation) SetType(i incidentevent.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *IncidentEventMutation) GetType() (r incidentevent.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldType(ctx context.Context) (v incidentevent.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *IncidentEventMutation) ResetType() {
	m._type = nil
}

// SetTitle sets the "title" field.
func (m *IncidentEventMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IncidentEventMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IncidentEventMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *IncidentEventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentEventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentEventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidentevent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentEventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidentevent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentEventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidentevent.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *IncidentEventMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *IncidentEventMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *IncidentEventMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetSequence sets the "sequence" field.
func (m *IncidentEventMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *IncidentEventMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *IncidentEventMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *IncidentEventMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *IncidentEventMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetIsDraft sets the "is_draft" field.
func (m *IncidentEventMutation) SetIsDraft(b bool) {
	m.is_draft = &b
}

// IsDraft returns the value of the "is_draft" field in the mutation.
func (m *IncidentEventMutation) IsDraft() (r bool, exists bool) {
	v := m.is_draft
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDraft returns the old "is_draft" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldIsDraft(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDraft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDraft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDraft: %w", err)
	}
	return oldValue.IsDraft, nil
}

// ResetIsDraft resets all changes to the "is_draft" field.
func (m *IncidentEventMutation) ResetIsDraft() {
	m.is_draft = nil
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentEventMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentevent.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentEventMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentEventMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentEventMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// SetContextID sets the "context" edge to the IncidentEventContext entity by id.
func (m *IncidentEventMutation) SetContextID(id uuid.UUID) {
	m.context = &id
}

// ClearContext clears the "context" edge to the IncidentEventContext entity.
func (m *IncidentEventMutation) ClearContext() {
	m.clearedcontext = true
}

// ContextCleared reports if the "context" edge to the IncidentEventContext entity was cleared.
func (m *IncidentEventMutation) ContextCleared() bool {
	return m.clearedcontext
}

// ContextID returns the "context" edge ID in the mutation.
func (m *IncidentEventMutation) ContextID() (id uuid.UUID, exists bool) {
	if m.context != nil {
		return *m.context, true
	}
	return
}

// ContextIDs returns the "context" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContextID instead. It exists only for internal usage by the builders.
func (m *IncidentEventMutation) ContextIDs() (ids []uuid.UUID) {
	if id := m.context; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContext resets all changes to the "context" edge.
func (m *IncidentEventMutation) ResetContext() {
	m.context = nil
	m.clearedcontext = false
}

// AddFactorIDs adds the "factors" edge to the IncidentEventContributingFactor entity by ids.
func (m *IncidentEventMutation) AddFactorIDs(ids ...uuid.UUID) {
	if m.factors == nil {
		m.factors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.factors[ids[i]] = struct{}{}
	}
}

// ClearFactors clears the "factors" edge to the IncidentEventContributingFactor entity.
func (m *IncidentEventMutation) ClearFactors() {
	m.clearedfactors = true
}

// FactorsCleared reports if the "factors" edge to the IncidentEventContributingFactor entity was cleared.
func (m *IncidentEventMutation) FactorsCleared() bool {
	return m.clearedfactors
}

// RemoveFactorIDs removes the "factors" edge to the IncidentEventContributingFactor entity by IDs.
func (m *IncidentEventMutation) RemoveFactorIDs(ids ...uuid.UUID) {
	if m.removedfactors == nil {
		m.removedfactors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.factors, ids[i])
		m.removedfactors[ids[i]] = struct{}{}
	}
}

// RemovedFactors returns the removed IDs of the "factors" edge to the IncidentEventContributingFactor entity.
func (m *IncidentEventMutation) RemovedFactorsIDs() (ids []uuid.UUID) {
	for id := range m.removedfactors {
		ids = append(ids, id)
	}
	return
}

// FactorsIDs returns the "factors" edge IDs in the mutation.
func (m *IncidentEventMutation) FactorsIDs() (ids []uuid.UUID) {
	for id := range m.factors {
		ids = append(ids, id)
	}
	return
}

// ResetFactors resets all changes to the "factors" edge.
func (m *IncidentEventMutation) ResetFactors() {
	m.factors = nil
	m.clearedfactors = false
	m.removedfactors = nil
}

// AddEvidenceIDs adds the "evidence" edge to the IncidentEventEvidence entity by ids.
func (m *IncidentEventMutation) AddEvidenceIDs(ids ...uuid.UUID) {
	if m.evidence == nil {
		m.evidence = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.evidence[ids[i]] = struct{}{}
	}
}

// ClearEvidence clears the "evidence" edge to the IncidentEventEvidence entity.
func (m *IncidentEventMutation) ClearEvidence() {
	m.clearedevidence = true
}

// EvidenceCleared reports if the "evidence" edge to the IncidentEventEvidence entity was cleared.
func (m *IncidentEventMutation) EvidenceCleared() bool {
	return m.clearedevidence
}

// RemoveEvidenceIDs removes the "evidence" edge to the IncidentEventEvidence entity by IDs.
func (m *IncidentEventMutation) RemoveEvidenceIDs(ids ...uuid.UUID) {
	if m.removedevidence == nil {
		m.removedevidence = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.evidence, ids[i])
		m.removedevidence[ids[i]] = struct{}{}
	}
}

// RemovedEvidence returns the removed IDs of the "evidence" edge to the IncidentEventEvidence entity.
func (m *IncidentEventMutation) RemovedEvidenceIDs() (ids []uuid.UUID) {
	for id := range m.removedevidence {
		ids = append(ids, id)
	}
	return
}

// EvidenceIDs returns the "evidence" edge IDs in the mutation.
func (m *IncidentEventMutation) EvidenceIDs() (ids []uuid.UUID) {
	for id := range m.evidence {
		ids = append(ids, id)
	}
	return
}

// ResetEvidence resets all changes to the "evidence" edge.
func (m *IncidentEventMutation) ResetEvidence() {
	m.evidence = nil
	m.clearedevidence = false
	m.removedevidence = nil
}

// Where appends a list predicates to the IncidentEventMutation builder.
func (m *IncidentEventMutation) Where(ps ...predicate.IncidentEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentEvent).
func (m *IncidentEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentEventMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.incident != nil {
		fields = append(fields, incidentevent.FieldIncidentID)
	}
	if m.timestamp != nil {
		fields = append(fields, incidentevent.FieldTimestamp)
	}
	if m._type != nil {
		fields = append(fields, incidentevent.FieldType)
	}
	if m.title != nil {
		fields = append(fields, incidentevent.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, incidentevent.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, incidentevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incidentevent.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, incidentevent.FieldCreatedBy)
	}
	if m.sequence != nil {
		fields = append(fields, incidentevent.FieldSequence)
	}
	if m.is_draft != nil {
		fields = append(fields, incidentevent.FieldIsDraft)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentevent.FieldIncidentID:
		return m.IncidentID()
	case incidentevent.FieldTimestamp:
		return m.Timestamp()
	case incidentevent.FieldType:
		return m.GetType()
	case incidentevent.FieldTitle:
		return m.Title()
	case incidentevent.FieldDescription:
		return m.Description()
	case incidentevent.FieldCreatedAt:
		return m.CreatedAt()
	case incidentevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case incidentevent.FieldCreatedBy:
		return m.CreatedBy()
	case incidentevent.FieldSequence:
		return m.Sequence()
	case incidentevent.FieldIsDraft:
		return m.IsDraft()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentevent.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case incidentevent.FieldType:
		return m.OldType(ctx)
	case incidentevent.FieldTitle:
		return m.OldTitle(ctx)
	case incidentevent.FieldDescription:
		return m.OldDescription(ctx)
	case incidentevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incidentevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case incidentevent.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case incidentevent.FieldSequence:
		return m.OldSequence(ctx)
	case incidentevent.FieldIsDraft:
		return m.OldIsDraft(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentevent.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case incidentevent.FieldType:
		v, ok := value.(incidentevent.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case incidentevent.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case incidentevent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidentevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incidentevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case incidentevent.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case incidentevent.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case incidentevent.FieldIsDraft:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDraft(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentEventMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, incidentevent.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incidentevent.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incidentevent.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentevent.FieldTimestamp) {
		fields = append(fields, incidentevent.FieldTimestamp)
	}
	if m.FieldCleared(incidentevent.FieldDescription) {
		fields = append(fields, incidentevent.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentEventMutation) ClearField(name string) error {
	switch name {
	case incidentevent.FieldTimestamp:
		m.ClearTimestamp()
		return nil
	case incidentevent.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentEventMutation) ResetField(name string) error {
	switch name {
	case incidentevent.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case incidentevent.FieldType:
		m.ResetType()
		return nil
	case incidentevent.FieldTitle:
		m.ResetTitle()
		return nil
	case incidentevent.FieldDescription:
		m.ResetDescription()
		return nil
	case incidentevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incidentevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case incidentevent.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case incidentevent.FieldSequence:
		m.ResetSequence()
		return nil
	case incidentevent.FieldIsDraft:
		m.ResetIsDraft()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.incident != nil {
		edges = append(edges, incidentevent.EdgeIncident)
	}
	if m.context != nil {
		edges = append(edges, incidentevent.EdgeContext)
	}
	if m.factors != nil {
		edges = append(edges, incidentevent.EdgeFactors)
	}
	if m.evidence != nil {
		edges = append(edges, incidentevent.EdgeEvidence)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentevent.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case incidentevent.EdgeContext:
		if id := m.context; id != nil {
			return []ent.Value{*id}
		}
	case incidentevent.EdgeFactors:
		ids := make([]ent.Value, 0, len(m.factors))
		for id := range m.factors {
			ids = append(ids, id)
		}
		return ids
	case incidentevent.EdgeEvidence:
		ids := make([]ent.Value, 0, len(m.evidence))
		for id := range m.evidence {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedfactors != nil {
		edges = append(edges, incidentevent.EdgeFactors)
	}
	if m.removedevidence != nil {
		edges = append(edges, incidentevent.EdgeEvidence)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentEventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentevent.EdgeFactors:
		ids := make([]ent.Value, 0, len(m.removedfactors))
		for id := range m.removedfactors {
			ids = append(ids, id)
		}
		return ids
	case incidentevent.EdgeEvidence:
		ids := make([]ent.Value, 0, len(m.removedevidence))
		for id := range m.removedevidence {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedincident {
		edges = append(edges, incidentevent.EdgeIncident)
	}
	if m.clearedcontext {
		edges = append(edges, incidentevent.EdgeContext)
	}
	if m.clearedfactors {
		edges = append(edges, incidentevent.EdgeFactors)
	}
	if m.clearedevidence {
		edges = append(edges, incidentevent.EdgeEvidence)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentEventMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentevent.EdgeIncident:
		return m.clearedincident
	case incidentevent.EdgeContext:
		return m.clearedcontext
	case incidentevent.EdgeFactors:
		return m.clearedfactors
	case incidentevent.EdgeEvidence:
		return m.clearedevidence
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentEventMutation) ClearEdge(name string) error {
	switch name {
	case incidentevent.EdgeIncident:
		m.ClearIncident()
		return nil
	case incidentevent.EdgeContext:
		m.ClearContext()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentEventMutation) ResetEdge(name string) error {
	switch name {
	case incidentevent.EdgeIncident:
		m.ResetIncident()
		return nil
	case incidentevent.EdgeContext:
		m.ResetContext()
		return nil
	case incidentevent.EdgeFactors:
		m.ResetFactors()
		return nil
	case incidentevent.EdgeEvidence:
		m.ResetEvidence()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent edge %s", name)
}

// IncidentEventContextMutation represents an operation that mutates the IncidentEventContext nodes in the graph.
type IncidentEventContextMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	system_state             *string
	decision_options         *[]string
	appenddecision_options   []string
	decision_rationale       *string
	involved_personnel       *[]string
	appendinvolved_personnel []string
	created_at               *time.Time
	clearedFields            map[string]struct{}
	event                    *uuid.UUID
	clearedevent             bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentEventContext, error)
	predicates               []predicate.IncidentEventContext
}

var _ ent.Mutation = (*IncidentEventContextMutation)(nil)

// incidenteventcontextOption allows management of the mutation configuration using functional options.
type incidenteventcontextOption func(*IncidentEventContextMutation)

// newIncidentEventContextMutation creates new mutation for the IncidentEventContext entity.
func newIncidentEventContextMutation(c config, op Op, opts ...incidenteventcontextOption) *IncidentEventContextMutation {
	m := &IncidentEventContextMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentEventContext,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentEventContextID sets the ID field of the mutation.
func withIncidentEventContextID(id uuid.UUID) incidenteventcontextOption {
	return func(m *IncidentEventContextMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentEventContext
		)
		m.oldValue = func(ctx context.Context) (*IncidentEventContext, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentEventContext.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentEventContext sets the old IncidentEventContext of the mutation.
func withIncidentEventContext(node *IncidentEventContext) incidenteventcontextOption {
	return func(m *IncidentEventContextMutation) {
		m.oldValue = func(context.Context) (*IncidentEventContext, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentEventContextMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentEventContextMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentEventContext entities.
func (m *IncidentEventContextMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentEventContextMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentEventContextMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentEventContext.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSystemState sets the "system_state" field.
func (m *IncidentEventContextMutation) SetSystemState(s string) {
	m.system_state = &s
}

// SystemState returns the value of the "system_state" field in the mutation.
func (m *IncidentEventContextMutation) SystemState() (r string, exists bool) {
	v := m.system_state
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemState returns the old "system_state" field's value of the IncidentEventContext entity.
// If the IncidentEventContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContextMutation) OldSystemState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemState: %w", err)
	}
	return oldValue.SystemState, nil
}

// ClearSystemState clears the value of the "system_state" field.
func (m *IncidentEventContextMutation) ClearSystemState() {
	m.system_state = nil
	m.clearedFields[incidenteventcontext.FieldSystemState] = struct{}{}
}

// SystemStateCleared returns if the "system_state" field was cleared in this mutation.
func (m *IncidentEventContextMutation) SystemStateCleared() bool {
	_, ok := m.clearedFields[incidenteventcontext.FieldSystemState]
	return ok
}

// ResetSystemState resets all changes to the "system_state" field.
func (m *IncidentEventContextMutation) ResetSystemState() {
	m.system_state = nil
	delete(m.clearedFields, incidenteventcontext.FieldSystemState)
}

// SetDecisionOptions sets the "decision_options" field.
func (m *IncidentEventContextMutation) SetDecisionOptions(s []string) {
	m.decision_options = &s
	m.appenddecision_options = nil
}

// DecisionOptions returns the value of the "decision_options" field in the mutation.
func (m *IncidentEventContextMutation) DecisionOptions() (r []string, exists bool) {
	v := m.decision_options
	if v == nil {
		return
	}
	return *v, true
}

// OldDecisionOptions returns the old "decision_options" field's value of the IncidentEventContext entity.
// If the IncidentEventContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContextMutation) OldDecisionOptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecisionOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecisionOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecisionOptions: %w", err)
	}
	return oldValue.DecisionOptions, nil
}

// AppendDecisionOptions adds s to the "decision_options" field.
func (m *IncidentEventContextMutation) AppendDecisionOptions(s []string) {
	m.appenddecision_options = append(m.appenddecision_options, s...)
}

// AppendedDecisionOptions returns the list of values that were appended to the "decision_options" field in this mutation.
func (m *IncidentEventContextMutation) AppendedDecisionOptions() ([]string, bool) {
	if len(m.appenddecision_options) == 0 {
		return nil, false
	}
	return m.appenddecision_options, true
}

// ClearDecisionOptions clears the value of the "decision_options" field.
func (m *IncidentEventContextMutation) ClearDecisionOptions() {
	m.decision_options = nil
	m.appenddecision_options = nil
	m.clearedFields[incidenteventcontext.FieldDecisionOptions] = struct{}{}
}

// DecisionOptionsCleared returns if the "decision_options" field was cleared in this mutation.
func (m *IncidentEventContextMutation) DecisionOptionsCleared() bool {
	_, ok := m.clearedFields[incidenteventcontext.FieldDecisionOptions]
	return ok
}

// ResetDecisionOptions resets all changes to the "decision_options" field.
func (m *IncidentEventContextMutation) ResetDecisionOptions() {
	m.decision_options = nil
	m.appenddecision_options = nil
	delete(m.clearedFields, incidenteventcontext.FieldDecisionOptions)
}

// SetDecisionRationale sets the "decision_rationale" field.
func (m *IncidentEventContextMutation) SetDecisionRationale(s string) {
	m.decision_rationale = &s
}

// DecisionRationale returns the value of the "decision_rationale" field in the mutation.
func (m *IncidentEventContextMutation) DecisionRationale() (r string, exists bool) {
	v := m.decision_rationale
	if v == nil {
		return
	}
	return *v, true
}

// OldDecisionRationale returns the old "decision_rationale" field's value of the IncidentEventContext entity.
// If the IncidentEventContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContextMutation) OldDecisionRationale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecisionRationale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecisionRationale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecisionRationale: %w", err)
	}
	return oldValue.DecisionRationale, nil
}

// ClearDecisionRationale clears the value of the "decision_rationale" field.
func (m *IncidentEventContextMutation) ClearDecisionRationale() {
	m.decision_rationale = nil
	m.clearedFields[incidenteventcontext.FieldDecisionRationale] = struct{}{}
}

// DecisionRationaleCleared returns if the "decision_rationale" field was cleared in this mutation.
func (m *IncidentEventContextMutation) DecisionRationaleCleared() bool {
	_, ok := m.clearedFields[incidenteventcontext.FieldDecisionRationale]
	return ok
}

// ResetDecisionRationale resets all changes to the "decision_rationale" field.
func (m *IncidentEventContextMutation) ResetDecisionRationale() {
	m.decision_rationale = nil
	delete(m.clearedFields, incidenteventcontext.FieldDecisionRationale)
}

// SetInvolvedPersonnel sets the "involved_personnel" field.
func (m *IncidentEventContextMutation) SetInvolvedPersonnel(s []string) {
	m.involved_personnel = &s
	m.appendinvolved_personnel = nil
}

// InvolvedPersonnel returns the value of the "involved_personnel" field in the mutation.
func (m *IncidentEventContextMutation) InvolvedPersonnel() (r []string, exists bool) {
	v := m.involved_personnel
	if v == nil {
		return
	}
	return *v, true
}

// OldInvolvedPersonnel returns the old "involved_personnel" field's value of the IncidentEventContext entity.
// If the IncidentEventContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContextMutation) OldInvolvedPersonnel(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvolvedPersonnel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvolvedPersonnel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvolvedPersonnel: %w", err)
	}
	return oldValue.InvolvedPersonnel, nil
}

// AppendInvolvedPersonnel adds s to the "involved_personnel" field.
func (m *IncidentEventContextMutation) AppendInvolvedPersonnel(s []string) {
	m.appendinvolved_personnel = append(m.appendinvolved_personnel, s...)
}

// AppendedInvolvedPersonnel returns the list of values that were appended to the "involved_personnel" field in this mutation.
func (m *IncidentEventContextMutation) AppendedInvolvedPersonnel() ([]string, bool) {
	if len(m.appendinvolved_personnel) == 0 {
		return nil, false
	}
	return m.appendinvolved_personnel, true
}

// ClearInvolvedPersonnel clears the value of the "involved_personnel" field.
func (m *IncidentEventContextMutation) ClearInvolvedPersonnel() {
	m.involved_personnel = nil
	m.appendinvolved_personnel = nil
	m.clearedFields[incidenteventcontext.FieldInvolvedPersonnel] = struct{}{}
}

// InvolvedPersonnelCleared returns if the "involved_personnel" field was cleared in this mutation.
func (m *IncidentEventContextMutation) InvolvedPersonnelCleared() bool {
	_, ok := m.clearedFields[incidenteventcontext.FieldInvolvedPersonnel]
	return ok
}

// ResetInvolvedPersonnel resets all changes to the "involved_personnel" field.
func (m *IncidentEventContextMutation) ResetInvolvedPersonnel() {
	m.involved_personnel = nil
	m.appendinvolved_personnel = nil
	delete(m.clearedFields, incidenteventcontext.FieldInvolvedPersonnel)
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentEventContextMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentEventContextMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentEventContext entity.
// If the IncidentEventContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContextMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentEventContextMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEventID sets the "event" edge to the IncidentEvent entity by id.
func (m *IncidentEventContextMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the IncidentEvent entity.
func (m *IncidentEventContextMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the IncidentEvent entity was cleared.
func (m *IncidentEventContextMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *IncidentEventContextMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *IncidentEventContextMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *IncidentEventContextMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the IncidentEventContextMutation builder.
func (m *IncidentEventContextMutation) Where(ps ...predicate.IncidentEventContext) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentEventContextMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentEventContextMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentEventContext, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentEventContextMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentEventContextMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentEventContext).
func (m *IncidentEventContextMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentEventContextMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.system_state != nil {
		fields = append(fields, incidenteventcontext.FieldSystemState)
	}
	if m.decision_options != nil {
		fields = append(fields, incidenteventcontext.FieldDecisionOptions)
	}
	if m.decision_rationale != nil {
		fields = append(fields, incidenteventcontext.FieldDecisionRationale)
	}
	if m.involved_personnel != nil {
		fields = append(fields, incidenteventcontext.FieldInvolvedPersonnel)
	}
	if m.created_at != nil {
		fields = append(fields, incidenteventcontext.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentEventContextMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidenteventcontext.FieldSystemState:
		return m.SystemState()
	case incidenteventcontext.FieldDecisionOptions:
		return m.DecisionOptions()
	case incidenteventcontext.FieldDecisionRationale:
		return m.DecisionRationale()
	case incidenteventcontext.FieldInvolvedPersonnel:
		return m.InvolvedPersonnel()
	case incidenteventcontext.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentEventContextMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidenteventcontext.FieldSystemState:
		return m.OldSystemState(ctx)
	case incidenteventcontext.FieldDecisionOptions:
		return m.OldDecisionOptions(ctx)
	case incidenteventcontext.FieldDecisionRationale:
		return m.OldDecisionRationale(ctx)
	case incidenteventcontext.FieldInvolvedPersonnel:
		return m.OldInvolvedPersonnel(ctx)
	case incidenteventcontext.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentEventContext field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventContextMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidenteventcontext.FieldSystemState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemState(v)
		return nil
	case incidenteventcontext.FieldDecisionOptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecisionOptions(v)
		return nil
	case incidenteventcontext.FieldDecisionRationale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecisionRationale(v)
		return nil
	case incidenteventcontext.FieldInvolvedPersonnel:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvolvedPersonnel(v)
		return nil
	case incidenteventcontext.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContext field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentEventContextMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentEventContextMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventContextMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentEventContext numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentEventContextMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidenteventcontext.FieldSystemState) {
		fields = append(fields, incidenteventcontext.FieldSystemState)
	}
	if m.FieldCleared(incidenteventcontext.FieldDecisionOptions) {
		fields = append(fields, incidenteventcontext.FieldDecisionOptions)
	}
	if m.FieldCleared(incidenteventcontext.FieldDecisionRationale) {
		fields = append(fields, incidenteventcontext.FieldDecisionRationale)
	}
	if m.FieldCleared(incidenteventcontext.FieldInvolvedPersonnel) {
		fields = append(fields, incidenteventcontext.FieldInvolvedPersonnel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentEventContextMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentEventContextMutation) ClearField(name string) error {
	switch name {
	case incidenteventcontext.FieldSystemState:
		m.ClearSystemState()
		return nil
	case incidenteventcontext.FieldDecisionOptions:
		m.ClearDecisionOptions()
		return nil
	case incidenteventcontext.FieldDecisionRationale:
		m.ClearDecisionRationale()
		return nil
	case incidenteventcontext.FieldInvolvedPersonnel:
		m.ClearInvolvedPersonnel()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContext nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentEventContextMutation) ResetField(name string) error {
	switch name {
	case incidenteventcontext.FieldSystemState:
		m.ResetSystemState()
		return nil
	case incidenteventcontext.FieldDecisionOptions:
		m.ResetDecisionOptions()
		return nil
	case incidenteventcontext.FieldDecisionRationale:
		m.ResetDecisionRationale()
		return nil
	case incidenteventcontext.FieldInvolvedPersonnel:
		m.ResetInvolvedPersonnel()
		return nil
	case incidenteventcontext.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContext field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentEventContextMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, incidenteventcontext.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentEventContextMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidenteventcontext.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentEventContextMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentEventContextMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentEventContextMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, incidenteventcontext.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentEventContextMutation) EdgeCleared(name string) bool {
	switch name {
	case incidenteventcontext.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentEventContextMutation) ClearEdge(name string) error {
	switch name {
	case incidenteventcontext.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContext unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentEventContextMutation) ResetEdge(name string) error {
	switch name {
	case incidenteventcontext.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContext edge %s", name)
}

// IncidentEventContributingFactorMutation represents an operation that mutates the IncidentEventContributingFactor nodes in the graph.
type IncidentEventContributingFactorMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	factor_type   *string
	description   *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	event         *uuid.UUID
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*IncidentEventContributingFactor, error)
	predicates    []predicate.IncidentEventContributingFactor
}

var _ ent.Mutation = (*IncidentEventContributingFactorMutation)(nil)

// incidenteventcontributingfactorOption allows management of the mutation configuration using functional options.
type incidenteventcontributingfactorOption func(*IncidentEventContributingFactorMutation)

// newIncidentEventContributingFactorMutation creates new mutation for the IncidentEventContributingFactor entity.
func newIncidentEventContributingFactorMutation(c config, op Op, opts ...incidenteventcontributingfactorOption) *IncidentEventContributingFactorMutation {
	m := &IncidentEventContributingFactorMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentEventContributingFactor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentEventContributingFactorID sets the ID field of the mutation.
func withIncidentEventContributingFactorID(id uuid.UUID) incidenteventcontributingfactorOption {
	return func(m *IncidentEventContributingFactorMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentEventContributingFactor
		)
		m.oldValue = func(ctx context.Context) (*IncidentEventContributingFactor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentEventContributingFactor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentEventContributingFactor sets the old IncidentEventContributingFactor of the mutation.
func withIncidentEventContributingFactor(node *IncidentEventContributingFactor) incidenteventcontributingfactorOption {
	return func(m *IncidentEventContributingFactorMutation) {
		m.oldValue = func(context.Context) (*IncidentEventContributingFactor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentEventContributingFactorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentEventContributingFactorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentEventContributingFactor entities.
func (m *IncidentEventContributingFactorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentEventContributingFactorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentEventContributingFactorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentEventContributingFactor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFactorType sets the "factor_type" field.
func (m *IncidentEventContributingFactorMutation) SetFactorType(s string) {
	m.factor_type = &s
}

// FactorType returns the value of the "factor_type" field in the mutation.
func (m *IncidentEventContributingFactorMutation) FactorType() (r string, exists bool) {
	v := m.factor_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFactorType returns the old "factor_type" field's value of the IncidentEventContributingFactor entity.
// If the IncidentEventContributingFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContributingFactorMutation) OldFactorType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFactorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFactorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFactorType: %w", err)
	}
	return oldValue.FactorType, nil
}

// ResetFactorType resets all changes to the "factor_type" field.
func (m *IncidentEventContributingFactorMutation) ResetFactorType() {
	m.factor_type = nil
}

// SetDescription sets the "description" field.
func (m *IncidentEventContributingFactorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentEventContributingFactorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentEventContributingFactor entity.
// If the IncidentEventContributingFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContributingFactorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentEventContributingFactorMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidenteventcontributingfactor.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentEventContributingFactorMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidenteventcontributingfactor.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentEventContributingFactorMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidenteventcontributingfactor.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentEventContributingFactorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentEventContributingFactorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentEventContributingFactor entity.
// If the IncidentEventContributingFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContributingFactorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentEventContributingFactorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEventID sets the "event" edge to the IncidentEvent entity by id.
func (m *IncidentEventContributingFactorMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the IncidentEvent entity.
func (m *IncidentEventContributingFactorMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the IncidentEvent entity was cleared.
func (m *IncidentEventContributingFactorMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *IncidentEventContributingFactorMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *IncidentEventContributingFactorMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *IncidentEventContributingFactorMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the IncidentEventContributingFactorMutation builder.
func (m *IncidentEventContributingFactorMutation) Where(ps ...predicate.IncidentEventContributingFactor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentEventContributingFactorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentEventContributingFactorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentEventContributingFactor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentEventContributingFactorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentEventContributingFactorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentEventContributingFactor).
func (m *IncidentEventContributingFactorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentEventContributingFactorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.factor_type != nil {
		fields = append(fields, incidenteventcontributingfactor.FieldFactorType)
	}
	if m.description != nil {
		fields = append(fields, incidenteventcontributingfactor.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, incidenteventcontributingfactor.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentEventContributingFactorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidenteventcontributingfactor.FieldFactorType:
		return m.FactorType()
	case incidenteventcontributingfactor.FieldDescription:
		return m.Description()
	case incidenteventcontributingfactor.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentEventContributingFactorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidenteventcontributingfactor.FieldFactorType:
		return m.OldFactorType(ctx)
	case incidenteventcontributingfactor.FieldDescription:
		return m.OldDescription(ctx)
	case incidenteventcontributingfactor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentEventContributingFactor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventContributingFactorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidenteventcontributingfactor.FieldFactorType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFactorType(v)
		return nil
	case incidenteventcontributingfactor.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidenteventcontributingfactor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentEventContributingFactorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentEventContributingFactorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventContributingFactorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentEventContributingFactorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidenteventcontributingfactor.FieldDescription) {
		fields = append(fields, incidenteventcontributingfactor.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentEventContributingFactorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentEventContributingFactorMutation) ClearField(name string) error {
	switch name {
	case incidenteventcontributingfactor.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentEventContributingFactorMutation) ResetField(name string) error {
	switch name {
	case incidenteventcontributingfactor.FieldFactorType:
		m.ResetFactorType()
		return nil
	case incidenteventcontributingfactor.FieldDescription:
		m.ResetDescription()
		return nil
	case incidenteventcontributingfactor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentEventContributingFactorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, incidenteventcontributingfactor.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentEventContributingFactorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidenteventcontributingfactor.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentEventContributingFactorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentEventContributingFactorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentEventContributingFactorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, incidenteventcontributingfactor.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentEventContributingFactorMutation) EdgeCleared(name string) bool {
	switch name {
	case incidenteventcontributingfactor.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentEventContributingFactorMutation) ClearEdge(name string) error {
	switch name {
	case incidenteventcontributingfactor.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentEventContributingFactorMutation) ResetEdge(name string) error {
	switch name {
	case incidenteventcontributingfactor.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor edge %s", name)
}

// IncidentEventEvidenceMutation represents an operation that mutates the IncidentEventEvidence nodes in the graph.
type IncidentEventEvidenceMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	evidence_type *incidenteventevidence.EvidenceType
	url           *string
	title         *string
	description   *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	event         *uuid.UUID
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*IncidentEventEvidence, error)
	predicates    []predicate.IncidentEventEvidence
}

var _ ent.Mutation = (*IncidentEventEvidenceMutation)(nil)

// incidenteventevidenceOption allows management of the mutation configuration using functional options.
type incidenteventevidenceOption func(*IncidentEventEvidenceMutation)

// newIncidentEventEvidenceMutation creates new mutation for the IncidentEventEvidence entity.
func newIncidentEventEvidenceMutation(c config, op Op, opts ...incidenteventevidenceOption) *IncidentEventEvidenceMutation {
	m := &IncidentEventEvidenceMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentEventEvidence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentEventEvidenceID sets the ID field of the mutation.
func withIncidentEventEvidenceID(id uuid.UUID) incidenteventevidenceOption {
	return func(m *IncidentEventEvidenceMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentEventEvidence
		)
		m.oldValue = func(ctx context.Context) (*IncidentEventEvidence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentEventEvidence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentEventEvidence sets the old IncidentEventEvidence of the mutation.
func withIncidentEventEvidence(node *IncidentEventEvidence) incidenteventevidenceOption {
	return func(m *IncidentEventEvidenceMutation) {
		m.oldValue = func(context.Context) (*IncidentEventEvidence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentEventEvidenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentEventEvidenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentEventEvidence entities.
func (m *IncidentEventEvidenceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentEventEvidenceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentEventEvidenceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentEventEvidence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEvidenceType sets the "evidence_type" field.
func (m *IncidentEventEvidenceMutation) SetEvidenceType(it incidenteventevidence.EvidenceType) {
	m.evidence_type = &it
}

// EvidenceType returns the value of the "evidence_type" field in the mutation.
func (m *IncidentEventEvidenceMutation) EvidenceType() (r incidenteventevidence.EvidenceType, exists bool) {
	v := m.evidence_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEvidenceType returns the old "evidence_type" field's value of the IncidentEventEvidence entity.
// If the IncidentEventEvidence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventEvidenceMutation) OldEvidenceType(ctx context.Context) (v incidenteventevidence.EvidenceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvidenceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvidenceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvidenceType: %w", err)
	}
	return oldValue.EvidenceType, nil
}

// ResetEvidenceType resets all changes to the "evidence_type" field.
func (m *IncidentEventEvidenceMutation) ResetEvidenceType() {
	m.evidence_type = nil
}

// SetURL sets the "url" field.
func (m *IncidentEventEvidenceMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *IncidentEventEvidenceMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the IncidentEventEvidence entity.
// If the IncidentEventEvidence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventEvidenceMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *IncidentEventEvidenceMutation) ResetURL() {
	m.url = nil
}

// SetTitle sets the "title" field.
func (m *IncidentEventEvidenceMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IncidentEventEvidenceMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the IncidentEventEvidence entity.
// If the IncidentEventEvidence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventEvidenceMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IncidentEventEvidenceMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *IncidentEventEvidenceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentEventEvidenceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentEventEvidence entity.
// If the IncidentEventEvidence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventEvidenceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentEventEvidenceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidenteventevidence.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentEventEvidenceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidenteventevidence.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentEventEvidenceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidenteventevidence.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentEventEvidenceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentEventEvidenceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentEventEvidence entity.
// If the IncidentEventEvidence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventEvidenceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentEventEvidenceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEventID sets the "event" edge to the IncidentEvent entity by id.
func (m *IncidentEventEvidenceMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the IncidentEvent entity.
func (m *IncidentEventEvidenceMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the IncidentEvent entity was cleared.
func (m *IncidentEventEvidenceMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *IncidentEventEvidenceMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *IncidentEventEvidenceMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *IncidentEventEvidenceMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the IncidentEventEvidenceMutation builder.
func (m *IncidentEventEvidenceMutation) Where(ps ...predicate.IncidentEventEvidence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentEventEvidenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentEventEvidenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentEventEvidence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentEventEvidenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentEventEvidenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentEventEvidence).
func (m *IncidentEventEvidenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentEventEvidenceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.evidence_type != nil {
		fields = append(fields, incidenteventevidence.FieldEvidenceType)
	}
	if m.url != nil {
		fields = append(fields, incidenteventevidence.FieldURL)
	}
	if m.title != nil {
		fields = append(fields, incidenteventevidence.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, incidenteventevidence.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, incidenteventevidence.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentEventEvidenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidenteventevidence.FieldEvidenceType:
		return m.EvidenceType()
	case incidenteventevidence.FieldURL:
		return m.URL()
	case incidenteventevidence.FieldTitle:
		return m.Title()
	case incidenteventevidence.FieldDescription:
		return m.Description()
	case incidenteventevidence.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentEventEvidenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidenteventevidence.FieldEvidenceType:
		return m.OldEvidenceType(ctx)
	case incidenteventevidence.FieldURL:
		return m.OldURL(ctx)
	case incidenteventevidence.FieldTitle:
		return m.OldTitle(ctx)
	case incidenteventevidence.FieldDescription:
		return m.OldDescription(ctx)
	case incidenteventevidence.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentEventEvidence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventEvidenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidenteventevidence.FieldEvidenceType:
		v, ok := value.(incidenteventevidence.EvidenceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvidenceType(v)
		return nil
	case incidenteventevidence.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case incidenteventevidence.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case incidenteventevidence.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidenteventevidence.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEventEvidence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentEventEvidenceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentEventEvidenceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventEvidenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentEventEvidence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentEventEvidenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidenteventevidence.FieldDescription) {
		fields = append(fields, incidenteventevidence.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentEventEvidenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentEventEvidenceMutation) ClearField(name string) error {
	switch name {
	case incidenteventevidence.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventEvidence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentEventEvidenceMutation) ResetField(name string) error {
	switch name {
	case incidenteventevidence.FieldEvidenceType:
		m.ResetEvidenceType()
		return nil
	case incidenteventevidence.FieldURL:
		m.ResetURL()
		return nil
	case incidenteventevidence.FieldTitle:
		m.ResetTitle()
		return nil
	case incidenteventevidence.FieldDescription:
		m.ResetDescription()
		return nil
	case incidenteventevidence.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventEvidence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentEventEvidenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, incidenteventevidence.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentEventEvidenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidenteventevidence.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentEventEvidenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentEventEvidenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentEventEvidenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, incidenteventevidence.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentEventEvidenceMutation) EdgeCleared(name string) bool {
	switch name {
	case incidenteventevidence.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentEventEvidenceMutation) ClearEdge(name string) error {
	switch name {
	case incidenteventevidence.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventEvidence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentEventEvidenceMutation) ResetEdge(name string) error {
	switch name {
	case incidenteventevidence.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventEvidence edge %s", name)
}

// IncidentFieldMutation represents an operation that mutates the IncidentField nodes in the graph.
type IncidentFieldMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	name                     *string
	clearedFields            map[string]struct{}
	options                  map[uuid.UUID]struct{}
	removedoptions           map[uuid.UUID]struct{}
	clearedoptions           bool
	debrief_questions        map[uuid.UUID]struct{}
	removeddebrief_questions map[uuid.UUID]struct{}
	cleareddebrief_questions bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentField, error)
	predicates               []predicate.IncidentField
}

var _ ent.Mutation = (*IncidentFieldMutation)(nil)

// incidentfieldOption allows management of the mutation configuration using functional options.
type incidentfieldOption func(*IncidentFieldMutation)

// newIncidentFieldMutation creates new mutation for the IncidentField entity.
func newIncidentFieldMutation(c config, op Op, opts ...incidentfieldOption) *IncidentFieldMutation {
	m := &IncidentFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentFieldID sets the ID field of the mutation.
func withIncidentFieldID(id uuid.UUID) incidentfieldOption {
	return func(m *IncidentFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentField
		)
		m.oldValue = func(ctx context.Context) (*IncidentField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentField sets the old IncidentField of the mutation.
func withIncidentField(node *IncidentField) incidentfieldOption {
	return func(m *IncidentFieldMutation) {
		m.oldValue = func(context.Context) (*IncidentField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentField entities.
func (m *IncidentFieldMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentFieldMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentFieldMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentFieldMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentFieldMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentField entity.
// If the IncidentField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentFieldMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidentfield.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentFieldMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidentfield.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentFieldMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidentfield.FieldArchiveTime)
}

// SetName sets the "name" field.
func (m *IncidentFieldMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncidentFieldMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncidentField entity.
// If the IncidentField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncidentFieldMutation) ResetName() {
	m.name = nil
}

// AddOptionIDs adds the "options" edge to the IncidentFieldOption entity by ids.
func (m *IncidentFieldMutation) AddOptionIDs(ids ...uuid.UUID) {
	if m.options == nil {
		m.options = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.options[ids[i]] = struct{}{}
	}
}

// ClearOptions clears the "options" edge to the IncidentFieldOption entity.
func (m *IncidentFieldMutation) ClearOptions() {
	m.clearedoptions = true
}

// OptionsCleared reports if the "options" edge to the IncidentFieldOption entity was cleared.
func (m *IncidentFieldMutation) OptionsCleared() bool {
	return m.clearedoptions
}

// RemoveOptionIDs removes the "options" edge to the IncidentFieldOption entity by IDs.
func (m *IncidentFieldMutation) RemoveOptionIDs(ids ...uuid.UUID) {
	if m.removedoptions == nil {
		m.removedoptions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.options, ids[i])
		m.removedoptions[ids[i]] = struct{}{}
	}
}

// RemovedOptions returns the removed IDs of the "options" edge to the IncidentFieldOption entity.
func (m *IncidentFieldMutation) RemovedOptionsIDs() (ids []uuid.UUID) {
	for id := range m.removedoptions {
		ids = append(ids, id)
	}
	return
}

// OptionsIDs returns the "options" edge IDs in the mutation.
func (m *IncidentFieldMutation) OptionsIDs() (ids []uuid.UUID) {
	for id := range m.options {
		ids = append(ids, id)
	}
	return
}

// ResetOptions resets all changes to the "options" edge.
func (m *IncidentFieldMutation) ResetOptions() {
	m.options = nil
	m.clearedoptions = false
	m.removedoptions = nil
}

// AddDebriefQuestionIDs adds the "debrief_questions" edge to the IncidentDebriefQuestion entity by ids.
func (m *IncidentFieldMutation) AddDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.debrief_questions == nil {
		m.debrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debrief_questions[ids[i]] = struct{}{}
	}
}

// ClearDebriefQuestions clears the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentFieldMutation) ClearDebriefQuestions() {
	m.cleareddebrief_questions = true
}

// DebriefQuestionsCleared reports if the "debrief_questions" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentFieldMutation) DebriefQuestionsCleared() bool {
	return m.cleareddebrief_questions
}

// RemoveDebriefQuestionIDs removes the "debrief_questions" edge to the IncidentDebriefQuestion entity by IDs.
func (m *IncidentFieldMutation) RemoveDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.removeddebrief_questions == nil {
		m.removeddebrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debrief_questions, ids[i])
		m.removeddebrief_questions[ids[i]] = struct{}{}
	}
}

// RemovedDebriefQuestions returns the removed IDs of the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentFieldMutation) RemovedDebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebrief_questions {
		ids = append(ids, id)
	}
	return
}

// DebriefQuestionsIDs returns the "debrief_questions" edge IDs in the mutation.
func (m *IncidentFieldMutation) DebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.debrief_questions {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefQuestions resets all changes to the "debrief_questions" edge.
func (m *IncidentFieldMutation) ResetDebriefQuestions() {
	m.debrief_questions = nil
	m.cleareddebrief_questions = false
	m.removeddebrief_questions = nil
}

// Where appends a list predicates to the IncidentFieldMutation builder.
func (m *IncidentFieldMutation) Where(ps ...predicate.IncidentField) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentFieldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentFieldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentField, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentFieldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentFieldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentField).
func (m *IncidentFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentFieldMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.archive_time != nil {
		fields = append(fields, incidentfield.FieldArchiveTime)
	}
	if m.name != nil {
		fields = append(fields, incidentfield.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentfield.FieldArchiveTime:
		return m.ArchiveTime()
	case incidentfield.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentfield.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidentfield.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentfield.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidentfield.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentFieldMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentFieldMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentFieldMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentfield.FieldArchiveTime) {
		fields = append(fields, incidentfield.FieldArchiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentFieldMutation) ClearField(name string) error {
	switch name {
	case incidentfield.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown IncidentField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentFieldMutation) ResetField(name string) error {
	switch name {
	case incidentfield.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidentfield.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown IncidentField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.options != nil {
		edges = append(edges, incidentfield.EdgeOptions)
	}
	if m.debrief_questions != nil {
		edges = append(edges, incidentfield.EdgeDebriefQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentfield.EdgeOptions:
		ids := make([]ent.Value, 0, len(m.options))
		for id := range m.options {
			ids = append(ids, id)
		}
		return ids
	case incidentfield.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.debrief_questions))
		for id := range m.debrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoptions != nil {
		edges = append(edges, incidentfield.EdgeOptions)
	}
	if m.removeddebrief_questions != nil {
		edges = append(edges, incidentfield.EdgeDebriefQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentFieldMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentfield.EdgeOptions:
		ids := make([]ent.Value, 0, len(m.removedoptions))
		for id := range m.removedoptions {
			ids = append(ids, id)
		}
		return ids
	case incidentfield.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.removeddebrief_questions))
		for id := range m.removeddebrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedoptions {
		edges = append(edges, incidentfield.EdgeOptions)
	}
	if m.cleareddebrief_questions {
		edges = append(edges, incidentfield.EdgeDebriefQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentfield.EdgeOptions:
		return m.clearedoptions
	case incidentfield.EdgeDebriefQuestions:
		return m.cleareddebrief_questions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentFieldMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentFieldMutation) ResetEdge(name string) error {
	switch name {
	case incidentfield.EdgeOptions:
		m.ResetOptions()
		return nil
	case incidentfield.EdgeDebriefQuestions:
		m.ResetDebriefQuestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentField edge %s", name)
}

// IncidentFieldOptionMutation represents an operation that mutates the IncidentFieldOption nodes in the graph.
type IncidentFieldOptionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	archive_time          *time.Time
	_type                 *incidentfieldoption.Type
	value                 *string
	clearedFields         map[string]struct{}
	incident_field        *uuid.UUID
	clearedincident_field bool
	incidents             map[uuid.UUID]struct{}
	removedincidents      map[uuid.UUID]struct{}
	clearedincidents      bool
	done                  bool
	oldValue              func(context.Context) (*IncidentFieldOption, error)
	predicates            []predicate.IncidentFieldOption
}

var _ ent.Mutation = (*IncidentFieldOptionMutation)(nil)

// incidentfieldoptionOption allows management of the mutation configuration using functional options.
type incidentfieldoptionOption func(*IncidentFieldOptionMutation)

// newIncidentFieldOptionMutation creates new mutation for the IncidentFieldOption entity.
func newIncidentFieldOptionMutation(c config, op Op, opts ...incidentfieldoptionOption) *IncidentFieldOptionMutation {
	m := &IncidentFieldOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentFieldOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentFieldOptionID sets the ID field of the mutation.
func withIncidentFieldOptionID(id uuid.UUID) incidentfieldoptionOption {
	return func(m *IncidentFieldOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentFieldOption
		)
		m.oldValue = func(ctx context.Context) (*IncidentFieldOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentFieldOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentFieldOption sets the old IncidentFieldOption of the mutation.
func withIncidentFieldOption(node *IncidentFieldOption) incidentfieldoptionOption {
	return func(m *IncidentFieldOptionMutation) {
		m.oldValue = func(context.Context) (*IncidentFieldOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentFieldOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentFieldOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentFieldOption entities.
func (m *IncidentFieldOptionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentFieldOptionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentFieldOptionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentFieldOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentFieldOptionMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentFieldOptionMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentFieldOption entity.
// If the IncidentFieldOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldOptionMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentFieldOptionMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidentfieldoption.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentFieldOptionMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidentfieldoption.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentFieldOptionMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidentfieldoption.FieldArchiveTime)
}

// SetIncidentFieldID sets the "incident_field_id" field.
func (m *IncidentFieldOptionMutation) SetIncidentFieldID(u uuid.UUID) {
	m.incident_field = &u
}

// IncidentFieldID returns the value of the "incident_field_id" field in the mutation.
func (m *IncidentFieldOptionMutation) IncidentFieldID() (r uuid.UUID, exists bool) {
	v := m.incident_field
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentFieldID returns the old "incident_field_id" field's value of the IncidentFieldOption entity.
// If the IncidentFieldOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldOptionMutation) OldIncidentFieldID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentFieldID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentFieldID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentFieldID: %w", err)
	}
	return oldValue.IncidentFieldID, nil
}

// ResetIncidentFieldID resets all changes to the "incident_field_id" field.
func (m *IncidentFieldOptionMutation) ResetIncidentFieldID() {
	m.incident_field = nil
}

// SetType sets the "type" field.
func (m *IncidentFieldOptionMutation) SetType(i incidentfieldoption.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *IncidentFieldOptionMutation) GetType() (r incidentfieldoption.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the IncidentFieldOption entity.
// If the IncidentFieldOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldOptionMutation) OldType(ctx context.Context) (v incidentfieldoption.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *IncidentFieldOptionMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *IncidentFieldOptionMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *IncidentFieldOptionMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the IncidentFieldOption entity.
// If the IncidentFieldOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldOptionMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *IncidentFieldOptionMutation) ResetValue() {
	m.value = nil
}

// ClearIncidentField clears the "incident_field" edge to the IncidentField entity.
func (m *IncidentFieldOptionMutation) ClearIncidentField() {
	m.clearedincident_field = true
	m.clearedFields[incidentfieldoption.FieldIncidentFieldID] = struct{}{}
}

// IncidentFieldCleared reports if the "incident_field" edge to the IncidentField entity was cleared.
func (m *IncidentFieldOptionMutation) IncidentFieldCleared() bool {
	return m.clearedincident_field
}

// IncidentFieldIDs returns the "incident_field" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentFieldID instead. It exists only for internal usage by the builders.
func (m *IncidentFieldOptionMutation) IncidentFieldIDs() (ids []uuid.UUID) {
	if id := m.incident_field; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncidentField resets all changes to the "incident_field" edge.
func (m *IncidentFieldOptionMutation) ResetIncidentField() {
	m.incident_field = nil
	m.clearedincident_field = false
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *IncidentFieldOptionMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *IncidentFieldOptionMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *IncidentFieldOptionMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *IncidentFieldOptionMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *IncidentFieldOptionMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *IncidentFieldOptionMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *IncidentFieldOptionMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// Where appends a list predicates to the IncidentFieldOptionMutation builder.
func (m *IncidentFieldOptionMutation) Where(ps ...predicate.IncidentFieldOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentFieldOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentFieldOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentFieldOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentFieldOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentFieldOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentFieldOption).
func (m *IncidentFieldOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentFieldOptionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.archive_time != nil {
		fields = append(fields, incidentfieldoption.FieldArchiveTime)
	}
	if m.incident_field != nil {
		fields = append(fields, incidentfieldoption.FieldIncidentFieldID)
	}
	if m._type != nil {
		fields = append(fields, incidentfieldoption.FieldType)
	}
	if m.value != nil {
		fields = append(fields, incidentfieldoption.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentFieldOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentfieldoption.FieldArchiveTime:
		return m.ArchiveTime()
	case incidentfieldoption.FieldIncidentFieldID:
		return m.IncidentFieldID()
	case incidentfieldoption.FieldType:
		return m.GetType()
	case incidentfieldoption.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentFieldOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentfieldoption.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidentfieldoption.FieldIncidentFieldID:
		return m.OldIncidentFieldID(ctx)
	case incidentfieldoption.FieldType:
		return m.OldType(ctx)
	case incidentfieldoption.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentFieldOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentFieldOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentfieldoption.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidentfieldoption.FieldIncidentFieldID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentFieldID(v)
		return nil
	case incidentfieldoption.FieldType:
		v, ok := value.(incidentfieldoption.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case incidentfieldoption.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentFieldOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentFieldOptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentFieldOptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentFieldOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentFieldOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentFieldOptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentfieldoption.FieldArchiveTime) {
		fields = append(fields, incidentfieldoption.FieldArchiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentFieldOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentFieldOptionMutation) ClearField(name string) error {
	switch name {
	case incidentfieldoption.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown IncidentFieldOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentFieldOptionMutation) ResetField(name string) error {
	switch name {
	case incidentfieldoption.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidentfieldoption.FieldIncidentFieldID:
		m.ResetIncidentFieldID()
		return nil
	case incidentfieldoption.FieldType:
		m.ResetType()
		return nil
	case incidentfieldoption.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown IncidentFieldOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentFieldOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.incident_field != nil {
		edges = append(edges, incidentfieldoption.EdgeIncidentField)
	}
	if m.incidents != nil {
		edges = append(edges, incidentfieldoption.EdgeIncidents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentFieldOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentfieldoption.EdgeIncidentField:
		if id := m.incident_field; id != nil {
			return []ent.Value{*id}
		}
	case incidentfieldoption.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentFieldOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedincidents != nil {
		edges = append(edges, incidentfieldoption.EdgeIncidents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentFieldOptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentfieldoption.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentFieldOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedincident_field {
		edges = append(edges, incidentfieldoption.EdgeIncidentField)
	}
	if m.clearedincidents {
		edges = append(edges, incidentfieldoption.EdgeIncidents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentFieldOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentfieldoption.EdgeIncidentField:
		return m.clearedincident_field
	case incidentfieldoption.EdgeIncidents:
		return m.clearedincidents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentFieldOptionMutation) ClearEdge(name string) error {
	switch name {
	case incidentfieldoption.EdgeIncidentField:
		m.ClearIncidentField()
		return nil
	}
	return fmt.Errorf("unknown IncidentFieldOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentFieldOptionMutation) ResetEdge(name string) error {
	switch name {
	case incidentfieldoption.EdgeIncidentField:
		m.ResetIncidentField()
		return nil
	case incidentfieldoption.EdgeIncidents:
		m.ResetIncidents()
		return nil
	}
	return fmt.Errorf("unknown IncidentFieldOption edge %s", name)
}

// IncidentLinkMutation represents an operation that mutates the IncidentLink nodes in the graph.
type IncidentLinkMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	description            *string
	link_type              *incidentlink.LinkType
	clearedFields          map[string]struct{}
	incident               *uuid.UUID
	clearedincident        bool
	linked_incident        *uuid.UUID
	clearedlinked_incident bool
	done                   bool
	oldValue               func(context.Context) (*IncidentLink, error)
	predicates             []predicate.IncidentLink
}

var _ ent.Mutation = (*IncidentLinkMutation)(nil)

// incidentlinkOption allows management of the mutation configuration using functional options.
type incidentlinkOption func(*IncidentLinkMutation)

// newIncidentLinkMutation creates new mutation for the IncidentLink entity.
func newIncidentLinkMutation(c config, op Op, opts ...incidentlinkOption) *IncidentLinkMutation {
	m := &IncidentLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentLinkID sets the ID field of the mutation.
func withIncidentLinkID(id int) incidentlinkOption {
	return func(m *IncidentLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentLink
		)
		m.oldValue = func(ctx context.Context) (*IncidentLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentLink sets the old IncidentLink of the mutation.
func withIncidentLink(node *IncidentLink) incidentlinkOption {
	return func(m *IncidentLinkMutation) {
		m.oldValue = func(context.Context) (*IncidentLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentLinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentLinkMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentLinkMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentLink entity.
// If the IncidentLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentLinkMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentLinkMutation) ResetIncidentID() {
	m.incident = nil
}

// SetLinkedIncidentID sets the "linked_incident_id" field.
func (m *IncidentLinkMutation) SetLinkedIncidentID(u uuid.UUID) {
	m.linked_incident = &u
}

// LinkedIncidentID returns the value of the "linked_incident_id" field in the mutation.
func (m *IncidentLinkMutation) LinkedIncidentID() (r uuid.UUID, exists bool) {
	v := m.linked_incident
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedIncidentID returns the old "linked_incident_id" field's value of the IncidentLink entity.
// If the IncidentLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentLinkMutation) OldLinkedIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedIncidentID: %w", err)
	}
	return oldValue.LinkedIncidentID, nil
}

// ResetLinkedIncidentID resets all changes to the "linked_incident_id" field.
func (m *IncidentLinkMutation) ResetLinkedIncidentID() {
	m.linked_incident = nil
}

// SetDescription sets the "description" field.
func (m *IncidentLinkMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentLinkMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentLink entity.
// If the IncidentLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentLinkMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentLinkMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidentlink.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentLinkMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidentlink.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentLinkMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidentlink.FieldDescription)
}

// SetLinkType sets the "link_type" field.
func (m *IncidentLinkMutation) SetLinkType(it incidentlink.LinkType) {
	m.link_type = &it
}

// LinkType returns the value of the "link_type" field in the mutation.
func (m *IncidentLinkMutation) LinkType() (r incidentlink.LinkType, exists bool) {
	v := m.link_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkType returns the old "link_type" field's value of the IncidentLink entity.
// If the IncidentLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentLinkMutation) OldLinkType(ctx context.Context) (v incidentlink.LinkType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkType: %w", err)
	}
	return oldValue.LinkType, nil
}

// ResetLinkType resets all changes to the "link_type" field.
func (m *IncidentLinkMutation) ResetLinkType() {
	m.link_type = nil
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentLinkMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentlink.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentLinkMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentLinkMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentLinkMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// ClearLinkedIncident clears the "linked_incident" edge to the Incident entity.
func (m *IncidentLinkMutation) ClearLinkedIncident() {
	m.clearedlinked_incident = true
	m.clearedFields[incidentlink.FieldLinkedIncidentID] = struct{}{}
}

// LinkedIncidentCleared reports if the "linked_incident" edge to the Incident entity was cleared.
func (m *IncidentLinkMutation) LinkedIncidentCleared() bool {
	return m.clearedlinked_incident
}

// LinkedIncidentIDs returns the "linked_incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LinkedIncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentLinkMutation) LinkedIncidentIDs() (ids []uuid.UUID) {
	if id := m.linked_incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLinkedIncident resets all changes to the "linked_incident" edge.
func (m *IncidentLinkMutation) ResetLinkedIncident() {
	m.linked_incident = nil
	m.clearedlinked_incident = false
}

// Where appends a list predicates to the IncidentLinkMutation builder.
func (m *IncidentLinkMutation) Where(ps ...predicate.IncidentLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentLink).
func (m *IncidentLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentLinkMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.incident != nil {
		fields = append(fields, incidentlink.FieldIncidentID)
	}
	if m.linked_incident != nil {
		fields = append(fields, incidentlink.FieldLinkedIncidentID)
	}
	if m.description != nil {
		fields = append(fields, incidentlink.FieldDescription)
	}
	if m.link_type != nil {
		fields = append(fields, incidentlink.FieldLinkType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentlink.FieldIncidentID:
		return m.IncidentID()
	case incidentlink.FieldLinkedIncidentID:
		return m.LinkedIncidentID()
	case incidentlink.FieldDescription:
		return m.Description()
	case incidentlink.FieldLinkType:
		return m.LinkType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentlink.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentlink.FieldLinkedIncidentID:
		return m.OldLinkedIncidentID(ctx)
	case incidentlink.FieldDescription:
		return m.OldDescription(ctx)
	case incidentlink.FieldLinkType:
		return m.OldLinkType(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentlink.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentlink.FieldLinkedIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedIncidentID(v)
		return nil
	case incidentlink.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidentlink.FieldLinkType:
		v, ok := value.(incidentlink.LinkType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkType(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentLinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentLinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentlink.FieldDescription) {
		fields = append(fields, incidentlink.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentLinkMutation) ClearField(name string) error {
	switch name {
	case incidentlink.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentLinkMutation) ResetField(name string) error {
	switch name {
	case incidentlink.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentlink.FieldLinkedIncidentID:
		m.ResetLinkedIncidentID()
		return nil
	case incidentlink.FieldDescription:
		m.ResetDescription()
		return nil
	case incidentlink.FieldLinkType:
		m.ResetLinkType()
		return nil
	}
	return fmt.Errorf("unknown IncidentLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.incident != nil {
		edges = append(edges, incidentlink.EdgeIncident)
	}
	if m.linked_incident != nil {
		edges = append(edges, incidentlink.EdgeLinkedIncident)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentlink.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case incidentlink.EdgeLinkedIncident:
		if id := m.linked_incident; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedincident {
		edges = append(edges, incidentlink.EdgeIncident)
	}
	if m.clearedlinked_incident {
		edges = append(edges, incidentlink.EdgeLinkedIncident)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentlink.EdgeIncident:
		return m.clearedincident
	case incidentlink.EdgeLinkedIncident:
		return m.clearedlinked_incident
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentLinkMutation) ClearEdge(name string) error {
	switch name {
	case incidentlink.EdgeIncident:
		m.ClearIncident()
		return nil
	case incidentlink.EdgeLinkedIncident:
		m.ClearLinkedIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentLinkMutation) ResetEdge(name string) error {
	switch name {
	case incidentlink.EdgeIncident:
		m.ResetIncident()
		return nil
	case incidentlink.EdgeLinkedIncident:
		m.ResetLinkedIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentLink edge %s", name)
}

// IncidentMilestoneMutation represents an operation that mutates the IncidentMilestone nodes in the graph.
type IncidentMilestoneMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	_type           *incidentmilestone.Type
	time            *time.Time
	clearedFields   map[string]struct{}
	incident        *uuid.UUID
	clearedincident bool
	done            bool
	oldValue        func(context.Context) (*IncidentMilestone, error)
	predicates      []predicate.IncidentMilestone
}

var _ ent.Mutation = (*IncidentMilestoneMutation)(nil)

// incidentmilestoneOption allows management of the mutation configuration using functional options.
type incidentmilestoneOption func(*IncidentMilestoneMutation)

// newIncidentMilestoneMutation creates new mutation for the IncidentMilestone entity.
func newIncidentMilestoneMutation(c config, op Op, opts ...incidentmilestoneOption) *IncidentMilestoneMutation {
	m := &IncidentMilestoneMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentMilestone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentMilestoneID sets the ID field of the mutation.
func withIncidentMilestoneID(id uuid.UUID) incidentmilestoneOption {
	return func(m *IncidentMilestoneMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentMilestone
		)
		m.oldValue = func(ctx context.Context) (*IncidentMilestone, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentMilestone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentMilestone sets the old IncidentMilestone of the mutation.
func withIncidentMilestone(node *IncidentMilestone) incidentmilestoneOption {
	return func(m *IncidentMilestoneMutation) {
		m.oldValue = func(context.Context) (*IncidentMilestone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentMilestoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentMilestoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentMilestone entities.
func (m *IncidentMilestoneMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentMilestoneMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentMilestoneMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentMilestone.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentMilestoneMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentMilestoneMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentMilestone entity.
// If the IncidentMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMilestoneMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentMilestoneMutation) ResetIncidentID() {
	m.incident = nil
}

// SetType sets the "type" field.
func (m *IncidentMilestoneMutation) SetType(i incidentmilestone.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *IncidentMilestoneMutation) GetType() (r incidentmilestone.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the IncidentMilestone entity.
// If the IncidentMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMilestoneMutation) OldType(ctx context.Context) (v incidentmilestone.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *IncidentMilestoneMutation) ResetType() {
	m._type = nil
}

// SetTime sets the "time" field.
func (m *IncidentMilestoneMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *IncidentMilestoneMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the IncidentMilestone entity.
// If the IncidentMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMilestoneMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *IncidentMilestoneMutation) ResetTime() {
	m.time = nil
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentMilestoneMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentmilestone.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentMilestoneMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentMilestoneMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentMilestoneMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// Where appends a list predicates to the IncidentMilestoneMutation builder.
func (m *IncidentMilestoneMutation) Where(ps ...predicate.IncidentMilestone) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentMilestoneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentMilestoneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentMilestone, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentMilestoneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentMilestoneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentMilestone).
func (m *IncidentMilestoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentMilestoneMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.incident != nil {
		fields = append(fields, incidentmilestone.FieldIncidentID)
	}
	if m._type != nil {
		fields = append(fields, incidentmilestone.FieldType)
	}
	if m.time != nil {
		fields = append(fields, incidentmilestone.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentMilestoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentmilestone.FieldIncidentID:
		return m.IncidentID()
	case incidentmilestone.FieldType:
		return m.GetType()
	case incidentmilestone.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentMilestoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentmilestone.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentmilestone.FieldType:
		return m.OldType(ctx)
	case incidentmilestone.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentMilestone field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMilestoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentmilestone.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentmilestone.FieldType:
		v, ok := value.(incidentmilestone.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case incidentmilestone.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentMilestone field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentMilestoneMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentMilestoneMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMilestoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentMilestone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentMilestoneMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentMilestoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentMilestoneMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentMilestone nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentMilestoneMutation) ResetField(name string) error {
	switch name {
	case incidentmilestone.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentmilestone.FieldType:
		m.ResetType()
		return nil
	case incidentmilestone.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown IncidentMilestone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentMilestoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.incident != nil {
		edges = append(edges, incidentmilestone.EdgeIncident)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentMilestoneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentmilestone.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentMilestoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentMilestoneMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentMilestoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedincident {
		edges = append(edges, incidentmilestone.EdgeIncident)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentMilestoneMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentmilestone.EdgeIncident:
		return m.clearedincident
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentMilestoneMutation) ClearEdge(name string) error {
	switch name {
	case incidentmilestone.EdgeIncident:
		m.ClearIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentMilestone unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentMilestoneMutation) ResetEdge(name string) error {
	switch name {
	case incidentmilestone.EdgeIncident:
		m.ResetIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentMilestone edge %s", name)
}

// IncidentRoleMutation represents an operation that mutates the IncidentRole nodes in the graph.
type IncidentRoleMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	name                     *string
	provider_id              *string
	required                 *bool
	clearedFields            map[string]struct{}
	assignments              map[uuid.UUID]struct{}
	removedassignments       map[uuid.UUID]struct{}
	clearedassignments       bool
	debrief_questions        map[uuid.UUID]struct{}
	removeddebrief_questions map[uuid.UUID]struct{}
	cleareddebrief_questions bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentRole, error)
	predicates               []predicate.IncidentRole
}

var _ ent.Mutation = (*IncidentRoleMutation)(nil)

// incidentroleOption allows management of the mutation configuration using functional options.
type incidentroleOption func(*IncidentRoleMutation)

// newIncidentRoleMutation creates new mutation for the IncidentRole entity.
func newIncidentRoleMutation(c config, op Op, opts ...incidentroleOption) *IncidentRoleMutation {
	m := &IncidentRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentRoleID sets the ID field of the mutation.
func withIncidentRoleID(id uuid.UUID) incidentroleOption {
	return func(m *IncidentRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentRole
		)
		m.oldValue = func(ctx context.Context) (*IncidentRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentRole sets the old IncidentRole of the mutation.
func withIncidentRole(node *IncidentRole) incidentroleOption {
	return func(m *IncidentRoleMutation) {
		m.oldValue = func(context.Context) (*IncidentRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentRole entities.
func (m *IncidentRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentRoleMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentRoleMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentRole entity.
// If the IncidentRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentRoleMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidentrole.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentRoleMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidentrole.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentRoleMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidentrole.FieldArchiveTime)
}

// SetName sets the "name" field.
func (m *IncidentRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncidentRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncidentRole entity.
// If the IncidentRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncidentRoleMutation) ResetName() {
	m.name = nil
}

// SetProviderID sets the "provider_id" field.
func (m *IncidentRoleMutation) SetProviderID(s string) {
	m.provider_id = &s
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *IncidentRoleMutation) ProviderID() (r string, exists bool) {
	v := m.provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the IncidentRole entity.
// If the IncidentRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleMutation) OldProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *IncidentRoleMutation) ResetProviderID() {
	m.provider_id = nil
}

// SetRequired sets the "required" field.
func (m *IncidentRoleMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *IncidentRoleMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the IncidentRole entity.
// If the IncidentRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *IncidentRoleMutation) ResetRequired() {
	m.required = nil
}

// AddAssignmentIDs adds the "assignments" edge to the IncidentRoleAssignment entity by ids.
func (m *IncidentRoleMutation) AddAssignmentIDs(ids ...uuid.UUID) {
	if m.assignments == nil {
		m.assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the IncidentRoleAssignment entity.
func (m *IncidentRoleMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the IncidentRoleAssignment entity was cleared.
func (m *IncidentRoleMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the IncidentRoleAssignment entity by IDs.
func (m *IncidentRoleMutation) RemoveAssignmentIDs(ids ...uuid.UUID) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the IncidentRoleAssignment entity.
func (m *IncidentRoleMutation) RemovedAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *IncidentRoleMutation) AssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *IncidentRoleMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// AddDebriefQuestionIDs adds the "debrief_questions" edge to the IncidentDebriefQuestion entity by ids.
func (m *IncidentRoleMutation) AddDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.debrief_questions == nil {
		m.debrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debrief_questions[ids[i]] = struct{}{}
	}
}

// ClearDebriefQuestions clears the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentRoleMutation) ClearDebriefQuestions() {
	m.cleareddebrief_questions = true
}

// DebriefQuestionsCleared reports if the "debrief_questions" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentRoleMutation) DebriefQuestionsCleared() bool {
	return m.cleareddebrief_questions
}

// RemoveDebriefQuestionIDs removes the "debrief_questions" edge to the IncidentDebriefQuestion entity by IDs.
func (m *IncidentRoleMutation) RemoveDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.removeddebrief_questions == nil {
		m.removeddebrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debrief_questions, ids[i])
		m.removeddebrief_questions[ids[i]] = struct{}{}
	}
}

// RemovedDebriefQuestions returns the removed IDs of the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentRoleMutation) RemovedDebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebrief_questions {
		ids = append(ids, id)
	}
	return
}

// DebriefQuestionsIDs returns the "debrief_questions" edge IDs in the mutation.
func (m *IncidentRoleMutation) DebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.debrief_questions {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefQuestions resets all changes to the "debrief_questions" edge.
func (m *IncidentRoleMutation) ResetDebriefQuestions() {
	m.debrief_questions = nil
	m.cleareddebrief_questions = false
	m.removeddebrief_questions = nil
}

// Where appends a list predicates to the IncidentRoleMutation builder.
func (m *IncidentRoleMutation) Where(ps ...predicate.IncidentRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentRole).
func (m *IncidentRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.archive_time != nil {
		fields = append(fields, incidentrole.FieldArchiveTime)
	}
	if m.name != nil {
		fields = append(fields, incidentrole.FieldName)
	}
	if m.provider_id != nil {
		fields = append(fields, incidentrole.FieldProviderID)
	}
	if m.required != nil {
		fields = append(fields, incidentrole.FieldRequired)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentrole.FieldArchiveTime:
		return m.ArchiveTime()
	case incidentrole.FieldName:
		return m.Name()
	case incidentrole.FieldProviderID:
		return m.ProviderID()
	case incidentrole.FieldRequired:
		return m.Required()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentrole.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidentrole.FieldName:
		return m.OldName(ctx)
	case incidentrole.FieldProviderID:
		return m.OldProviderID(ctx)
	case incidentrole.FieldRequired:
		return m.OldRequired(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentrole.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidentrole.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case incidentrole.FieldProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case incidentrole.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentrole.FieldArchiveTime) {
		fields = append(fields, incidentrole.FieldArchiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentRoleMutation) ClearField(name string) error {
	switch name {
	case incidentrole.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown IncidentRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentRoleMutation) ResetField(name string) error {
	switch name {
	case incidentrole.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidentrole.FieldName:
		m.ResetName()
		return nil
	case incidentrole.FieldProviderID:
		m.ResetProviderID()
		return nil
	case incidentrole.FieldRequired:
		m.ResetRequired()
		return nil
	}
	return fmt.Errorf("unknown IncidentRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.assignments != nil {
		edges = append(edges, incidentrole.EdgeAssignments)
	}
	if m.debrief_questions != nil {
		edges = append(edges, incidentrole.EdgeDebriefQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentrole.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	case incidentrole.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.debrief_questions))
		for id := range m.debrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedassignments != nil {
		edges = append(edges, incidentrole.EdgeAssignments)
	}
	if m.removeddebrief_questions != nil {
		edges = append(edges, incidentrole.EdgeDebriefQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentrole.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	case incidentrole.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.removeddebrief_questions))
		for id := range m.removeddebrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedassignments {
		edges = append(edges, incidentrole.EdgeAssignments)
	}
	if m.cleareddebrief_questions {
		edges = append(edges, incidentrole.EdgeDebriefQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentrole.EdgeAssignments:
		return m.clearedassignments
	case incidentrole.EdgeDebriefQuestions:
		return m.cleareddebrief_questions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentRoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentRoleMutation) ResetEdge(name string) error {
	switch name {
	case incidentrole.EdgeAssignments:
		m.ResetAssignments()
		return nil
	case incidentrole.EdgeDebriefQuestions:
		m.ResetDebriefQuestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentRole edge %s", name)
}

// IncidentRoleAssignmentMutation represents an operation that mutates the IncidentRoleAssignment nodes in the graph.
type IncidentRoleAssignmentMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	clearedFields   map[string]struct{}
	role            *uuid.UUID
	clearedrole     bool
	incident        *uuid.UUID
	clearedincident bool
	user            *uuid.UUID
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*IncidentRoleAssignment, error)
	predicates      []predicate.IncidentRoleAssignment
}

var _ ent.Mutation = (*IncidentRoleAssignmentMutation)(nil)

// incidentroleassignmentOption allows management of the mutation configuration using functional options.
type incidentroleassignmentOption func(*IncidentRoleAssignmentMutation)

// newIncidentRoleAssignmentMutation creates new mutation for the IncidentRoleAssignment entity.
func newIncidentRoleAssignmentMutation(c config, op Op, opts ...incidentroleassignmentOption) *IncidentRoleAssignmentMutation {
	m := &IncidentRoleAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentRoleAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentRoleAssignmentID sets the ID field of the mutation.
func withIncidentRoleAssignmentID(id uuid.UUID) incidentroleassignmentOption {
	return func(m *IncidentRoleAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentRoleAssignment
		)
		m.oldValue = func(ctx context.Context) (*IncidentRoleAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentRoleAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentRoleAssignment sets the old IncidentRoleAssignment of the mutation.
func withIncidentRoleAssignment(node *IncidentRoleAssignment) incidentroleassignmentOption {
	return func(m *IncidentRoleAssignmentMutation) {
		m.oldValue = func(context.Context) (*IncidentRoleAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentRoleAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentRoleAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentRoleAssignment entities.
func (m *IncidentRoleAssignmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentRoleAssignmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentRoleAssignmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentRoleAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleID sets the "role_id" field.
func (m *IncidentRoleAssignmentMutation) SetRoleID(u uuid.UUID) {
	m.role = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *IncidentRoleAssignmentMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the IncidentRoleAssignment entity.
// If the IncidentRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleAssignmentMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *IncidentRoleAssignmentMutation) ResetRoleID() {
	m.role = nil
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentRoleAssignmentMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentRoleAssignmentMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentRoleAssignment entity.
// If the IncidentRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleAssignmentMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentRoleAssignmentMutation) ResetIncidentID() {
	m.incident = nil
}

// SetUserID sets the "user_id" field.
func (m *IncidentRoleAssignmentMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IncidentRoleAssignmentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the IncidentRoleAssignment entity.
// If the IncidentRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleAssignmentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IncidentRoleAssignmentMutation) ResetUserID() {
	m.user = nil
}

// ClearRole clears the "role" edge to the IncidentRole entity.
func (m *IncidentRoleAssignmentMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[incidentroleassignment.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the IncidentRole entity was cleared.
func (m *IncidentRoleAssignmentMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *IncidentRoleAssignmentMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *IncidentRoleAssignmentMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentRoleAssignmentMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentroleassignment.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentRoleAssignmentMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentRoleAssignmentMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentRoleAssignmentMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *IncidentRoleAssignmentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[incidentroleassignment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *IncidentRoleAssignmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *IncidentRoleAssignmentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *IncidentRoleAssignmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the IncidentRoleAssignmentMutation builder.
func (m *IncidentRoleAssignmentMutation) Where(ps ...predicate.IncidentRoleAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentRoleAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentRoleAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentRoleAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentRoleAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentRoleAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentRoleAssignment).
func (m *IncidentRoleAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentRoleAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.role != nil {
		fields = append(fields, incidentroleassignment.FieldRoleID)
	}
	if m.incident != nil {
		fields = append(fields, incidentroleassignment.FieldIncidentID)
	}
	if m.user != nil {
		fields = append(fields, incidentroleassignment.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentRoleAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentroleassignment.FieldRoleID:
		return m.RoleID()
	case incidentroleassignment.FieldIncidentID:
		return m.IncidentID()
	case incidentroleassignment.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentRoleAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentroleassignment.FieldRoleID:
		return m.OldRoleID(ctx)
	case incidentroleassignment.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentroleassignment.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentRoleAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRoleAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentroleassignment.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case incidentroleassignment.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentroleassignment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentRoleAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentRoleAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentRoleAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRoleAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentRoleAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentRoleAssignmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentRoleAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentRoleAssignmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentRoleAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentRoleAssignmentMutation) ResetField(name string) error {
	switch name {
	case incidentroleassignment.FieldRoleID:
		m.ResetRoleID()
		return nil
	case incidentroleassignment.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentroleassignment.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown IncidentRoleAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentRoleAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.role != nil {
		edges = append(edges, incidentroleassignment.EdgeRole)
	}
	if m.incident != nil {
		edges = append(edges, incidentroleassignment.EdgeIncident)
	}
	if m.user != nil {
		edges = append(edges, incidentroleassignment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentRoleAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentroleassignment.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case incidentroleassignment.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case incidentroleassignment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentRoleAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentRoleAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentRoleAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrole {
		edges = append(edges, incidentroleassignment.EdgeRole)
	}
	if m.clearedincident {
		edges = append(edges, incidentroleassignment.EdgeIncident)
	}
	if m.cleareduser {
		edges = append(edges, incidentroleassignment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentRoleAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentroleassignment.EdgeRole:
		return m.clearedrole
	case incidentroleassignment.EdgeIncident:
		return m.clearedincident
	case incidentroleassignment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentRoleAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case incidentroleassignment.EdgeRole:
		m.ClearRole()
		return nil
	case incidentroleassignment.EdgeIncident:
		m.ClearIncident()
		return nil
	case incidentroleassignment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown IncidentRoleAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentRoleAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case incidentroleassignment.EdgeRole:
		m.ResetRole()
		return nil
	case incidentroleassignment.EdgeIncident:
		m.ResetIncident()
		return nil
	case incidentroleassignment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown IncidentRoleAssignment edge %s", name)
}

// IncidentSeverityMutation represents an operation that mutates the IncidentSeverity nodes in the graph.
type IncidentSeverityMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	name                     *string
	color                    *string
	description              *string
	clearedFields            map[string]struct{}
	incidents                map[uuid.UUID]struct{}
	removedincidents         map[uuid.UUID]struct{}
	clearedincidents         bool
	debrief_questions        map[uuid.UUID]struct{}
	removeddebrief_questions map[uuid.UUID]struct{}
	cleareddebrief_questions bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentSeverity, error)
	predicates               []predicate.IncidentSeverity
}

var _ ent.Mutation = (*IncidentSeverityMutation)(nil)

// incidentseverityOption allows management of the mutation configuration using functional options.
type incidentseverityOption func(*IncidentSeverityMutation)

// newIncidentSeverityMutation creates new mutation for the IncidentSeverity entity.
func newIncidentSeverityMutation(c config, op Op, opts ...incidentseverityOption) *IncidentSeverityMutation {
	m := &IncidentSeverityMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentSeverity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentSeverityID sets the ID field of the mutation.
func withIncidentSeverityID(id uuid.UUID) incidentseverityOption {
	return func(m *IncidentSeverityMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentSeverity
		)
		m.oldValue = func(ctx context.Context) (*IncidentSeverity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentSeverity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentSeverity sets the old IncidentSeverity of the mutation.
func withIncidentSeverity(node *IncidentSeverity) incidentseverityOption {
	return func(m *IncidentSeverityMutation) {
		m.oldValue = func(context.Context) (*IncidentSeverity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentSeverityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentSeverityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentSeverity entities.
func (m *IncidentSeverityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentSeverityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentSeverityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentSeverity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentSeverityMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentSeverityMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentSeverity entity.
// If the IncidentSeverity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentSeverityMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentSeverityMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidentseverity.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentSeverityMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidentseverity.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentSeverityMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidentseverity.FieldArchiveTime)
}

// SetName sets the "name" field.
func (m *IncidentSeverityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncidentSeverityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncidentSeverity entity.
// If the IncidentSeverity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentSeverityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncidentSeverityMutation) ResetName() {
	m.name = nil
}

// SetColor sets the "color" field.
func (m *IncidentSeverityMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *IncidentSeverityMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the IncidentSeverity entity.
// If the IncidentSeverity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentSeverityMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *IncidentSeverityMutation) ClearColor() {
	m.color = nil
	m.clearedFields[incidentseverity.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *IncidentSeverityMutation) ColorCleared() bool {
	_, ok := m.clearedFields[incidentseverity.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *IncidentSeverityMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, incidentseverity.FieldColor)
}

// SetDescription sets the "description" field.
func (m *IncidentSeverityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentSeverityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentSeverity entity.
// If the IncidentSeverity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentSeverityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentSeverityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidentseverity.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentSeverityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidentseverity.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentSeverityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidentseverity.FieldDescription)
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *IncidentSeverityMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *IncidentSeverityMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *IncidentSeverityMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *IncidentSeverityMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *IncidentSeverityMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *IncidentSeverityMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *IncidentSeverityMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// AddDebriefQuestionIDs adds the "debrief_questions" edge to the IncidentDebriefQuestion entity by ids.
func (m *IncidentSeverityMutation) AddDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.debrief_questions == nil {
		m.debrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debrief_questions[ids[i]] = struct{}{}
	}
}

// ClearDebriefQuestions clears the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentSeverityMutation) ClearDebriefQuestions() {
	m.cleareddebrief_questions = true
}

// DebriefQuestionsCleared reports if the "debrief_questions" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentSeverityMutation) DebriefQuestionsCleared() bool {
	return m.cleareddebrief_questions
}

// RemoveDebriefQuestionIDs removes the "debrief_questions" edge to the IncidentDebriefQuestion entity by IDs.
func (m *IncidentSeverityMutation) RemoveDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.removeddebrief_questions == nil {
		m.removeddebrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debrief_questions, ids[i])
		m.removeddebrief_questions[ids[i]] = struct{}{}
	}
}

// RemovedDebriefQuestions returns the removed IDs of the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentSeverityMutation) RemovedDebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebrief_questions {
		ids = append(ids, id)
	}
	return
}

// DebriefQuestionsIDs returns the "debrief_questions" edge IDs in the mutation.
func (m *IncidentSeverityMutation) DebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.debrief_questions {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefQuestions resets all changes to the "debrief_questions" edge.
func (m *IncidentSeverityMutation) ResetDebriefQuestions() {
	m.debrief_questions = nil
	m.cleareddebrief_questions = false
	m.removeddebrief_questions = nil
}

// Where appends a list predicates to the IncidentSeverityMutation builder.
func (m *IncidentSeverityMutation) Where(ps ...predicate.IncidentSeverity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentSeverityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentSeverityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentSeverity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentSeverityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentSeverityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentSeverity).
func (m *IncidentSeverityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentSeverityMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.archive_time != nil {
		fields = append(fields, incidentseverity.FieldArchiveTime)
	}
	if m.name != nil {
		fields = append(fields, incidentseverity.FieldName)
	}
	if m.color != nil {
		fields = append(fields, incidentseverity.FieldColor)
	}
	if m.description != nil {
		fields = append(fields, incidentseverity.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentSeverityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentseverity.FieldArchiveTime:
		return m.ArchiveTime()
	case incidentseverity.FieldName:
		return m.Name()
	case incidentseverity.FieldColor:
		return m.Color()
	case incidentseverity.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentSeverityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentseverity.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidentseverity.FieldName:
		return m.OldName(ctx)
	case incidentseverity.FieldColor:
		return m.OldColor(ctx)
	case incidentseverity.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentSeverity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentSeverityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentseverity.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidentseverity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case incidentseverity.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case incidentseverity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentSeverity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentSeverityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentSeverityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentSeverityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentSeverity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentSeverityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentseverity.FieldArchiveTime) {
		fields = append(fields, incidentseverity.FieldArchiveTime)
	}
	if m.FieldCleared(incidentseverity.FieldColor) {
		fields = append(fields, incidentseverity.FieldColor)
	}
	if m.FieldCleared(incidentseverity.FieldDescription) {
		fields = append(fields, incidentseverity.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentSeverityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentSeverityMutation) ClearField(name string) error {
	switch name {
	case incidentseverity.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	case incidentseverity.FieldColor:
		m.ClearColor()
		return nil
	case incidentseverity.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentSeverity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentSeverityMutation) ResetField(name string) error {
	switch name {
	case incidentseverity.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidentseverity.FieldName:
		m.ResetName()
		return nil
	case incidentseverity.FieldColor:
		m.ResetColor()
		return nil
	case incidentseverity.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentSeverity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentSeverityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.incidents != nil {
		edges = append(edges, incidentseverity.EdgeIncidents)
	}
	if m.debrief_questions != nil {
		edges = append(edges, incidentseverity.EdgeDebriefQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentSeverityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentseverity.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	case incidentseverity.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.debrief_questions))
		for id := range m.debrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentSeverityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedincidents != nil {
		edges = append(edges, incidentseverity.EdgeIncidents)
	}
	if m.removeddebrief_questions != nil {
		edges = append(edges, incidentseverity.EdgeDebriefQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentSeverityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentseverity.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	case incidentseverity.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.removeddebrief_questions))
		for id := range m.removeddebrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentSeverityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedincidents {
		edges = append(edges, incidentseverity.EdgeIncidents)
	}
	if m.cleareddebrief_questions {
		edges = append(edges, incidentseverity.EdgeDebriefQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentSeverityMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentseverity.EdgeIncidents:
		return m.clearedincidents
	case incidentseverity.EdgeDebriefQuestions:
		return m.cleareddebrief_questions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentSeverityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentSeverity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentSeverityMutation) ResetEdge(name string) error {
	switch name {
	case incidentseverity.EdgeIncidents:
		m.ResetIncidents()
		return nil
	case incidentseverity.EdgeDebriefQuestions:
		m.ResetDebriefQuestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentSeverity edge %s", name)
}

// IncidentTagMutation represents an operation that mutates the IncidentTag nodes in the graph.
type IncidentTagMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	key                      *string
	value                    *string
	clearedFields            map[string]struct{}
	incidents                map[uuid.UUID]struct{}
	removedincidents         map[uuid.UUID]struct{}
	clearedincidents         bool
	debrief_questions        map[uuid.UUID]struct{}
	removeddebrief_questions map[uuid.UUID]struct{}
	cleareddebrief_questions bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentTag, error)
	predicates               []predicate.IncidentTag
}

var _ ent.Mutation = (*IncidentTagMutation)(nil)

// incidenttagOption allows management of the mutation configuration using functional options.
type incidenttagOption func(*IncidentTagMutation)

// newIncidentTagMutation creates new mutation for the IncidentTag entity.
func newIncidentTagMutation(c config, op Op, opts ...incidenttagOption) *IncidentTagMutation {
	m := &IncidentTagMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentTagID sets the ID field of the mutation.
func withIncidentTagID(id uuid.UUID) incidenttagOption {
	return func(m *IncidentTagMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentTag
		)
		m.oldValue = func(ctx context.Context) (*IncidentTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentTag sets the old IncidentTag of the mutation.
func withIncidentTag(node *IncidentTag) incidenttagOption {
	return func(m *IncidentTagMutation) {
		m.oldValue = func(context.Context) (*IncidentTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentTag entities.
func (m *IncidentTagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentTagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentTagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentTagMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentTagMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentTag entity.
// If the IncidentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTagMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentTagMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidenttag.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentTagMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidenttag.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentTagMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidenttag.FieldArchiveTime)
}

// SetKey sets the "key" field.
func (m *IncidentTagMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *IncidentTagMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the IncidentTag entity.
// If the IncidentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTagMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *IncidentTagMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *IncidentTagMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *IncidentTagMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the IncidentTag entity.
// If the IncidentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTagMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *IncidentTagMutation) ResetValue() {
	m.value = nil
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *IncidentTagMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *IncidentTagMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *IncidentTagMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *IncidentTagMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *IncidentTagMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *IncidentTagMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *IncidentTagMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// AddDebriefQuestionIDs adds the "debrief_questions" edge to the IncidentDebriefQuestion entity by ids.
func (m *IncidentTagMutation) AddDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.debrief_questions == nil {
		m.debrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debrief_questions[ids[i]] = struct{}{}
	}
}

// ClearDebriefQuestions clears the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentTagMutation) ClearDebriefQuestions() {
	m.cleareddebrief_questions = true
}

// DebriefQuestionsCleared reports if the "debrief_questions" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentTagMutation) DebriefQuestionsCleared() bool {
	return m.cleareddebrief_questions
}

// RemoveDebriefQuestionIDs removes the "debrief_questions" edge to the IncidentDebriefQuestion entity by IDs.
func (m *IncidentTagMutation) RemoveDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.removeddebrief_questions == nil {
		m.removeddebrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debrief_questions, ids[i])
		m.removeddebrief_questions[ids[i]] = struct{}{}
	}
}

// RemovedDebriefQuestions returns the removed IDs of the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentTagMutation) RemovedDebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebrief_questions {
		ids = append(ids, id)
	}
	return
}

// DebriefQuestionsIDs returns the "debrief_questions" edge IDs in the mutation.
func (m *IncidentTagMutation) DebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.debrief_questions {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefQuestions resets all changes to the "debrief_questions" edge.
func (m *IncidentTagMutation) ResetDebriefQuestions() {
	m.debrief_questions = nil
	m.cleareddebrief_questions = false
	m.removeddebrief_questions = nil
}

// Where appends a list predicates to the IncidentTagMutation builder.
func (m *IncidentTagMutation) Where(ps ...predicate.IncidentTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentTag).
func (m *IncidentTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentTagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.archive_time != nil {
		fields = append(fields, incidenttag.FieldArchiveTime)
	}
	if m.key != nil {
		fields = append(fields, incidenttag.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, incidenttag.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidenttag.FieldArchiveTime:
		return m.ArchiveTime()
	case incidenttag.FieldKey:
		return m.Key()
	case incidenttag.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidenttag.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidenttag.FieldKey:
		return m.OldKey(ctx)
	case incidenttag.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidenttag.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidenttag.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case incidenttag.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidenttag.FieldArchiveTime) {
		fields = append(fields, incidenttag.FieldArchiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentTagMutation) ClearField(name string) error {
	switch name {
	case incidenttag.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown IncidentTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentTagMutation) ResetField(name string) error {
	switch name {
	case incidenttag.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidenttag.FieldKey:
		m.ResetKey()
		return nil
	case incidenttag.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown IncidentTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.incidents != nil {
		edges = append(edges, incidenttag.EdgeIncidents)
	}
	if m.debrief_questions != nil {
		edges = append(edges, incidenttag.EdgeDebriefQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidenttag.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	case incidenttag.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.debrief_questions))
		for id := range m.debrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedincidents != nil {
		edges = append(edges, incidenttag.EdgeIncidents)
	}
	if m.removeddebrief_questions != nil {
		edges = append(edges, incidenttag.EdgeDebriefQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidenttag.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	case incidenttag.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.removeddebrief_questions))
		for id := range m.removeddebrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedincidents {
		edges = append(edges, incidenttag.EdgeIncidents)
	}
	if m.cleareddebrief_questions {
		edges = append(edges, incidenttag.EdgeDebriefQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentTagMutation) EdgeCleared(name string) bool {
	switch name {
	case incidenttag.EdgeIncidents:
		return m.clearedincidents
	case incidenttag.EdgeDebriefQuestions:
		return m.cleareddebrief_questions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentTagMutation) ResetEdge(name string) error {
	switch name {
	case incidenttag.EdgeIncidents:
		m.ResetIncidents()
		return nil
	case incidenttag.EdgeDebriefQuestions:
		m.ResetDebriefQuestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentTag edge %s", name)
}

// IncidentTeamAssignmentMutation represents an operation that mutates the IncidentTeamAssignment nodes in the graph.
type IncidentTeamAssignmentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	clearedFields   map[string]struct{}
	incident        *uuid.UUID
	clearedincident bool
	team            *uuid.UUID
	clearedteam     bool
	done            bool
	oldValue        func(context.Context) (*IncidentTeamAssignment, error)
	predicates      []predicate.IncidentTeamAssignment
}

var _ ent.Mutation = (*IncidentTeamAssignmentMutation)(nil)

// incidentteamassignmentOption allows management of the mutation configuration using functional options.
type incidentteamassignmentOption func(*IncidentTeamAssignmentMutation)

// newIncidentTeamAssignmentMutation creates new mutation for the IncidentTeamAssignment entity.
func newIncidentTeamAssignmentMutation(c config, op Op, opts ...incidentteamassignmentOption) *IncidentTeamAssignmentMutation {
	m := &IncidentTeamAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentTeamAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentTeamAssignmentID sets the ID field of the mutation.
func withIncidentTeamAssignmentID(id int) incidentteamassignmentOption {
	return func(m *IncidentTeamAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentTeamAssignment
		)
		m.oldValue = func(ctx context.Context) (*IncidentTeamAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentTeamAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentTeamAssignment sets the old IncidentTeamAssignment of the mutation.
func withIncidentTeamAssignment(node *IncidentTeamAssignment) incidentteamassignmentOption {
	return func(m *IncidentTeamAssignmentMutation) {
		m.oldValue = func(context.Context) (*IncidentTeamAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentTeamAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentTeamAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentTeamAssignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentTeamAssignmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentTeamAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentTeamAssignmentMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentTeamAssignmentMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentTeamAssignment entity.
// If the IncidentTeamAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTeamAssignmentMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentTeamAssignmentMutation) ResetIncidentID() {
	m.incident = nil
}

// SetTeamID sets the "team_id" field.
func (m *IncidentTeamAssignmentMutation) SetTeamID(u uuid.UUID) {
	m.team = &u
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *IncidentTeamAssignmentMutation) TeamID() (r uuid.UUID, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the IncidentTeamAssignment entity.
// If the IncidentTeamAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTeamAssignmentMutation) OldTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *IncidentTeamAssignmentMutation) ResetTeamID() {
	m.team = nil
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentTeamAssignmentMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentteamassignment.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentTeamAssignmentMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentTeamAssignmentMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentTeamAssignmentMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *IncidentTeamAssignmentMutation) ClearTeam() {
	m.clearedteam = true
	m.clearedFields[incidentteamassignment.FieldTeamID] = struct{}{}
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *IncidentTeamAssignmentMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *IncidentTeamAssignmentMutation) TeamIDs() (ids []uuid.UUID) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *IncidentTeamAssignmentMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the IncidentTeamAssignmentMutation builder.
func (m *IncidentTeamAssignmentMutation) Where(ps ...predicate.IncidentTeamAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentTeamAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentTeamAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentTeamAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentTeamAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentTeamAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentTeamAssignment).
func (m *IncidentTeamAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentTeamAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.incident != nil {
		fields = append(fields, incidentteamassignment.FieldIncidentID)
	}
	if m.team != nil {
		fields = append(fields, incidentteamassignment.FieldTeamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentTeamAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentteamassignment.FieldIncidentID:
		return m.IncidentID()
	case incidentteamassignment.FieldTeamID:
		return m.TeamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentTeamAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentteamassignment.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentteamassignment.FieldTeamID:
		return m.OldTeamID(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentTeamAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentTeamAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentteamassignment.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentteamassignment.FieldTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentTeamAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentTeamAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentTeamAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentTeamAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentTeamAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentTeamAssignmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentTeamAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentTeamAssignmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentTeamAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentTeamAssignmentMutation) ResetField(name string) error {
	switch name {
	case incidentteamassignment.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentteamassignment.FieldTeamID:
		m.ResetTeamID()
		return nil
	}
	return fmt.Errorf("unknown IncidentTeamAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentTeamAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.incident != nil {
		edges = append(edges, incidentteamassignment.EdgeIncident)
	}
	if m.team != nil {
		edges = append(edges, incidentteamassignment.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentTeamAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentteamassignment.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case incidentteamassignment.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentTeamAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentTeamAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentTeamAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedincident {
		edges = append(edges, incidentteamassignment.EdgeIncident)
	}
	if m.clearedteam {
		edges = append(edges, incidentteamassignment.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentTeamAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentteamassignment.EdgeIncident:
		return m.clearedincident
	case incidentteamassignment.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentTeamAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case incidentteamassignment.EdgeIncident:
		m.ClearIncident()
		return nil
	case incidentteamassignment.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown IncidentTeamAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentTeamAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case incidentteamassignment.EdgeIncident:
		m.ResetIncident()
		return nil
	case incidentteamassignment.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown IncidentTeamAssignment edge %s", name)
}

// IncidentTypeMutation represents an operation that mutates the IncidentType nodes in the graph.
type IncidentTypeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	name                     *string
	clearedFields            map[string]struct{}
	incidents                map[uuid.UUID]struct{}
	removedincidents         map[uuid.UUID]struct{}
	clearedincidents         bool
	debrief_questions        map[uuid.UUID]struct{}
	removeddebrief_questions map[uuid.UUID]struct{}
	cleareddebrief_questions bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentType, error)
	predicates               []predicate.IncidentType
}

var _ ent.Mutation = (*IncidentTypeMutation)(nil)

// incidenttypeOption allows management of the mutation configuration using functional options.
type incidenttypeOption func(*IncidentTypeMutation)

// newIncidentTypeMutation creates new mutation for the IncidentType entity.
func newIncidentTypeMutation(c config, op Op, opts ...incidenttypeOption) *IncidentTypeMutation {
	m := &IncidentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentTypeID sets the ID field of the mutation.
func withIncidentTypeID(id uuid.UUID) incidenttypeOption {
	return func(m *IncidentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentType
		)
		m.oldValue = func(ctx context.Context) (*IncidentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentType sets the old IncidentType of the mutation.
func withIncidentType(node *IncidentType) incidenttypeOption {
	return func(m *IncidentTypeMutation) {
		m.oldValue = func(context.Context) (*IncidentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentType entities.
func (m *IncidentTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentTypeMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentTypeMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentType entity.
// If the IncidentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTypeMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentTypeMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidenttype.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentTypeMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidenttype.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentTypeMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidenttype.FieldArchiveTime)
}

// SetName sets the "name" field.
func (m *IncidentTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncidentTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncidentType entity.
// If the IncidentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncidentTypeMutation) ResetName() {
	m.name = nil
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *IncidentTypeMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *IncidentTypeMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *IncidentTypeMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *IncidentTypeMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *IncidentTypeMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *IncidentTypeMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *IncidentTypeMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// AddDebriefQuestionIDs adds the "debrief_questions" edge to the IncidentDebriefQuestion entity by ids.
func (m *IncidentTypeMutation) AddDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.debrief_questions == nil {
		m.debrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debrief_questions[ids[i]] = struct{}{}
	}
}

// ClearDebriefQuestions clears the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentTypeMutation) ClearDebriefQuestions() {
	m.cleareddebrief_questions = true
}

// DebriefQuestionsCleared reports if the "debrief_questions" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentTypeMutation) DebriefQuestionsCleared() bool {
	return m.cleareddebrief_questions
}

// RemoveDebriefQuestionIDs removes the "debrief_questions" edge to the IncidentDebriefQuestion entity by IDs.
func (m *IncidentTypeMutation) RemoveDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.removeddebrief_questions == nil {
		m.removeddebrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debrief_questions, ids[i])
		m.removeddebrief_questions[ids[i]] = struct{}{}
	}
}

// RemovedDebriefQuestions returns the removed IDs of the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentTypeMutation) RemovedDebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebrief_questions {
		ids = append(ids, id)
	}
	return
}

// DebriefQuestionsIDs returns the "debrief_questions" edge IDs in the mutation.
func (m *IncidentTypeMutation) DebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.debrief_questions {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefQuestions resets all changes to the "debrief_questions" edge.
func (m *IncidentTypeMutation) ResetDebriefQuestions() {
	m.debrief_questions = nil
	m.cleareddebrief_questions = false
	m.removeddebrief_questions = nil
}

// Where appends a list predicates to the IncidentTypeMutation builder.
func (m *IncidentTypeMutation) Where(ps ...predicate.IncidentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentType).
func (m *IncidentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentTypeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.archive_time != nil {
		fields = append(fields, incidenttype.FieldArchiveTime)
	}
	if m.name != nil {
		fields = append(fields, incidenttype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidenttype.FieldArchiveTime:
		return m.ArchiveTime()
	case incidenttype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidenttype.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidenttype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidenttype.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidenttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidenttype.FieldArchiveTime) {
		fields = append(fields, incidenttype.FieldArchiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentTypeMutation) ClearField(name string) error {
	switch name {
	case incidenttype.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown IncidentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentTypeMutation) ResetField(name string) error {
	switch name {
	case incidenttype.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidenttype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown IncidentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.incidents != nil {
		edges = append(edges, incidenttype.EdgeIncidents)
	}
	if m.debrief_questions != nil {
		edges = append(edges, incidenttype.EdgeDebriefQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidenttype.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	case incidenttype.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.debrief_questions))
		for id := range m.debrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedincidents != nil {
		edges = append(edges, incidenttype.EdgeIncidents)
	}
	if m.removeddebrief_questions != nil {
		edges = append(edges, incidenttype.EdgeDebriefQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidenttype.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	case incidenttype.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.removeddebrief_questions))
		for id := range m.removeddebrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedincidents {
		edges = append(edges, incidenttype.EdgeIncidents)
	}
	if m.cleareddebrief_questions {
		edges = append(edges, incidenttype.EdgeDebriefQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case incidenttype.EdgeIncidents:
		return m.clearedincidents
	case incidenttype.EdgeDebriefQuestions:
		return m.cleareddebrief_questions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentTypeMutation) ResetEdge(name string) error {
	switch name {
	case incidenttype.EdgeIncidents:
		m.ResetIncidents()
		return nil
	case incidenttype.EdgeDebriefQuestions:
		m.ResetDebriefQuestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentType edge %s", name)
}

// MeetingScheduleMutation represents an operation that mutates the MeetingSchedule nodes in the graph.
type MeetingScheduleMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	description         *string
	begin_minute        *int
	addbegin_minute     *int
	duration_minutes    *int
	addduration_minutes *int
	start_date          *time.Time
	repeats             *meetingschedule.Repeats
	repetition_step     *int
	addrepetition_step  *int
	week_days           *[]string
	appendweek_days     []string
	monthly_on          *meetingschedule.MonthlyOn
	until_date          *time.Time
	num_repetitions     *int
	addnum_repetitions  *int
	clearedFields       map[string]struct{}
	sessions            map[uuid.UUID]struct{}
	removedsessions     map[uuid.UUID]struct{}
	clearedsessions     bool
	owning_team         map[uuid.UUID]struct{}
	removedowning_team  map[uuid.UUID]struct{}
	clearedowning_team  bool
	done                bool
	oldValue            func(context.Context) (*MeetingSchedule, error)
	predicates          []predicate.MeetingSchedule
}

var _ ent.Mutation = (*MeetingScheduleMutation)(nil)

// meetingscheduleOption allows management of the mutation configuration using functional options.
type meetingscheduleOption func(*MeetingScheduleMutation)

// newMeetingScheduleMutation creates new mutation for the MeetingSchedule entity.
func newMeetingScheduleMutation(c config, op Op, opts ...meetingscheduleOption) *MeetingScheduleMutation {
	m := &MeetingScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeMeetingSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMeetingScheduleID sets the ID field of the mutation.
func withMeetingScheduleID(id uuid.UUID) meetingscheduleOption {
	return func(m *MeetingScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *MeetingSchedule
		)
		m.oldValue = func(ctx context.Context) (*MeetingSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MeetingSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMeetingSchedule sets the old MeetingSchedule of the mutation.
func withMeetingSchedule(node *MeetingSchedule) meetingscheduleOption {
	return func(m *MeetingScheduleMutation) {
		m.oldValue = func(context.Context) (*MeetingSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MeetingScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MeetingScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MeetingSchedule entities.
func (m *MeetingScheduleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MeetingScheduleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MeetingScheduleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MeetingSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MeetingScheduleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MeetingScheduleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MeetingScheduleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *MeetingScheduleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MeetingScheduleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MeetingScheduleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[meetingschedule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MeetingScheduleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[meetingschedule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MeetingScheduleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, meetingschedule.FieldDescription)
}

// SetBeginMinute sets the "begin_minute" field.
func (m *MeetingScheduleMutation) SetBeginMinute(i int) {
	m.begin_minute = &i
	m.addbegin_minute = nil
}

// BeginMinute returns the value of the "begin_minute" field in the mutation.
func (m *MeetingScheduleMutation) BeginMinute() (r int, exists bool) {
	v := m.begin_minute
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginMinute returns the old "begin_minute" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldBeginMinute(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginMinute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginMinute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginMinute: %w", err)
	}
	return oldValue.BeginMinute, nil
}

// AddBeginMinute adds i to the "begin_minute" field.
func (m *MeetingScheduleMutation) AddBeginMinute(i int) {
	if m.addbegin_minute != nil {
		*m.addbegin_minute += i
	} else {
		m.addbegin_minute = &i
	}
}

// AddedBeginMinute returns the value that was added to the "begin_minute" field in this mutation.
func (m *MeetingScheduleMutation) AddedBeginMinute() (r int, exists bool) {
	v := m.addbegin_minute
	if v == nil {
		return
	}
	return *v, true
}

// ResetBeginMinute resets all changes to the "begin_minute" field.
func (m *MeetingScheduleMutation) ResetBeginMinute() {
	m.begin_minute = nil
	m.addbegin_minute = nil
}

// SetDurationMinutes sets the "duration_minutes" field.
func (m *MeetingScheduleMutation) SetDurationMinutes(i int) {
	m.duration_minutes = &i
	m.addduration_minutes = nil
}

// DurationMinutes returns the value of the "duration_minutes" field in the mutation.
func (m *MeetingScheduleMutation) DurationMinutes() (r int, exists bool) {
	v := m.duration_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMinutes returns the old "duration_minutes" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldDurationMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMinutes: %w", err)
	}
	return oldValue.DurationMinutes, nil
}

// AddDurationMinutes adds i to the "duration_minutes" field.
func (m *MeetingScheduleMutation) AddDurationMinutes(i int) {
	if m.addduration_minutes != nil {
		*m.addduration_minutes += i
	} else {
		m.addduration_minutes = &i
	}
}

// AddedDurationMinutes returns the value that was added to the "duration_minutes" field in this mutation.
func (m *MeetingScheduleMutation) AddedDurationMinutes() (r int, exists bool) {
	v := m.addduration_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationMinutes resets all changes to the "duration_minutes" field.
func (m *MeetingScheduleMutation) ResetDurationMinutes() {
	m.duration_minutes = nil
	m.addduration_minutes = nil
}

// SetStartDate sets the "start_date" field.
func (m *MeetingScheduleMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *MeetingScheduleMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *MeetingScheduleMutation) ResetStartDate() {
	m.start_date = nil
}

// SetRepeats sets the "repeats" field.
func (m *MeetingScheduleMutation) SetRepeats(value meetingschedule.Repeats) {
	m.repeats = &value
}

// Repeats returns the value of the "repeats" field in the mutation.
func (m *MeetingScheduleMutation) Repeats() (r meetingschedule.Repeats, exists bool) {
	v := m.repeats
	if v == nil {
		return
	}
	return *v, true
}

// OldRepeats returns the old "repeats" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldRepeats(ctx context.Context) (v meetingschedule.Repeats, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepeats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepeats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepeats: %w", err)
	}
	return oldValue.Repeats, nil
}

// ResetRepeats resets all changes to the "repeats" field.
func (m *MeetingScheduleMutation) ResetRepeats() {
	m.repeats = nil
}

// SetRepetitionStep sets the "repetition_step" field.
func (m *MeetingScheduleMutation) SetRepetitionStep(i int) {
	m.repetition_step = &i
	m.addrepetition_step = nil
}

// RepetitionStep returns the value of the "repetition_step" field in the mutation.
func (m *MeetingScheduleMutation) RepetitionStep() (r int, exists bool) {
	v := m.repetition_step
	if v == nil {
		return
	}
	return *v, true
}

// OldRepetitionStep returns the old "repetition_step" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldRepetitionStep(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepetitionStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepetitionStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepetitionStep: %w", err)
	}
	return oldValue.RepetitionStep, nil
}

// AddRepetitionStep adds i to the "repetition_step" field.
func (m *MeetingScheduleMutation) AddRepetitionStep(i int) {
	if m.addrepetition_step != nil {
		*m.addrepetition_step += i
	} else {
		m.addrepetition_step = &i
	}
}

// AddedRepetitionStep returns the value that was added to the "repetition_step" field in this mutation.
func (m *MeetingScheduleMutation) AddedRepetitionStep() (r int, exists bool) {
	v := m.addrepetition_step
	if v == nil {
		return
	}
	return *v, true
}

// ResetRepetitionStep resets all changes to the "repetition_step" field.
func (m *MeetingScheduleMutation) ResetRepetitionStep() {
	m.repetition_step = nil
	m.addrepetition_step = nil
}

// SetWeekDays sets the "week_days" field.
func (m *MeetingScheduleMutation) SetWeekDays(s []string) {
	m.week_days = &s
	m.appendweek_days = nil
}

// WeekDays returns the value of the "week_days" field in the mutation.
func (m *MeetingScheduleMutation) WeekDays() (r []string, exists bool) {
	v := m.week_days
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekDays returns the old "week_days" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldWeekDays(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekDays: %w", err)
	}
	return oldValue.WeekDays, nil
}

// AppendWeekDays adds s to the "week_days" field.
func (m *MeetingScheduleMutation) AppendWeekDays(s []string) {
	m.appendweek_days = append(m.appendweek_days, s...)
}

// AppendedWeekDays returns the list of values that were appended to the "week_days" field in this mutation.
func (m *MeetingScheduleMutation) AppendedWeekDays() ([]string, bool) {
	if len(m.appendweek_days) == 0 {
		return nil, false
	}
	return m.appendweek_days, true
}

// ClearWeekDays clears the value of the "week_days" field.
func (m *MeetingScheduleMutation) ClearWeekDays() {
	m.week_days = nil
	m.appendweek_days = nil
	m.clearedFields[meetingschedule.FieldWeekDays] = struct{}{}
}

// WeekDaysCleared returns if the "week_days" field was cleared in this mutation.
func (m *MeetingScheduleMutation) WeekDaysCleared() bool {
	_, ok := m.clearedFields[meetingschedule.FieldWeekDays]
	return ok
}

// ResetWeekDays resets all changes to the "week_days" field.
func (m *MeetingScheduleMutation) ResetWeekDays() {
	m.week_days = nil
	m.appendweek_days = nil
	delete(m.clearedFields, meetingschedule.FieldWeekDays)
}

// SetMonthlyOn sets the "monthly_on" field.
func (m *MeetingScheduleMutation) SetMonthlyOn(mo meetingschedule.MonthlyOn) {
	m.monthly_on = &mo
}

// MonthlyOn returns the value of the "monthly_on" field in the mutation.
func (m *MeetingScheduleMutation) MonthlyOn() (r meetingschedule.MonthlyOn, exists bool) {
	v := m.monthly_on
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyOn returns the old "monthly_on" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldMonthlyOn(ctx context.Context) (v meetingschedule.MonthlyOn, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyOn: %w", err)
	}
	return oldValue.MonthlyOn, nil
}

// ClearMonthlyOn clears the value of the "monthly_on" field.
func (m *MeetingScheduleMutation) ClearMonthlyOn() {
	m.monthly_on = nil
	m.clearedFields[meetingschedule.FieldMonthlyOn] = struct{}{}
}

// MonthlyOnCleared returns if the "monthly_on" field was cleared in this mutation.
func (m *MeetingScheduleMutation) MonthlyOnCleared() bool {
	_, ok := m.clearedFields[meetingschedule.FieldMonthlyOn]
	return ok
}

// ResetMonthlyOn resets all changes to the "monthly_on" field.
func (m *MeetingScheduleMutation) ResetMonthlyOn() {
	m.monthly_on = nil
	delete(m.clearedFields, meetingschedule.FieldMonthlyOn)
}

// SetUntilDate sets the "until_date" field.
func (m *MeetingScheduleMutation) SetUntilDate(t time.Time) {
	m.until_date = &t
}

// UntilDate returns the value of the "until_date" field in the mutation.
func (m *MeetingScheduleMutation) UntilDate() (r time.Time, exists bool) {
	v := m.until_date
	if v == nil {
		return
	}
	return *v, true
}

// OldUntilDate returns the old "until_date" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldUntilDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUntilDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUntilDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUntilDate: %w", err)
	}
	return oldValue.UntilDate, nil
}

// ClearUntilDate clears the value of the "until_date" field.
func (m *MeetingScheduleMutation) ClearUntilDate() {
	m.until_date = nil
	m.clearedFields[meetingschedule.FieldUntilDate] = struct{}{}
}

// UntilDateCleared returns if the "until_date" field was cleared in this mutation.
func (m *MeetingScheduleMutation) UntilDateCleared() bool {
	_, ok := m.clearedFields[meetingschedule.FieldUntilDate]
	return ok
}

// ResetUntilDate resets all changes to the "until_date" field.
func (m *MeetingScheduleMutation) ResetUntilDate() {
	m.until_date = nil
	delete(m.clearedFields, meetingschedule.FieldUntilDate)
}

// SetNumRepetitions sets the "num_repetitions" field.
func (m *MeetingScheduleMutation) SetNumRepetitions(i int) {
	m.num_repetitions = &i
	m.addnum_repetitions = nil
}

// NumRepetitions returns the value of the "num_repetitions" field in the mutation.
func (m *MeetingScheduleMutation) NumRepetitions() (r int, exists bool) {
	v := m.num_repetitions
	if v == nil {
		return
	}
	return *v, true
}

// OldNumRepetitions returns the old "num_repetitions" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldNumRepetitions(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumRepetitions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumRepetitions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumRepetitions: %w", err)
	}
	return oldValue.NumRepetitions, nil
}

// AddNumRepetitions adds i to the "num_repetitions" field.
func (m *MeetingScheduleMutation) AddNumRepetitions(i int) {
	if m.addnum_repetitions != nil {
		*m.addnum_repetitions += i
	} else {
		m.addnum_repetitions = &i
	}
}

// AddedNumRepetitions returns the value that was added to the "num_repetitions" field in this mutation.
func (m *MeetingScheduleMutation) AddedNumRepetitions() (r int, exists bool) {
	v := m.addnum_repetitions
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumRepetitions clears the value of the "num_repetitions" field.
func (m *MeetingScheduleMutation) ClearNumRepetitions() {
	m.num_repetitions = nil
	m.addnum_repetitions = nil
	m.clearedFields[meetingschedule.FieldNumRepetitions] = struct{}{}
}

// NumRepetitionsCleared returns if the "num_repetitions" field was cleared in this mutation.
func (m *MeetingScheduleMutation) NumRepetitionsCleared() bool {
	_, ok := m.clearedFields[meetingschedule.FieldNumRepetitions]
	return ok
}

// ResetNumRepetitions resets all changes to the "num_repetitions" field.
func (m *MeetingScheduleMutation) ResetNumRepetitions() {
	m.num_repetitions = nil
	m.addnum_repetitions = nil
	delete(m.clearedFields, meetingschedule.FieldNumRepetitions)
}

// AddSessionIDs adds the "sessions" edge to the MeetingSession entity by ids.
func (m *MeetingScheduleMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m.sessions == nil {
		m.sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the MeetingSession entity.
func (m *MeetingScheduleMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the MeetingSession entity was cleared.
func (m *MeetingScheduleMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the MeetingSession entity by IDs.
func (m *MeetingScheduleMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the MeetingSession entity.
func (m *MeetingScheduleMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *MeetingScheduleMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *MeetingScheduleMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddOwningTeamIDs adds the "owning_team" edge to the Team entity by ids.
func (m *MeetingScheduleMutation) AddOwningTeamIDs(ids ...uuid.UUID) {
	if m.owning_team == nil {
		m.owning_team = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.owning_team[ids[i]] = struct{}{}
	}
}

// ClearOwningTeam clears the "owning_team" edge to the Team entity.
func (m *MeetingScheduleMutation) ClearOwningTeam() {
	m.clearedowning_team = true
}

// OwningTeamCleared reports if the "owning_team" edge to the Team entity was cleared.
func (m *MeetingScheduleMutation) OwningTeamCleared() bool {
	return m.clearedowning_team
}

// RemoveOwningTeamIDs removes the "owning_team" edge to the Team entity by IDs.
func (m *MeetingScheduleMutation) RemoveOwningTeamIDs(ids ...uuid.UUID) {
	if m.removedowning_team == nil {
		m.removedowning_team = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.owning_team, ids[i])
		m.removedowning_team[ids[i]] = struct{}{}
	}
}

// RemovedOwningTeam returns the removed IDs of the "owning_team" edge to the Team entity.
func (m *MeetingScheduleMutation) RemovedOwningTeamIDs() (ids []uuid.UUID) {
	for id := range m.removedowning_team {
		ids = append(ids, id)
	}
	return
}

// OwningTeamIDs returns the "owning_team" edge IDs in the mutation.
func (m *MeetingScheduleMutation) OwningTeamIDs() (ids []uuid.UUID) {
	for id := range m.owning_team {
		ids = append(ids, id)
	}
	return
}

// ResetOwningTeam resets all changes to the "owning_team" edge.
func (m *MeetingScheduleMutation) ResetOwningTeam() {
	m.owning_team = nil
	m.clearedowning_team = false
	m.removedowning_team = nil
}

// Where appends a list predicates to the MeetingScheduleMutation builder.
func (m *MeetingScheduleMutation) Where(ps ...predicate.MeetingSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MeetingScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MeetingScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MeetingSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MeetingScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MeetingScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MeetingSchedule).
func (m *MeetingScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MeetingScheduleMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, meetingschedule.FieldName)
	}
	if m.description != nil {
		fields = append(fields, meetingschedule.FieldDescription)
	}
	if m.begin_minute != nil {
		fields = append(fields, meetingschedule.FieldBeginMinute)
	}
	if m.duration_minutes != nil {
		fields = append(fields, meetingschedule.FieldDurationMinutes)
	}
	if m.start_date != nil {
		fields = append(fields, meetingschedule.FieldStartDate)
	}
	if m.repeats != nil {
		fields = append(fields, meetingschedule.FieldRepeats)
	}
	if m.repetition_step != nil {
		fields = append(fields, meetingschedule.FieldRepetitionStep)
	}
	if m.week_days != nil {
		fields = append(fields, meetingschedule.FieldWeekDays)
	}
	if m.monthly_on != nil {
		fields = append(fields, meetingschedule.FieldMonthlyOn)
	}
	if m.until_date != nil {
		fields = append(fields, meetingschedule.FieldUntilDate)
	}
	if m.num_repetitions != nil {
		fields = append(fields, meetingschedule.FieldNumRepetitions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MeetingScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case meetingschedule.FieldName:
		return m.Name()
	case meetingschedule.FieldDescription:
		return m.Description()
	case meetingschedule.FieldBeginMinute:
		return m.BeginMinute()
	case meetingschedule.FieldDurationMinutes:
		return m.DurationMinutes()
	case meetingschedule.FieldStartDate:
		return m.StartDate()
	case meetingschedule.FieldRepeats:
		return m.Repeats()
	case meetingschedule.FieldRepetitionStep:
		return m.RepetitionStep()
	case meetingschedule.FieldWeekDays:
		return m.WeekDays()
	case meetingschedule.FieldMonthlyOn:
		return m.MonthlyOn()
	case meetingschedule.FieldUntilDate:
		return m.UntilDate()
	case meetingschedule.FieldNumRepetitions:
		return m.NumRepetitions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MeetingScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case meetingschedule.FieldName:
		return m.OldName(ctx)
	case meetingschedule.FieldDescription:
		return m.OldDescription(ctx)
	case meetingschedule.FieldBeginMinute:
		return m.OldBeginMinute(ctx)
	case meetingschedule.FieldDurationMinutes:
		return m.OldDurationMinutes(ctx)
	case meetingschedule.FieldStartDate:
		return m.OldStartDate(ctx)
	case meetingschedule.FieldRepeats:
		return m.OldRepeats(ctx)
	case meetingschedule.FieldRepetitionStep:
		return m.OldRepetitionStep(ctx)
	case meetingschedule.FieldWeekDays:
		return m.OldWeekDays(ctx)
	case meetingschedule.FieldMonthlyOn:
		return m.OldMonthlyOn(ctx)
	case meetingschedule.FieldUntilDate:
		return m.OldUntilDate(ctx)
	case meetingschedule.FieldNumRepetitions:
		return m.OldNumRepetitions(ctx)
	}
	return nil, fmt.Errorf("unknown MeetingSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeetingScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case meetingschedule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case meetingschedule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case meetingschedule.FieldBeginMinute:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginMinute(v)
		return nil
	case meetingschedule.FieldDurationMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMinutes(v)
		return nil
	case meetingschedule.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case meetingschedule.FieldRepeats:
		v, ok := value.(meetingschedule.Repeats)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepeats(v)
		return nil
	case meetingschedule.FieldRepetitionStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepetitionStep(v)
		return nil
	case meetingschedule.FieldWeekDays:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekDays(v)
		return nil
	case meetingschedule.FieldMonthlyOn:
		v, ok := value.(meetingschedule.MonthlyOn)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyOn(v)
		return nil
	case meetingschedule.FieldUntilDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUntilDate(v)
		return nil
	case meetingschedule.FieldNumRepetitions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumRepetitions(v)
		return nil
	}
	return fmt.Errorf("unknown MeetingSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MeetingScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addbegin_minute != nil {
		fields = append(fields, meetingschedule.FieldBeginMinute)
	}
	if m.addduration_minutes != nil {
		fields = append(fields, meetingschedule.FieldDurationMinutes)
	}
	if m.addrepetition_step != nil {
		fields = append(fields, meetingschedule.FieldRepetitionStep)
	}
	if m.addnum_repetitions != nil {
		fields = append(fields, meetingschedule.FieldNumRepetitions)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MeetingScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case meetingschedule.FieldBeginMinute:
		return m.AddedBeginMinute()
	case meetingschedule.FieldDurationMinutes:
		return m.AddedDurationMinutes()
	case meetingschedule.FieldRepetitionStep:
		return m.AddedRepetitionStep()
	case meetingschedule.FieldNumRepetitions:
		return m.AddedNumRepetitions()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeetingScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case meetingschedule.FieldBeginMinute:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBeginMinute(v)
		return nil
	case meetingschedule.FieldDurationMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMinutes(v)
		return nil
	case meetingschedule.FieldRepetitionStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepetitionStep(v)
		return nil
	case meetingschedule.FieldNumRepetitions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumRepetitions(v)
		return nil
	}
	return fmt.Errorf("unknown MeetingSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MeetingScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(meetingschedule.FieldDescription) {
		fields = append(fields, meetingschedule.FieldDescription)
	}
	if m.FieldCleared(meetingschedule.FieldWeekDays) {
		fields = append(fields, meetingschedule.FieldWeekDays)
	}
	if m.FieldCleared(meetingschedule.FieldMonthlyOn) {
		fields = append(fields, meetingschedule.FieldMonthlyOn)
	}
	if m.FieldCleared(meetingschedule.FieldUntilDate) {
		fields = append(fields, meetingschedule.FieldUntilDate)
	}
	if m.FieldCleared(meetingschedule.FieldNumRepetitions) {
		fields = append(fields, meetingschedule.FieldNumRepetitions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MeetingScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MeetingScheduleMutation) ClearField(name string) error {
	switch name {
	case meetingschedule.FieldDescription:
		m.ClearDescription()
		return nil
	case meetingschedule.FieldWeekDays:
		m.ClearWeekDays()
		return nil
	case meetingschedule.FieldMonthlyOn:
		m.ClearMonthlyOn()
		return nil
	case meetingschedule.FieldUntilDate:
		m.ClearUntilDate()
		return nil
	case meetingschedule.FieldNumRepetitions:
		m.ClearNumRepetitions()
		return nil
	}
	return fmt.Errorf("unknown MeetingSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MeetingScheduleMutation) ResetField(name string) error {
	switch name {
	case meetingschedule.FieldName:
		m.ResetName()
		return nil
	case meetingschedule.FieldDescription:
		m.ResetDescription()
		return nil
	case meetingschedule.FieldBeginMinute:
		m.ResetBeginMinute()
		return nil
	case meetingschedule.FieldDurationMinutes:
		m.ResetDurationMinutes()
		return nil
	case meetingschedule.FieldStartDate:
		m.ResetStartDate()
		return nil
	case meetingschedule.FieldRepeats:
		m.ResetRepeats()
		return nil
	case meetingschedule.FieldRepetitionStep:
		m.ResetRepetitionStep()
		return nil
	case meetingschedule.FieldWeekDays:
		m.ResetWeekDays()
		return nil
	case meetingschedule.FieldMonthlyOn:
		m.ResetMonthlyOn()
		return nil
	case meetingschedule.FieldUntilDate:
		m.ResetUntilDate()
		return nil
	case meetingschedule.FieldNumRepetitions:
		m.ResetNumRepetitions()
		return nil
	}
	return fmt.Errorf("unknown MeetingSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MeetingScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sessions != nil {
		edges = append(edges, meetingschedule.EdgeSessions)
	}
	if m.owning_team != nil {
		edges = append(edges, meetingschedule.EdgeOwningTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MeetingScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case meetingschedule.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case meetingschedule.EdgeOwningTeam:
		ids := make([]ent.Value, 0, len(m.owning_team))
		for id := range m.owning_team {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MeetingScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsessions != nil {
		edges = append(edges, meetingschedule.EdgeSessions)
	}
	if m.removedowning_team != nil {
		edges = append(edges, meetingschedule.EdgeOwningTeam)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MeetingScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case meetingschedule.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case meetingschedule.EdgeOwningTeam:
		ids := make([]ent.Value, 0, len(m.removedowning_team))
		for id := range m.removedowning_team {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MeetingScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsessions {
		edges = append(edges, meetingschedule.EdgeSessions)
	}
	if m.clearedowning_team {
		edges = append(edges, meetingschedule.EdgeOwningTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MeetingScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case meetingschedule.EdgeSessions:
		return m.clearedsessions
	case meetingschedule.EdgeOwningTeam:
		return m.clearedowning_team
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MeetingScheduleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MeetingSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MeetingScheduleMutation) ResetEdge(name string) error {
	switch name {
	case meetingschedule.EdgeSessions:
		m.ResetSessions()
		return nil
	case meetingschedule.EdgeOwningTeam:
		m.ResetOwningTeam()
		return nil
	}
	return fmt.Errorf("unknown MeetingSchedule edge %s", name)
}

// MeetingSessionMutation represents an operation that mutates the MeetingSession nodes in the graph.
type MeetingSessionMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	title            *string
	started_at       *time.Time
	ended_at         *time.Time
	document_name    *string
	clearedFields    map[string]struct{}
	incidents        map[uuid.UUID]struct{}
	removedincidents map[uuid.UUID]struct{}
	clearedincidents bool
	done             bool
	oldValue         func(context.Context) (*MeetingSession, error)
	predicates       []predicate.MeetingSession
}

var _ ent.Mutation = (*MeetingSessionMutation)(nil)

// meetingsessionOption allows management of the mutation configuration using functional options.
type meetingsessionOption func(*MeetingSessionMutation)

// newMeetingSessionMutation creates new mutation for the MeetingSession entity.
func newMeetingSessionMutation(c config, op Op, opts ...meetingsessionOption) *MeetingSessionMutation {
	m := &MeetingSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeMeetingSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMeetingSessionID sets the ID field of the mutation.
func withMeetingSessionID(id uuid.UUID) meetingsessionOption {
	return func(m *MeetingSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *MeetingSession
		)
		m.oldValue = func(ctx context.Context) (*MeetingSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MeetingSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMeetingSession sets the old MeetingSession of the mutation.
func withMeetingSession(node *MeetingSession) meetingsessionOption {
	return func(m *MeetingSessionMutation) {
		m.oldValue = func(context.Context) (*MeetingSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MeetingSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MeetingSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MeetingSession entities.
func (m *MeetingSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MeetingSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MeetingSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MeetingSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *MeetingSessionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MeetingSessionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the MeetingSession entity.
// If the MeetingSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingSessionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *MeetingSessionMutation) ResetTitle() {
	m.title = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MeetingSessionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MeetingSessionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MeetingSession entity.
// If the MeetingSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingSessionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MeetingSessionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *MeetingSessionMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *MeetingSessionMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the MeetingSession entity.
// If the MeetingSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingSessionMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *MeetingSessionMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[meetingsession.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *MeetingSessionMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[meetingsession.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *MeetingSessionMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, meetingsession.FieldEndedAt)
}

// SetDocumentName sets the "document_name" field.
func (m *MeetingSessionMutation) SetDocumentName(s string) {
	m.document_name = &s
}

// DocumentName returns the value of the "document_name" field in the mutation.
func (m *MeetingSessionMutation) DocumentName() (r string, exists bool) {
	v := m.document_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentName returns the old "document_name" field's value of the MeetingSession entity.
// If the MeetingSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingSessionMutation) OldDocumentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentName: %w", err)
	}
	return oldValue.DocumentName, nil
}

// ResetDocumentName resets all changes to the "document_name" field.
func (m *MeetingSessionMutation) ResetDocumentName() {
	m.document_name = nil
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *MeetingSessionMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *MeetingSessionMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *MeetingSessionMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *MeetingSessionMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *MeetingSessionMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *MeetingSessionMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *MeetingSessionMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// Where appends a list predicates to the MeetingSessionMutation builder.
func (m *MeetingSessionMutation) Where(ps ...predicate.MeetingSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MeetingSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MeetingSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MeetingSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MeetingSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MeetingSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MeetingSession).
func (m *MeetingSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MeetingSessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.title != nil {
		fields = append(fields, meetingsession.FieldTitle)
	}
	if m.started_at != nil {
		fields = append(fields, meetingsession.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, meetingsession.FieldEndedAt)
	}
	if m.document_name != nil {
		fields = append(fields, meetingsession.FieldDocumentName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MeetingSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case meetingsession.FieldTitle:
		return m.Title()
	case meetingsession.FieldStartedAt:
		return m.StartedAt()
	case meetingsession.FieldEndedAt:
		return m.EndedAt()
	case meetingsession.FieldDocumentName:
		return m.DocumentName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MeetingSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case meetingsession.FieldTitle:
		return m.OldTitle(ctx)
	case meetingsession.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case meetingsession.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case meetingsession.FieldDocumentName:
		return m.OldDocumentName(ctx)
	}
	return nil, fmt.Errorf("unknown MeetingSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeetingSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case meetingsession.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case meetingsession.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case meetingsession.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case meetingsession.FieldDocumentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentName(v)
		return nil
	}
	return fmt.Errorf("unknown MeetingSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MeetingSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MeetingSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeetingSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MeetingSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MeetingSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(meetingsession.FieldEndedAt) {
		fields = append(fields, meetingsession.FieldEndedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MeetingSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MeetingSessionMutation) ClearField(name string) error {
	switch name {
	case meetingsession.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	}
	return fmt.Errorf("unknown MeetingSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MeetingSessionMutation) ResetField(name string) error {
	switch name {
	case meetingsession.FieldTitle:
		m.ResetTitle()
		return nil
	case meetingsession.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case meetingsession.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case meetingsession.FieldDocumentName:
		m.ResetDocumentName()
		return nil
	}
	return fmt.Errorf("unknown MeetingSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MeetingSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.incidents != nil {
		edges = append(edges, meetingsession.EdgeIncidents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MeetingSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case meetingsession.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MeetingSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedincidents != nil {
		edges = append(edges, meetingsession.EdgeIncidents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MeetingSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case meetingsession.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MeetingSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedincidents {
		edges = append(edges, meetingsession.EdgeIncidents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MeetingSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case meetingsession.EdgeIncidents:
		return m.clearedincidents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MeetingSessionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MeetingSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MeetingSessionMutation) ResetEdge(name string) error {
	switch name {
	case meetingsession.EdgeIncidents:
		m.ResetIncidents()
		return nil
	}
	return fmt.Errorf("unknown MeetingSession edge %s", name)
}

// OncallAlertMutation represents an operation that mutates the OncallAlert nodes in the graph.
type OncallAlertMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	timestamp        *time.Time
	clearedFields    map[string]struct{}
	instances        map[uuid.UUID]struct{}
	removedinstances map[uuid.UUID]struct{}
	clearedinstances bool
	roster           *uuid.UUID
	clearedroster    bool
	done             bool
	oldValue         func(context.Context) (*OncallAlert, error)
	predicates       []predicate.OncallAlert
}

var _ ent.Mutation = (*OncallAlertMutation)(nil)

// oncallalertOption allows management of the mutation configuration using functional options.
type oncallalertOption func(*OncallAlertMutation)

// newOncallAlertMutation creates new mutation for the OncallAlert entity.
func newOncallAlertMutation(c config, op Op, opts ...oncallalertOption) *OncallAlertMutation {
	m := &OncallAlertMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallAlertID sets the ID field of the mutation.
func withOncallAlertID(id uuid.UUID) oncallalertOption {
	return func(m *OncallAlertMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallAlert
		)
		m.oldValue = func(ctx context.Context) (*OncallAlert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallAlert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallAlert sets the old OncallAlert of the mutation.
func withOncallAlert(node *OncallAlert) oncallalertOption {
	return func(m *OncallAlertMutation) {
		m.oldValue = func(context.Context) (*OncallAlert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallAlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallAlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallAlert entities.
func (m *OncallAlertMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallAlertMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallAlertMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallAlert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRosterID sets the "roster_id" field.
func (m *OncallAlertMutation) SetRosterID(u uuid.UUID) {
	m.roster = &u
}

// RosterID returns the value of the "roster_id" field in the mutation.
func (m *OncallAlertMutation) RosterID() (r uuid.UUID, exists bool) {
	v := m.roster
	if v == nil {
		return
	}
	return *v, true
}

// OldRosterID returns the old "roster_id" field's value of the OncallAlert entity.
// If the OncallAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallAlertMutation) OldRosterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosterID: %w", err)
	}
	return oldValue.RosterID, nil
}

// ResetRosterID resets all changes to the "roster_id" field.
func (m *OncallAlertMutation) ResetRosterID() {
	m.roster = nil
}

// SetName sets the "name" field.
func (m *OncallAlertMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OncallAlertMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OncallAlert entity.
// If the OncallAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallAlertMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OncallAlertMutation) ResetName() {
	m.name = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *OncallAlertMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *OncallAlertMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the OncallAlert entity.
// If the OncallAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallAlertMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *OncallAlertMutation) ResetTimestamp() {
	m.timestamp = nil
}

// AddInstanceIDs adds the "instances" edge to the OncallAlertInstance entity by ids.
func (m *OncallAlertMutation) AddInstanceIDs(ids ...uuid.UUID) {
	if m.instances == nil {
		m.instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the OncallAlertInstance entity.
func (m *OncallAlertMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the OncallAlertInstance entity was cleared.
func (m *OncallAlertMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the OncallAlertInstance entity by IDs.
func (m *OncallAlertMutation) RemoveInstanceIDs(ids ...uuid.UUID) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the OncallAlertInstance entity.
func (m *OncallAlertMutation) RemovedInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *OncallAlertMutation) InstancesIDs() (ids []uuid.UUID) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *OncallAlertMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// ClearRoster clears the "roster" edge to the OncallRoster entity.
func (m *OncallAlertMutation) ClearRoster() {
	m.clearedroster = true
	m.clearedFields[oncallalert.FieldRosterID] = struct{}{}
}

// RosterCleared reports if the "roster" edge to the OncallRoster entity was cleared.
func (m *OncallAlertMutation) RosterCleared() bool {
	return m.clearedroster
}

// RosterIDs returns the "roster" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RosterID instead. It exists only for internal usage by the builders.
func (m *OncallAlertMutation) RosterIDs() (ids []uuid.UUID) {
	if id := m.roster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoster resets all changes to the "roster" edge.
func (m *OncallAlertMutation) ResetRoster() {
	m.roster = nil
	m.clearedroster = false
}

// Where appends a list predicates to the OncallAlertMutation builder.
func (m *OncallAlertMutation) Where(ps ...predicate.OncallAlert) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallAlertMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallAlertMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallAlert, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallAlertMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallAlertMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallAlert).
func (m *OncallAlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallAlertMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.roster != nil {
		fields = append(fields, oncallalert.FieldRosterID)
	}
	if m.name != nil {
		fields = append(fields, oncallalert.FieldName)
	}
	if m.timestamp != nil {
		fields = append(fields, oncallalert.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallAlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallalert.FieldRosterID:
		return m.RosterID()
	case oncallalert.FieldName:
		return m.Name()
	case oncallalert.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallAlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallalert.FieldRosterID:
		return m.OldRosterID(ctx)
	case oncallalert.FieldName:
		return m.OldName(ctx)
	case oncallalert.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown OncallAlert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallAlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallalert.FieldRosterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosterID(v)
		return nil
	case oncallalert.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oncallalert.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown OncallAlert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallAlertMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallAlertMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallAlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallAlert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallAlertMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallAlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallAlertMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OncallAlert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallAlertMutation) ResetField(name string) error {
	switch name {
	case oncallalert.FieldRosterID:
		m.ResetRosterID()
		return nil
	case oncallalert.FieldName:
		m.ResetName()
		return nil
	case oncallalert.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown OncallAlert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallAlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.instances != nil {
		edges = append(edges, oncallalert.EdgeInstances)
	}
	if m.roster != nil {
		edges = append(edges, oncallalert.EdgeRoster)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallAlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallalert.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	case oncallalert.EdgeRoster:
		if id := m.roster; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallAlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinstances != nil {
		edges = append(edges, oncallalert.EdgeInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallAlertMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oncallalert.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallAlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinstances {
		edges = append(edges, oncallalert.EdgeInstances)
	}
	if m.clearedroster {
		edges = append(edges, oncallalert.EdgeRoster)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallAlertMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallalert.EdgeInstances:
		return m.clearedinstances
	case oncallalert.EdgeRoster:
		return m.clearedroster
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallAlertMutation) ClearEdge(name string) error {
	switch name {
	case oncallalert.EdgeRoster:
		m.ClearRoster()
		return nil
	}
	return fmt.Errorf("unknown OncallAlert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallAlertMutation) ResetEdge(name string) error {
	switch name {
	case oncallalert.EdgeInstances:
		m.ResetInstances()
		return nil
	case oncallalert.EdgeRoster:
		m.ResetRoster()
		return nil
	}
	return fmt.Errorf("unknown OncallAlert edge %s", name)
}

// OncallAlertInstanceMutation represents an operation that mutates the OncallAlertInstance nodes in the graph.
type OncallAlertInstanceMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	acked_at        *time.Time
	clearedFields   map[string]struct{}
	alert           *uuid.UUID
	clearedalert    bool
	receiver        *uuid.UUID
	clearedreceiver bool
	done            bool
	oldValue        func(context.Context) (*OncallAlertInstance, error)
	predicates      []predicate.OncallAlertInstance
}

var _ ent.Mutation = (*OncallAlertInstanceMutation)(nil)

// oncallalertinstanceOption allows management of the mutation configuration using functional options.
type oncallalertinstanceOption func(*OncallAlertInstanceMutation)

// newOncallAlertInstanceMutation creates new mutation for the OncallAlertInstance entity.
func newOncallAlertInstanceMutation(c config, op Op, opts ...oncallalertinstanceOption) *OncallAlertInstanceMutation {
	m := &OncallAlertInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallAlertInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallAlertInstanceID sets the ID field of the mutation.
func withOncallAlertInstanceID(id uuid.UUID) oncallalertinstanceOption {
	return func(m *OncallAlertInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallAlertInstance
		)
		m.oldValue = func(ctx context.Context) (*OncallAlertInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallAlertInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallAlertInstance sets the old OncallAlertInstance of the mutation.
func withOncallAlertInstance(node *OncallAlertInstance) oncallalertinstanceOption {
	return func(m *OncallAlertInstanceMutation) {
		m.oldValue = func(context.Context) (*OncallAlertInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallAlertInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallAlertInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallAlertInstance entities.
func (m *OncallAlertInstanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallAlertInstanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallAlertInstanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallAlertInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlertID sets the "alert_id" field.
func (m *OncallAlertInstanceMutation) SetAlertID(u uuid.UUID) {
	m.alert = &u
}

// AlertID returns the value of the "alert_id" field in the mutation.
func (m *OncallAlertInstanceMutation) AlertID() (r uuid.UUID, exists bool) {
	v := m.alert
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertID returns the old "alert_id" field's value of the OncallAlertInstance entity.
// If the OncallAlertInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallAlertInstanceMutation) OldAlertID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertID: %w", err)
	}
	return oldValue.AlertID, nil
}

// ResetAlertID resets all changes to the "alert_id" field.
func (m *OncallAlertInstanceMutation) ResetAlertID() {
	m.alert = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OncallAlertInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OncallAlertInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OncallAlertInstance entity.
// If the OncallAlertInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallAlertInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OncallAlertInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAckedAt sets the "acked_at" field.
func (m *OncallAlertInstanceMutation) SetAckedAt(t time.Time) {
	m.acked_at = &t
}

// AckedAt returns the value of the "acked_at" field in the mutation.
func (m *OncallAlertInstanceMutation) AckedAt() (r time.Time, exists bool) {
	v := m.acked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAckedAt returns the old "acked_at" field's value of the OncallAlertInstance entity.
// If the OncallAlertInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallAlertInstanceMutation) OldAckedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAckedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAckedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAckedAt: %w", err)
	}
	return oldValue.AckedAt, nil
}

// ResetAckedAt resets all changes to the "acked_at" field.
func (m *OncallAlertInstanceMutation) ResetAckedAt() {
	m.acked_at = nil
}

// SetReceiverUserID sets the "receiver_user_id" field.
func (m *OncallAlertInstanceMutation) SetReceiverUserID(u uuid.UUID) {
	m.receiver = &u
}

// ReceiverUserID returns the value of the "receiver_user_id" field in the mutation.
func (m *OncallAlertInstanceMutation) ReceiverUserID() (r uuid.UUID, exists bool) {
	v := m.receiver
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverUserID returns the old "receiver_user_id" field's value of the OncallAlertInstance entity.
// If the OncallAlertInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallAlertInstanceMutation) OldReceiverUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverUserID: %w", err)
	}
	return oldValue.ReceiverUserID, nil
}

// ResetReceiverUserID resets all changes to the "receiver_user_id" field.
func (m *OncallAlertInstanceMutation) ResetReceiverUserID() {
	m.receiver = nil
}

// ClearAlert clears the "alert" edge to the OncallAlert entity.
func (m *OncallAlertInstanceMutation) ClearAlert() {
	m.clearedalert = true
	m.clearedFields[oncallalertinstance.FieldAlertID] = struct{}{}
}

// AlertCleared reports if the "alert" edge to the OncallAlert entity was cleared.
func (m *OncallAlertInstanceMutation) AlertCleared() bool {
	return m.clearedalert
}

// AlertIDs returns the "alert" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlertID instead. It exists only for internal usage by the builders.
func (m *OncallAlertInstanceMutation) AlertIDs() (ids []uuid.UUID) {
	if id := m.alert; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlert resets all changes to the "alert" edge.
func (m *OncallAlertInstanceMutation) ResetAlert() {
	m.alert = nil
	m.clearedalert = false
}

// SetReceiverID sets the "receiver" edge to the User entity by id.
func (m *OncallAlertInstanceMutation) SetReceiverID(id uuid.UUID) {
	m.receiver = &id
}

// ClearReceiver clears the "receiver" edge to the User entity.
func (m *OncallAlertInstanceMutation) ClearReceiver() {
	m.clearedreceiver = true
	m.clearedFields[oncallalertinstance.FieldReceiverUserID] = struct{}{}
}

// ReceiverCleared reports if the "receiver" edge to the User entity was cleared.
func (m *OncallAlertInstanceMutation) ReceiverCleared() bool {
	return m.clearedreceiver
}

// ReceiverID returns the "receiver" edge ID in the mutation.
func (m *OncallAlertInstanceMutation) ReceiverID() (id uuid.UUID, exists bool) {
	if m.receiver != nil {
		return *m.receiver, true
	}
	return
}

// ReceiverIDs returns the "receiver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReceiverID instead. It exists only for internal usage by the builders.
func (m *OncallAlertInstanceMutation) ReceiverIDs() (ids []uuid.UUID) {
	if id := m.receiver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReceiver resets all changes to the "receiver" edge.
func (m *OncallAlertInstanceMutation) ResetReceiver() {
	m.receiver = nil
	m.clearedreceiver = false
}

// Where appends a list predicates to the OncallAlertInstanceMutation builder.
func (m *OncallAlertInstanceMutation) Where(ps ...predicate.OncallAlertInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallAlertInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallAlertInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallAlertInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallAlertInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallAlertInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallAlertInstance).
func (m *OncallAlertInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallAlertInstanceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.alert != nil {
		fields = append(fields, oncallalertinstance.FieldAlertID)
	}
	if m.created_at != nil {
		fields = append(fields, oncallalertinstance.FieldCreatedAt)
	}
	if m.acked_at != nil {
		fields = append(fields, oncallalertinstance.FieldAckedAt)
	}
	if m.receiver != nil {
		fields = append(fields, oncallalertinstance.FieldReceiverUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallAlertInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallalertinstance.FieldAlertID:
		return m.AlertID()
	case oncallalertinstance.FieldCreatedAt:
		return m.CreatedAt()
	case oncallalertinstance.FieldAckedAt:
		return m.AckedAt()
	case oncallalertinstance.FieldReceiverUserID:
		return m.ReceiverUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallAlertInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallalertinstance.FieldAlertID:
		return m.OldAlertID(ctx)
	case oncallalertinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oncallalertinstance.FieldAckedAt:
		return m.OldAckedAt(ctx)
	case oncallalertinstance.FieldReceiverUserID:
		return m.OldReceiverUserID(ctx)
	}
	return nil, fmt.Errorf("unknown OncallAlertInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallAlertInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallalertinstance.FieldAlertID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertID(v)
		return nil
	case oncallalertinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oncallalertinstance.FieldAckedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAckedAt(v)
		return nil
	case oncallalertinstance.FieldReceiverUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverUserID(v)
		return nil
	}
	return fmt.Errorf("unknown OncallAlertInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallAlertInstanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallAlertInstanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallAlertInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallAlertInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallAlertInstanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallAlertInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallAlertInstanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OncallAlertInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallAlertInstanceMutation) ResetField(name string) error {
	switch name {
	case oncallalertinstance.FieldAlertID:
		m.ResetAlertID()
		return nil
	case oncallalertinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oncallalertinstance.FieldAckedAt:
		m.ResetAckedAt()
		return nil
	case oncallalertinstance.FieldReceiverUserID:
		m.ResetReceiverUserID()
		return nil
	}
	return fmt.Errorf("unknown OncallAlertInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallAlertInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.alert != nil {
		edges = append(edges, oncallalertinstance.EdgeAlert)
	}
	if m.receiver != nil {
		edges = append(edges, oncallalertinstance.EdgeReceiver)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallAlertInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallalertinstance.EdgeAlert:
		if id := m.alert; id != nil {
			return []ent.Value{*id}
		}
	case oncallalertinstance.EdgeReceiver:
		if id := m.receiver; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallAlertInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallAlertInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallAlertInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedalert {
		edges = append(edges, oncallalertinstance.EdgeAlert)
	}
	if m.clearedreceiver {
		edges = append(edges, oncallalertinstance.EdgeReceiver)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallAlertInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallalertinstance.EdgeAlert:
		return m.clearedalert
	case oncallalertinstance.EdgeReceiver:
		return m.clearedreceiver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallAlertInstanceMutation) ClearEdge(name string) error {
	switch name {
	case oncallalertinstance.EdgeAlert:
		m.ClearAlert()
		return nil
	case oncallalertinstance.EdgeReceiver:
		m.ClearReceiver()
		return nil
	}
	return fmt.Errorf("unknown OncallAlertInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallAlertInstanceMutation) ResetEdge(name string) error {
	switch name {
	case oncallalertinstance.EdgeAlert:
		m.ResetAlert()
		return nil
	case oncallalertinstance.EdgeReceiver:
		m.ResetReceiver()
		return nil
	}
	return fmt.Errorf("unknown OncallAlertInstance edge %s", name)
}

// OncallHandoverTemplateMutation represents an operation that mutates the OncallHandoverTemplate nodes in the graph.
type OncallHandoverTemplateMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	contents      *[]byte
	is_default    *bool
	clearedFields map[string]struct{}
	roster        map[uuid.UUID]struct{}
	removedroster map[uuid.UUID]struct{}
	clearedroster bool
	done          bool
	oldValue      func(context.Context) (*OncallHandoverTemplate, error)
	predicates    []predicate.OncallHandoverTemplate
}

var _ ent.Mutation = (*OncallHandoverTemplateMutation)(nil)

// oncallhandovertemplateOption allows management of the mutation configuration using functional options.
type oncallhandovertemplateOption func(*OncallHandoverTemplateMutation)

// newOncallHandoverTemplateMutation creates new mutation for the OncallHandoverTemplate entity.
func newOncallHandoverTemplateMutation(c config, op Op, opts ...oncallhandovertemplateOption) *OncallHandoverTemplateMutation {
	m := &OncallHandoverTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallHandoverTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallHandoverTemplateID sets the ID field of the mutation.
func withOncallHandoverTemplateID(id uuid.UUID) oncallhandovertemplateOption {
	return func(m *OncallHandoverTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallHandoverTemplate
		)
		m.oldValue = func(ctx context.Context) (*OncallHandoverTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallHandoverTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallHandoverTemplate sets the old OncallHandoverTemplate of the mutation.
func withOncallHandoverTemplate(node *OncallHandoverTemplate) oncallhandovertemplateOption {
	return func(m *OncallHandoverTemplateMutation) {
		m.oldValue = func(context.Context) (*OncallHandoverTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallHandoverTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallHandoverTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallHandoverTemplate entities.
func (m *OncallHandoverTemplateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallHandoverTemplateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallHandoverTemplateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallHandoverTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OncallHandoverTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OncallHandoverTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OncallHandoverTemplate entity.
// If the OncallHandoverTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallHandoverTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OncallHandoverTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OncallHandoverTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OncallHandoverTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OncallHandoverTemplate entity.
// If the OncallHandoverTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallHandoverTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OncallHandoverTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContents sets the "contents" field.
func (m *OncallHandoverTemplateMutation) SetContents(b []byte) {
	m.contents = &b
}

// Contents returns the value of the "contents" field in the mutation.
func (m *OncallHandoverTemplateMutation) Contents() (r []byte, exists bool) {
	v := m.contents
	if v == nil {
		return
	}
	return *v, true
}

// OldContents returns the old "contents" field's value of the OncallHandoverTemplate entity.
// If the OncallHandoverTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallHandoverTemplateMutation) OldContents(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContents: %w", err)
	}
	return oldValue.Contents, nil
}

// ResetContents resets all changes to the "contents" field.
func (m *OncallHandoverTemplateMutation) ResetContents() {
	m.contents = nil
}

// SetIsDefault sets the "is_default" field.
func (m *OncallHandoverTemplateMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *OncallHandoverTemplateMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the OncallHandoverTemplate entity.
// If the OncallHandoverTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallHandoverTemplateMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *OncallHandoverTemplateMutation) ResetIsDefault() {
	m.is_default = nil
}

// AddRosterIDs adds the "roster" edge to the OncallRoster entity by ids.
func (m *OncallHandoverTemplateMutation) AddRosterIDs(ids ...uuid.UUID) {
	if m.roster == nil {
		m.roster = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roster[ids[i]] = struct{}{}
	}
}

// ClearRoster clears the "roster" edge to the OncallRoster entity.
func (m *OncallHandoverTemplateMutation) ClearRoster() {
	m.clearedroster = true
}

// RosterCleared reports if the "roster" edge to the OncallRoster entity was cleared.
func (m *OncallHandoverTemplateMutation) RosterCleared() bool {
	return m.clearedroster
}

// RemoveRosterIDs removes the "roster" edge to the OncallRoster entity by IDs.
func (m *OncallHandoverTemplateMutation) RemoveRosterIDs(ids ...uuid.UUID) {
	if m.removedroster == nil {
		m.removedroster = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roster, ids[i])
		m.removedroster[ids[i]] = struct{}{}
	}
}

// RemovedRoster returns the removed IDs of the "roster" edge to the OncallRoster entity.
func (m *OncallHandoverTemplateMutation) RemovedRosterIDs() (ids []uuid.UUID) {
	for id := range m.removedroster {
		ids = append(ids, id)
	}
	return
}

// RosterIDs returns the "roster" edge IDs in the mutation.
func (m *OncallHandoverTemplateMutation) RosterIDs() (ids []uuid.UUID) {
	for id := range m.roster {
		ids = append(ids, id)
	}
	return
}

// ResetRoster resets all changes to the "roster" edge.
func (m *OncallHandoverTemplateMutation) ResetRoster() {
	m.roster = nil
	m.clearedroster = false
	m.removedroster = nil
}

// Where appends a list predicates to the OncallHandoverTemplateMutation builder.
func (m *OncallHandoverTemplateMutation) Where(ps ...predicate.OncallHandoverTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallHandoverTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallHandoverTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallHandoverTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallHandoverTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallHandoverTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallHandoverTemplate).
func (m *OncallHandoverTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallHandoverTemplateMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, oncallhandovertemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oncallhandovertemplate.FieldUpdatedAt)
	}
	if m.contents != nil {
		fields = append(fields, oncallhandovertemplate.FieldContents)
	}
	if m.is_default != nil {
		fields = append(fields, oncallhandovertemplate.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallHandoverTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallhandovertemplate.FieldCreatedAt:
		return m.CreatedAt()
	case oncallhandovertemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case oncallhandovertemplate.FieldContents:
		return m.Contents()
	case oncallhandovertemplate.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallHandoverTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallhandovertemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oncallhandovertemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oncallhandovertemplate.FieldContents:
		return m.OldContents(ctx)
	case oncallhandovertemplate.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown OncallHandoverTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallHandoverTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallhandovertemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oncallhandovertemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oncallhandovertemplate.FieldContents:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContents(v)
		return nil
	case oncallhandovertemplate.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown OncallHandoverTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallHandoverTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallHandoverTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallHandoverTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallHandoverTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallHandoverTemplateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallHandoverTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallHandoverTemplateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OncallHandoverTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallHandoverTemplateMutation) ResetField(name string) error {
	switch name {
	case oncallhandovertemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oncallhandovertemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oncallhandovertemplate.FieldContents:
		m.ResetContents()
		return nil
	case oncallhandovertemplate.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown OncallHandoverTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallHandoverTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roster != nil {
		edges = append(edges, oncallhandovertemplate.EdgeRoster)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallHandoverTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallhandovertemplate.EdgeRoster:
		ids := make([]ent.Value, 0, len(m.roster))
		for id := range m.roster {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallHandoverTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroster != nil {
		edges = append(edges, oncallhandovertemplate.EdgeRoster)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallHandoverTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oncallhandovertemplate.EdgeRoster:
		ids := make([]ent.Value, 0, len(m.removedroster))
		for id := range m.removedroster {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallHandoverTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedroster {
		edges = append(edges, oncallhandovertemplate.EdgeRoster)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallHandoverTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallhandovertemplate.EdgeRoster:
		return m.clearedroster
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallHandoverTemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallHandoverTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallHandoverTemplateMutation) ResetEdge(name string) error {
	switch name {
	case oncallhandovertemplate.EdgeRoster:
		m.ResetRoster()
		return nil
	}
	return fmt.Errorf("unknown OncallHandoverTemplate edge %s", name)
}

// OncallRosterMutation represents an operation that mutates the OncallRoster nodes in the graph.
type OncallRosterMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	name                     *string
	slug                     *string
	provider_id              *string
	timezone                 *string
	chat_handle              *string
	chat_channel_id          *string
	clearedFields            map[string]struct{}
	schedules                map[uuid.UUID]struct{}
	removedschedules         map[uuid.UUID]struct{}
	clearedschedules         bool
	handover_template        *uuid.UUID
	clearedhandover_template bool
	teams                    map[uuid.UUID]struct{}
	removedteams             map[uuid.UUID]struct{}
	clearedteams             bool
	shifts                   map[uuid.UUID]struct{}
	removedshifts            map[uuid.UUID]struct{}
	clearedshifts            bool
	alerts                   map[uuid.UUID]struct{}
	removedalerts            map[uuid.UUID]struct{}
	clearedalerts            bool
	done                     bool
	oldValue                 func(context.Context) (*OncallRoster, error)
	predicates               []predicate.OncallRoster
}

var _ ent.Mutation = (*OncallRosterMutation)(nil)

// oncallrosterOption allows management of the mutation configuration using functional options.
type oncallrosterOption func(*OncallRosterMutation)

// newOncallRosterMutation creates new mutation for the OncallRoster entity.
func newOncallRosterMutation(c config, op Op, opts ...oncallrosterOption) *OncallRosterMutation {
	m := &OncallRosterMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallRoster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallRosterID sets the ID field of the mutation.
func withOncallRosterID(id uuid.UUID) oncallrosterOption {
	return func(m *OncallRosterMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallRoster
		)
		m.oldValue = func(ctx context.Context) (*OncallRoster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallRoster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallRoster sets the old OncallRoster of the mutation.
func withOncallRoster(node *OncallRoster) oncallrosterOption {
	return func(m *OncallRosterMutation) {
		m.oldValue = func(context.Context) (*OncallRoster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallRosterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallRosterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallRoster entities.
func (m *OncallRosterMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallRosterMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallRosterMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallRoster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchiveTime sets the "archive_time" field.
func (m *OncallRosterMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *OncallRosterMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *OncallRosterMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[oncallroster.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *OncallRosterMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[oncallroster.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *OncallRosterMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, oncallroster.FieldArchiveTime)
}

// SetName sets the "name" field.
func (m *OncallRosterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OncallRosterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OncallRosterMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *OncallRosterMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *OncallRosterMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *OncallRosterMutation) ResetSlug() {
	m.slug = nil
}

// SetProviderID sets the "provider_id" field.
func (m *OncallRosterMutation) SetProviderID(s string) {
	m.provider_id = &s
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *OncallRosterMutation) ProviderID() (r string, exists bool) {
	v := m.provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *OncallRosterMutation) ResetProviderID() {
	m.provider_id = nil
}

// SetTimezone sets the "timezone" field.
func (m *OncallRosterMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *OncallRosterMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *OncallRosterMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[oncallroster.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *OncallRosterMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[oncallroster.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *OncallRosterMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, oncallroster.FieldTimezone)
}

// SetChatHandle sets the "chat_handle" field.
func (m *OncallRosterMutation) SetChatHandle(s string) {
	m.chat_handle = &s
}

// ChatHandle returns the value of the "chat_handle" field in the mutation.
func (m *OncallRosterMutation) ChatHandle() (r string, exists bool) {
	v := m.chat_handle
	if v == nil {
		return
	}
	return *v, true
}

// OldChatHandle returns the old "chat_handle" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldChatHandle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatHandle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatHandle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatHandle: %w", err)
	}
	return oldValue.ChatHandle, nil
}

// ClearChatHandle clears the value of the "chat_handle" field.
func (m *OncallRosterMutation) ClearChatHandle() {
	m.chat_handle = nil
	m.clearedFields[oncallroster.FieldChatHandle] = struct{}{}
}

// ChatHandleCleared returns if the "chat_handle" field was cleared in this mutation.
func (m *OncallRosterMutation) ChatHandleCleared() bool {
	_, ok := m.clearedFields[oncallroster.FieldChatHandle]
	return ok
}

// ResetChatHandle resets all changes to the "chat_handle" field.
func (m *OncallRosterMutation) ResetChatHandle() {
	m.chat_handle = nil
	delete(m.clearedFields, oncallroster.FieldChatHandle)
}

// SetChatChannelID sets the "chat_channel_id" field.
func (m *OncallRosterMutation) SetChatChannelID(s string) {
	m.chat_channel_id = &s
}

// ChatChannelID returns the value of the "chat_channel_id" field in the mutation.
func (m *OncallRosterMutation) ChatChannelID() (r string, exists bool) {
	v := m.chat_channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChatChannelID returns the old "chat_channel_id" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldChatChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatChannelID: %w", err)
	}
	return oldValue.ChatChannelID, nil
}

// ClearChatChannelID clears the value of the "chat_channel_id" field.
func (m *OncallRosterMutation) ClearChatChannelID() {
	m.chat_channel_id = nil
	m.clearedFields[oncallroster.FieldChatChannelID] = struct{}{}
}

// ChatChannelIDCleared returns if the "chat_channel_id" field was cleared in this mutation.
func (m *OncallRosterMutation) ChatChannelIDCleared() bool {
	_, ok := m.clearedFields[oncallroster.FieldChatChannelID]
	return ok
}

// ResetChatChannelID resets all changes to the "chat_channel_id" field.
func (m *OncallRosterMutation) ResetChatChannelID() {
	m.chat_channel_id = nil
	delete(m.clearedFields, oncallroster.FieldChatChannelID)
}

// SetHandoverTemplateID sets the "handover_template_id" field.
func (m *OncallRosterMutation) SetHandoverTemplateID(u uuid.UUID) {
	m.handover_template = &u
}

// HandoverTemplateID returns the value of the "handover_template_id" field in the mutation.
func (m *OncallRosterMutation) HandoverTemplateID() (r uuid.UUID, exists bool) {
	v := m.handover_template
	if v == nil {
		return
	}
	return *v, true
}

// OldHandoverTemplateID returns the old "handover_template_id" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldHandoverTemplateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandoverTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandoverTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandoverTemplateID: %w", err)
	}
	return oldValue.HandoverTemplateID, nil
}

// ClearHandoverTemplateID clears the value of the "handover_template_id" field.
func (m *OncallRosterMutation) ClearHandoverTemplateID() {
	m.handover_template = nil
	m.clearedFields[oncallroster.FieldHandoverTemplateID] = struct{}{}
}

// HandoverTemplateIDCleared returns if the "handover_template_id" field was cleared in this mutation.
func (m *OncallRosterMutation) HandoverTemplateIDCleared() bool {
	_, ok := m.clearedFields[oncallroster.FieldHandoverTemplateID]
	return ok
}

// ResetHandoverTemplateID resets all changes to the "handover_template_id" field.
func (m *OncallRosterMutation) ResetHandoverTemplateID() {
	m.handover_template = nil
	delete(m.clearedFields, oncallroster.FieldHandoverTemplateID)
}

// AddScheduleIDs adds the "schedules" edge to the OncallSchedule entity by ids.
func (m *OncallRosterMutation) AddScheduleIDs(ids ...uuid.UUID) {
	if m.schedules == nil {
		m.schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// ClearSchedules clears the "schedules" edge to the OncallSchedule entity.
func (m *OncallRosterMutation) ClearSchedules() {
	m.clearedschedules = true
}

// SchedulesCleared reports if the "schedules" edge to the OncallSchedule entity was cleared.
func (m *OncallRosterMutation) SchedulesCleared() bool {
	return m.clearedschedules
}

// RemoveScheduleIDs removes the "schedules" edge to the OncallSchedule entity by IDs.
func (m *OncallRosterMutation) RemoveScheduleIDs(ids ...uuid.UUID) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.schedules, ids[i])
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed IDs of the "schedules" edge to the OncallSchedule entity.
func (m *OncallRosterMutation) RemovedSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the "schedules" edge IDs in the mutation.
func (m *OncallRosterMutation) SchedulesIDs() (ids []uuid.UUID) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules resets all changes to the "schedules" edge.
func (m *OncallRosterMutation) ResetSchedules() {
	m.schedules = nil
	m.clearedschedules = false
	m.removedschedules = nil
}

// ClearHandoverTemplate clears the "handover_template" edge to the OncallHandoverTemplate entity.
func (m *OncallRosterMutation) ClearHandoverTemplate() {
	m.clearedhandover_template = true
	m.clearedFields[oncallroster.FieldHandoverTemplateID] = struct{}{}
}

// HandoverTemplateCleared reports if the "handover_template" edge to the OncallHandoverTemplate entity was cleared.
func (m *OncallRosterMutation) HandoverTemplateCleared() bool {
	return m.HandoverTemplateIDCleared() || m.clearedhandover_template
}

// HandoverTemplateIDs returns the "handover_template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HandoverTemplateID instead. It exists only for internal usage by the builders.
func (m *OncallRosterMutation) HandoverTemplateIDs() (ids []uuid.UUID) {
	if id := m.handover_template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHandoverTemplate resets all changes to the "handover_template" edge.
func (m *OncallRosterMutation) ResetHandoverTemplate() {
	m.handover_template = nil
	m.clearedhandover_template = false
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *OncallRosterMutation) AddTeamIDs(ids ...uuid.UUID) {
	if m.teams == nil {
		m.teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *OncallRosterMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *OncallRosterMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *OncallRosterMutation) RemoveTeamIDs(ids ...uuid.UUID) {
	if m.removedteams == nil {
		m.removedteams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *OncallRosterMutation) RemovedTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *OncallRosterMutation) TeamsIDs() (ids []uuid.UUID) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *OncallRosterMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// AddShiftIDs adds the "shifts" edge to the OncallUserShift entity by ids.
func (m *OncallRosterMutation) AddShiftIDs(ids ...uuid.UUID) {
	if m.shifts == nil {
		m.shifts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shifts[ids[i]] = struct{}{}
	}
}

// ClearShifts clears the "shifts" edge to the OncallUserShift entity.
func (m *OncallRosterMutation) ClearShifts() {
	m.clearedshifts = true
}

// ShiftsCleared reports if the "shifts" edge to the OncallUserShift entity was cleared.
func (m *OncallRosterMutation) ShiftsCleared() bool {
	return m.clearedshifts
}

// RemoveShiftIDs removes the "shifts" edge to the OncallUserShift entity by IDs.
func (m *OncallRosterMutation) RemoveShiftIDs(ids ...uuid.UUID) {
	if m.removedshifts == nil {
		m.removedshifts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shifts, ids[i])
		m.removedshifts[ids[i]] = struct{}{}
	}
}

// RemovedShifts returns the removed IDs of the "shifts" edge to the OncallUserShift entity.
func (m *OncallRosterMutation) RemovedShiftsIDs() (ids []uuid.UUID) {
	for id := range m.removedshifts {
		ids = append(ids, id)
	}
	return
}

// ShiftsIDs returns the "shifts" edge IDs in the mutation.
func (m *OncallRosterMutation) ShiftsIDs() (ids []uuid.UUID) {
	for id := range m.shifts {
		ids = append(ids, id)
	}
	return
}

// ResetShifts resets all changes to the "shifts" edge.
func (m *OncallRosterMutation) ResetShifts() {
	m.shifts = nil
	m.clearedshifts = false
	m.removedshifts = nil
}

// AddAlertIDs adds the "alerts" edge to the OncallAlert entity by ids.
func (m *OncallRosterMutation) AddAlertIDs(ids ...uuid.UUID) {
	if m.alerts == nil {
		m.alerts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.alerts[ids[i]] = struct{}{}
	}
}

// ClearAlerts clears the "alerts" edge to the OncallAlert entity.
func (m *OncallRosterMutation) ClearAlerts() {
	m.clearedalerts = true
}

// AlertsCleared reports if the "alerts" edge to the OncallAlert entity was cleared.
func (m *OncallRosterMutation) AlertsCleared() bool {
	return m.clearedalerts
}

// RemoveAlertIDs removes the "alerts" edge to the OncallAlert entity by IDs.
func (m *OncallRosterMutation) RemoveAlertIDs(ids ...uuid.UUID) {
	if m.removedalerts == nil {
		m.removedalerts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.alerts, ids[i])
		m.removedalerts[ids[i]] = struct{}{}
	}
}

// RemovedAlerts returns the removed IDs of the "alerts" edge to the OncallAlert entity.
func (m *OncallRosterMutation) RemovedAlertsIDs() (ids []uuid.UUID) {
	for id := range m.removedalerts {
		ids = append(ids, id)
	}
	return
}

// AlertsIDs returns the "alerts" edge IDs in the mutation.
func (m *OncallRosterMutation) AlertsIDs() (ids []uuid.UUID) {
	for id := range m.alerts {
		ids = append(ids, id)
	}
	return
}

// ResetAlerts resets all changes to the "alerts" edge.
func (m *OncallRosterMutation) ResetAlerts() {
	m.alerts = nil
	m.clearedalerts = false
	m.removedalerts = nil
}

// Where appends a list predicates to the OncallRosterMutation builder.
func (m *OncallRosterMutation) Where(ps ...predicate.OncallRoster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallRosterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallRosterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallRoster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallRosterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallRosterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallRoster).
func (m *OncallRosterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallRosterMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.archive_time != nil {
		fields = append(fields, oncallroster.FieldArchiveTime)
	}
	if m.name != nil {
		fields = append(fields, oncallroster.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, oncallroster.FieldSlug)
	}
	if m.provider_id != nil {
		fields = append(fields, oncallroster.FieldProviderID)
	}
	if m.timezone != nil {
		fields = append(fields, oncallroster.FieldTimezone)
	}
	if m.chat_handle != nil {
		fields = append(fields, oncallroster.FieldChatHandle)
	}
	if m.chat_channel_id != nil {
		fields = append(fields, oncallroster.FieldChatChannelID)
	}
	if m.handover_template != nil {
		fields = append(fields, oncallroster.FieldHandoverTemplateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallRosterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallroster.FieldArchiveTime:
		return m.ArchiveTime()
	case oncallroster.FieldName:
		return m.Name()
	case oncallroster.FieldSlug:
		return m.Slug()
	case oncallroster.FieldProviderID:
		return m.ProviderID()
	case oncallroster.FieldTimezone:
		return m.Timezone()
	case oncallroster.FieldChatHandle:
		return m.ChatHandle()
	case oncallroster.FieldChatChannelID:
		return m.ChatChannelID()
	case oncallroster.FieldHandoverTemplateID:
		return m.HandoverTemplateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallRosterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallroster.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case oncallroster.FieldName:
		return m.OldName(ctx)
	case oncallroster.FieldSlug:
		return m.OldSlug(ctx)
	case oncallroster.FieldProviderID:
		return m.OldProviderID(ctx)
	case oncallroster.FieldTimezone:
		return m.OldTimezone(ctx)
	case oncallroster.FieldChatHandle:
		return m.OldChatHandle(ctx)
	case oncallroster.FieldChatChannelID:
		return m.OldChatChannelID(ctx)
	case oncallroster.FieldHandoverTemplateID:
		return m.OldHandoverTemplateID(ctx)
	}
	return nil, fmt.Errorf("unknown OncallRoster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallRosterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallroster.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case oncallroster.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oncallroster.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case oncallroster.FieldProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case oncallroster.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case oncallroster.FieldChatHandle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatHandle(v)
		return nil
	case oncallroster.FieldChatChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatChannelID(v)
		return nil
	case oncallroster.FieldHandoverTemplateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandoverTemplateID(v)
		return nil
	}
	return fmt.Errorf("unknown OncallRoster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallRosterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallRosterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallRosterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallRoster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallRosterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oncallroster.FieldArchiveTime) {
		fields = append(fields, oncallroster.FieldArchiveTime)
	}
	if m.FieldCleared(oncallroster.FieldTimezone) {
		fields = append(fields, oncallroster.FieldTimezone)
	}
	if m.FieldCleared(oncallroster.FieldChatHandle) {
		fields = append(fields, oncallroster.FieldChatHandle)
	}
	if m.FieldCleared(oncallroster.FieldChatChannelID) {
		fields = append(fields, oncallroster.FieldChatChannelID)
	}
	if m.FieldCleared(oncallroster.FieldHandoverTemplateID) {
		fields = append(fields, oncallroster.FieldHandoverTemplateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallRosterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallRosterMutation) ClearField(name string) error {
	switch name {
	case oncallroster.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	case oncallroster.FieldTimezone:
		m.ClearTimezone()
		return nil
	case oncallroster.FieldChatHandle:
		m.ClearChatHandle()
		return nil
	case oncallroster.FieldChatChannelID:
		m.ClearChatChannelID()
		return nil
	case oncallroster.FieldHandoverTemplateID:
		m.ClearHandoverTemplateID()
		return nil
	}
	return fmt.Errorf("unknown OncallRoster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallRosterMutation) ResetField(name string) error {
	switch name {
	case oncallroster.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case oncallroster.FieldName:
		m.ResetName()
		return nil
	case oncallroster.FieldSlug:
		m.ResetSlug()
		return nil
	case oncallroster.FieldProviderID:
		m.ResetProviderID()
		return nil
	case oncallroster.FieldTimezone:
		m.ResetTimezone()
		return nil
	case oncallroster.FieldChatHandle:
		m.ResetChatHandle()
		return nil
	case oncallroster.FieldChatChannelID:
		m.ResetChatChannelID()
		return nil
	case oncallroster.FieldHandoverTemplateID:
		m.ResetHandoverTemplateID()
		return nil
	}
	return fmt.Errorf("unknown OncallRoster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallRosterMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.schedules != nil {
		edges = append(edges, oncallroster.EdgeSchedules)
	}
	if m.handover_template != nil {
		edges = append(edges, oncallroster.EdgeHandoverTemplate)
	}
	if m.teams != nil {
		edges = append(edges, oncallroster.EdgeTeams)
	}
	if m.shifts != nil {
		edges = append(edges, oncallroster.EdgeShifts)
	}
	if m.alerts != nil {
		edges = append(edges, oncallroster.EdgeAlerts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallRosterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallroster.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeHandoverTemplate:
		if id := m.handover_template; id != nil {
			return []ent.Value{*id}
		}
	case oncallroster.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeShifts:
		ids := make([]ent.Value, 0, len(m.shifts))
		for id := range m.shifts {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.alerts))
		for id := range m.alerts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallRosterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedschedules != nil {
		edges = append(edges, oncallroster.EdgeSchedules)
	}
	if m.removedteams != nil {
		edges = append(edges, oncallroster.EdgeTeams)
	}
	if m.removedshifts != nil {
		edges = append(edges, oncallroster.EdgeShifts)
	}
	if m.removedalerts != nil {
		edges = append(edges, oncallroster.EdgeAlerts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallRosterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oncallroster.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeShifts:
		ids := make([]ent.Value, 0, len(m.removedshifts))
		for id := range m.removedshifts {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.removedalerts))
		for id := range m.removedalerts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallRosterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedschedules {
		edges = append(edges, oncallroster.EdgeSchedules)
	}
	if m.clearedhandover_template {
		edges = append(edges, oncallroster.EdgeHandoverTemplate)
	}
	if m.clearedteams {
		edges = append(edges, oncallroster.EdgeTeams)
	}
	if m.clearedshifts {
		edges = append(edges, oncallroster.EdgeShifts)
	}
	if m.clearedalerts {
		edges = append(edges, oncallroster.EdgeAlerts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallRosterMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallroster.EdgeSchedules:
		return m.clearedschedules
	case oncallroster.EdgeHandoverTemplate:
		return m.clearedhandover_template
	case oncallroster.EdgeTeams:
		return m.clearedteams
	case oncallroster.EdgeShifts:
		return m.clearedshifts
	case oncallroster.EdgeAlerts:
		return m.clearedalerts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallRosterMutation) ClearEdge(name string) error {
	switch name {
	case oncallroster.EdgeHandoverTemplate:
		m.ClearHandoverTemplate()
		return nil
	}
	return fmt.Errorf("unknown OncallRoster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallRosterMutation) ResetEdge(name string) error {
	switch name {
	case oncallroster.EdgeSchedules:
		m.ResetSchedules()
		return nil
	case oncallroster.EdgeHandoverTemplate:
		m.ResetHandoverTemplate()
		return nil
	case oncallroster.EdgeTeams:
		m.ResetTeams()
		return nil
	case oncallroster.EdgeShifts:
		m.ResetShifts()
		return nil
	case oncallroster.EdgeAlerts:
		m.ResetAlerts()
		return nil
	}
	return fmt.Errorf("unknown OncallRoster edge %s", name)
}

// OncallScheduleMutation represents an operation that mutates the OncallSchedule nodes in the graph.
type OncallScheduleMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	archive_time        *time.Time
	name                *string
	timezone            *string
	provider_id         *string
	clearedFields       map[string]struct{}
	participants        map[uuid.UUID]struct{}
	removedparticipants map[uuid.UUID]struct{}
	clearedparticipants bool
	roster              *uuid.UUID
	clearedroster       bool
	done                bool
	oldValue            func(context.Context) (*OncallSchedule, error)
	predicates          []predicate.OncallSchedule
}

var _ ent.Mutation = (*OncallScheduleMutation)(nil)

// oncallscheduleOption allows management of the mutation configuration using functional options.
type oncallscheduleOption func(*OncallScheduleMutation)

// newOncallScheduleMutation creates new mutation for the OncallSchedule entity.
func newOncallScheduleMutation(c config, op Op, opts ...oncallscheduleOption) *OncallScheduleMutation {
	m := &OncallScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallScheduleID sets the ID field of the mutation.
func withOncallScheduleID(id uuid.UUID) oncallscheduleOption {
	return func(m *OncallScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallSchedule
		)
		m.oldValue = func(ctx context.Context) (*OncallSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallSchedule sets the old OncallSchedule of the mutation.
func withOncallSchedule(node *OncallSchedule) oncallscheduleOption {
	return func(m *OncallScheduleMutation) {
		m.oldValue = func(context.Context) (*OncallSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallSchedule entities.
func (m *OncallScheduleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallScheduleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallScheduleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchiveTime sets the "archive_time" field.
func (m *OncallScheduleMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *OncallScheduleMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the OncallSchedule entity.
// If the OncallSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *OncallScheduleMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[oncallschedule.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *OncallScheduleMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[oncallschedule.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *OncallScheduleMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, oncallschedule.FieldArchiveTime)
}

// SetName sets the "name" field.
func (m *OncallScheduleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OncallScheduleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OncallSchedule entity.
// If the OncallSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OncallScheduleMutation) ResetName() {
	m.name = nil
}

// SetRosterID sets the "roster_id" field.
func (m *OncallScheduleMutation) SetRosterID(u uuid.UUID) {
	m.roster = &u
}

// RosterID returns the value of the "roster_id" field in the mutation.
func (m *OncallScheduleMutation) RosterID() (r uuid.UUID, exists bool) {
	v := m.roster
	if v == nil {
		return
	}
	return *v, true
}

// OldRosterID returns the old "roster_id" field's value of the OncallSchedule entity.
// If the OncallSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleMutation) OldRosterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosterID: %w", err)
	}
	return oldValue.RosterID, nil
}

// ResetRosterID resets all changes to the "roster_id" field.
func (m *OncallScheduleMutation) ResetRosterID() {
	m.roster = nil
}

// SetTimezone sets the "timezone" field.
func (m *OncallScheduleMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *OncallScheduleMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the OncallSchedule entity.
// If the OncallSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *OncallScheduleMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[oncallschedule.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *OncallScheduleMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[oncallschedule.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *OncallScheduleMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, oncallschedule.FieldTimezone)
}

// SetProviderID sets the "provider_id" field.
func (m *OncallScheduleMutation) SetProviderID(s string) {
	m.provider_id = &s
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *OncallScheduleMutation) ProviderID() (r string, exists bool) {
	v := m.provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the OncallSchedule entity.
// If the OncallSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleMutation) OldProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *OncallScheduleMutation) ResetProviderID() {
	m.provider_id = nil
}

// AddParticipantIDs adds the "participants" edge to the OncallScheduleParticipant entity by ids.
func (m *OncallScheduleMutation) AddParticipantIDs(ids ...uuid.UUID) {
	if m.participants == nil {
		m.participants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the OncallScheduleParticipant entity.
func (m *OncallScheduleMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the OncallScheduleParticipant entity was cleared.
func (m *OncallScheduleMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the OncallScheduleParticipant entity by IDs.
func (m *OncallScheduleMutation) RemoveParticipantIDs(ids ...uuid.UUID) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the OncallScheduleParticipant entity.
func (m *OncallScheduleMutation) RemovedParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *OncallScheduleMutation) ParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *OncallScheduleMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// ClearRoster clears the "roster" edge to the OncallRoster entity.
func (m *OncallScheduleMutation) ClearRoster() {
	m.clearedroster = true
	m.clearedFields[oncallschedule.FieldRosterID] = struct{}{}
}

// RosterCleared reports if the "roster" edge to the OncallRoster entity was cleared.
func (m *OncallScheduleMutation) RosterCleared() bool {
	return m.clearedroster
}

// RosterIDs returns the "roster" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RosterID instead. It exists only for internal usage by the builders.
func (m *OncallScheduleMutation) RosterIDs() (ids []uuid.UUID) {
	if id := m.roster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoster resets all changes to the "roster" edge.
func (m *OncallScheduleMutation) ResetRoster() {
	m.roster = nil
	m.clearedroster = false
}

// Where appends a list predicates to the OncallScheduleMutation builder.
func (m *OncallScheduleMutation) Where(ps ...predicate.OncallSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallSchedule).
func (m *OncallScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallScheduleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.archive_time != nil {
		fields = append(fields, oncallschedule.FieldArchiveTime)
	}
	if m.name != nil {
		fields = append(fields, oncallschedule.FieldName)
	}
	if m.roster != nil {
		fields = append(fields, oncallschedule.FieldRosterID)
	}
	if m.timezone != nil {
		fields = append(fields, oncallschedule.FieldTimezone)
	}
	if m.provider_id != nil {
		fields = append(fields, oncallschedule.FieldProviderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallschedule.FieldArchiveTime:
		return m.ArchiveTime()
	case oncallschedule.FieldName:
		return m.Name()
	case oncallschedule.FieldRosterID:
		return m.RosterID()
	case oncallschedule.FieldTimezone:
		return m.Timezone()
	case oncallschedule.FieldProviderID:
		return m.ProviderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallschedule.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case oncallschedule.FieldName:
		return m.OldName(ctx)
	case oncallschedule.FieldRosterID:
		return m.OldRosterID(ctx)
	case oncallschedule.FieldTimezone:
		return m.OldTimezone(ctx)
	case oncallschedule.FieldProviderID:
		return m.OldProviderID(ctx)
	}
	return nil, fmt.Errorf("unknown OncallSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallschedule.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case oncallschedule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oncallschedule.FieldRosterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosterID(v)
		return nil
	case oncallschedule.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case oncallschedule.FieldProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	}
	return fmt.Errorf("unknown OncallSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallScheduleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallScheduleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oncallschedule.FieldArchiveTime) {
		fields = append(fields, oncallschedule.FieldArchiveTime)
	}
	if m.FieldCleared(oncallschedule.FieldTimezone) {
		fields = append(fields, oncallschedule.FieldTimezone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallScheduleMutation) ClearField(name string) error {
	switch name {
	case oncallschedule.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	case oncallschedule.FieldTimezone:
		m.ClearTimezone()
		return nil
	}
	return fmt.Errorf("unknown OncallSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallScheduleMutation) ResetField(name string) error {
	switch name {
	case oncallschedule.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case oncallschedule.FieldName:
		m.ResetName()
		return nil
	case oncallschedule.FieldRosterID:
		m.ResetRosterID()
		return nil
	case oncallschedule.FieldTimezone:
		m.ResetTimezone()
		return nil
	case oncallschedule.FieldProviderID:
		m.ResetProviderID()
		return nil
	}
	return fmt.Errorf("unknown OncallSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.participants != nil {
		edges = append(edges, oncallschedule.EdgeParticipants)
	}
	if m.roster != nil {
		edges = append(edges, oncallschedule.EdgeRoster)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallschedule.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case oncallschedule.EdgeRoster:
		if id := m.roster; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedparticipants != nil {
		edges = append(edges, oncallschedule.EdgeParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oncallschedule.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparticipants {
		edges = append(edges, oncallschedule.EdgeParticipants)
	}
	if m.clearedroster {
		edges = append(edges, oncallschedule.EdgeRoster)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallschedule.EdgeParticipants:
		return m.clearedparticipants
	case oncallschedule.EdgeRoster:
		return m.clearedroster
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallScheduleMutation) ClearEdge(name string) error {
	switch name {
	case oncallschedule.EdgeRoster:
		m.ClearRoster()
		return nil
	}
	return fmt.Errorf("unknown OncallSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallScheduleMutation) ResetEdge(name string) error {
	switch name {
	case oncallschedule.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case oncallschedule.EdgeRoster:
		m.ResetRoster()
		return nil
	}
	return fmt.Errorf("unknown OncallSchedule edge %s", name)
}

// OncallScheduleParticipantMutation represents an operation that mutates the OncallScheduleParticipant nodes in the graph.
type OncallScheduleParticipantMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	index           *int
	addindex        *int
	clearedFields   map[string]struct{}
	schedule        *uuid.UUID
	clearedschedule bool
	user            *uuid.UUID
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*OncallScheduleParticipant, error)
	predicates      []predicate.OncallScheduleParticipant
}

var _ ent.Mutation = (*OncallScheduleParticipantMutation)(nil)

// oncallscheduleparticipantOption allows management of the mutation configuration using functional options.
type oncallscheduleparticipantOption func(*OncallScheduleParticipantMutation)

// newOncallScheduleParticipantMutation creates new mutation for the OncallScheduleParticipant entity.
func newOncallScheduleParticipantMutation(c config, op Op, opts ...oncallscheduleparticipantOption) *OncallScheduleParticipantMutation {
	m := &OncallScheduleParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallScheduleParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallScheduleParticipantID sets the ID field of the mutation.
func withOncallScheduleParticipantID(id uuid.UUID) oncallscheduleparticipantOption {
	return func(m *OncallScheduleParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallScheduleParticipant
		)
		m.oldValue = func(ctx context.Context) (*OncallScheduleParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallScheduleParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallScheduleParticipant sets the old OncallScheduleParticipant of the mutation.
func withOncallScheduleParticipant(node *OncallScheduleParticipant) oncallscheduleparticipantOption {
	return func(m *OncallScheduleParticipantMutation) {
		m.oldValue = func(context.Context) (*OncallScheduleParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallScheduleParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallScheduleParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallScheduleParticipant entities.
func (m *OncallScheduleParticipantMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallScheduleParticipantMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallScheduleParticipantMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallScheduleParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScheduleID sets the "schedule_id" field.
func (m *OncallScheduleParticipantMutation) SetScheduleID(u uuid.UUID) {
	m.schedule = &u
}

// ScheduleID returns the value of the "schedule_id" field in the mutation.
func (m *OncallScheduleParticipantMutation) ScheduleID() (r uuid.UUID, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleID returns the old "schedule_id" field's value of the OncallScheduleParticipant entity.
// If the OncallScheduleParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleParticipantMutation) OldScheduleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleID: %w", err)
	}
	return oldValue.ScheduleID, nil
}

// ResetScheduleID resets all changes to the "schedule_id" field.
func (m *OncallScheduleParticipantMutation) ResetScheduleID() {
	m.schedule = nil
}

// SetUserID sets the "user_id" field.
func (m *OncallScheduleParticipantMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OncallScheduleParticipantMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OncallScheduleParticipant entity.
// If the OncallScheduleParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleParticipantMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OncallScheduleParticipantMutation) ResetUserID() {
	m.user = nil
}

// SetIndex sets the "index" field.
func (m *OncallScheduleParticipantMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *OncallScheduleParticipantMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the OncallScheduleParticipant entity.
// If the OncallScheduleParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleParticipantMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *OncallScheduleParticipantMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *OncallScheduleParticipantMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *OncallScheduleParticipantMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// ClearSchedule clears the "schedule" edge to the OncallSchedule entity.
func (m *OncallScheduleParticipantMutation) ClearSchedule() {
	m.clearedschedule = true
	m.clearedFields[oncallscheduleparticipant.FieldScheduleID] = struct{}{}
}

// ScheduleCleared reports if the "schedule" edge to the OncallSchedule entity was cleared.
func (m *OncallScheduleParticipantMutation) ScheduleCleared() bool {
	return m.clearedschedule
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *OncallScheduleParticipantMutation) ScheduleIDs() (ids []uuid.UUID) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *OncallScheduleParticipantMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OncallScheduleParticipantMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[oncallscheduleparticipant.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OncallScheduleParticipantMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OncallScheduleParticipantMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OncallScheduleParticipantMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OncallScheduleParticipantMutation builder.
func (m *OncallScheduleParticipantMutation) Where(ps ...predicate.OncallScheduleParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallScheduleParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallScheduleParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallScheduleParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallScheduleParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallScheduleParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallScheduleParticipant).
func (m *OncallScheduleParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallScheduleParticipantMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.schedule != nil {
		fields = append(fields, oncallscheduleparticipant.FieldScheduleID)
	}
	if m.user != nil {
		fields = append(fields, oncallscheduleparticipant.FieldUserID)
	}
	if m.index != nil {
		fields = append(fields, oncallscheduleparticipant.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallScheduleParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallscheduleparticipant.FieldScheduleID:
		return m.ScheduleID()
	case oncallscheduleparticipant.FieldUserID:
		return m.UserID()
	case oncallscheduleparticipant.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallScheduleParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallscheduleparticipant.FieldScheduleID:
		return m.OldScheduleID(ctx)
	case oncallscheduleparticipant.FieldUserID:
		return m.OldUserID(ctx)
	case oncallscheduleparticipant.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown OncallScheduleParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallScheduleParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallscheduleparticipant.FieldScheduleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleID(v)
		return nil
	case oncallscheduleparticipant.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oncallscheduleparticipant.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown OncallScheduleParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallScheduleParticipantMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, oncallscheduleparticipant.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallScheduleParticipantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oncallscheduleparticipant.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallScheduleParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oncallscheduleparticipant.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown OncallScheduleParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallScheduleParticipantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallScheduleParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallScheduleParticipantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OncallScheduleParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallScheduleParticipantMutation) ResetField(name string) error {
	switch name {
	case oncallscheduleparticipant.FieldScheduleID:
		m.ResetScheduleID()
		return nil
	case oncallscheduleparticipant.FieldUserID:
		m.ResetUserID()
		return nil
	case oncallscheduleparticipant.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown OncallScheduleParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallScheduleParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.schedule != nil {
		edges = append(edges, oncallscheduleparticipant.EdgeSchedule)
	}
	if m.user != nil {
		edges = append(edges, oncallscheduleparticipant.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallScheduleParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallscheduleparticipant.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	case oncallscheduleparticipant.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallScheduleParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallScheduleParticipantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallScheduleParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedschedule {
		edges = append(edges, oncallscheduleparticipant.EdgeSchedule)
	}
	if m.cleareduser {
		edges = append(edges, oncallscheduleparticipant.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallScheduleParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallscheduleparticipant.EdgeSchedule:
		return m.clearedschedule
	case oncallscheduleparticipant.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallScheduleParticipantMutation) ClearEdge(name string) error {
	switch name {
	case oncallscheduleparticipant.EdgeSchedule:
		m.ClearSchedule()
		return nil
	case oncallscheduleparticipant.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OncallScheduleParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallScheduleParticipantMutation) ResetEdge(name string) error {
	switch name {
	case oncallscheduleparticipant.EdgeSchedule:
		m.ResetSchedule()
		return nil
	case oncallscheduleparticipant.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OncallScheduleParticipant edge %s", name)
}

// OncallUserShiftMutation represents an operation that mutates the OncallUserShift nodes in the graph.
type OncallUserShiftMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	start_at           *time.Time
	end_at             *time.Time
	provider_id        *string
	clearedFields      map[string]struct{}
	user               *uuid.UUID
	cleareduser        bool
	roster             *uuid.UUID
	clearedroster      bool
	covers             map[uuid.UUID]struct{}
	removedcovers      map[uuid.UUID]struct{}
	clearedcovers      bool
	annotations        map[uuid.UUID]struct{}
	removedannotations map[uuid.UUID]struct{}
	clearedannotations bool
	handover           *uuid.UUID
	clearedhandover    bool
	done               bool
	oldValue           func(context.Context) (*OncallUserShift, error)
	predicates         []predicate.OncallUserShift
}

var _ ent.Mutation = (*OncallUserShiftMutation)(nil)

// oncallusershiftOption allows management of the mutation configuration using functional options.
type oncallusershiftOption func(*OncallUserShiftMutation)

// newOncallUserShiftMutation creates new mutation for the OncallUserShift entity.
func newOncallUserShiftMutation(c config, op Op, opts ...oncallusershiftOption) *OncallUserShiftMutation {
	m := &OncallUserShiftMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallUserShift,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallUserShiftID sets the ID field of the mutation.
func withOncallUserShiftID(id uuid.UUID) oncallusershiftOption {
	return func(m *OncallUserShiftMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallUserShift
		)
		m.oldValue = func(ctx context.Context) (*OncallUserShift, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallUserShift.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallUserShift sets the old OncallUserShift of the mutation.
func withOncallUserShift(node *OncallUserShift) oncallusershiftOption {
	return func(m *OncallUserShiftMutation) {
		m.oldValue = func(context.Context) (*OncallUserShift, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallUserShiftMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallUserShiftMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallUserShift entities.
func (m *OncallUserShiftMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallUserShiftMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallUserShiftMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallUserShift.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *OncallUserShiftMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OncallUserShiftMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OncallUserShift entity.
// If the OncallUserShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OncallUserShiftMutation) ResetUserID() {
	m.user = nil
}

// SetRosterID sets the "roster_id" field.
func (m *OncallUserShiftMutation) SetRosterID(u uuid.UUID) {
	m.roster = &u
}

// RosterID returns the value of the "roster_id" field in the mutation.
func (m *OncallUserShiftMutation) RosterID() (r uuid.UUID, exists bool) {
	v := m.roster
	if v == nil {
		return
	}
	return *v, true
}

// OldRosterID returns the old "roster_id" field's value of the OncallUserShift entity.
// If the OncallUserShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftMutation) OldRosterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosterID: %w", err)
	}
	return oldValue.RosterID, nil
}

// ResetRosterID resets all changes to the "roster_id" field.
func (m *OncallUserShiftMutation) ResetRosterID() {
	m.roster = nil
}

// SetStartAt sets the "start_at" field.
func (m *OncallUserShiftMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *OncallUserShiftMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the OncallUserShift entity.
// If the OncallUserShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *OncallUserShiftMutation) ResetStartAt() {
	m.start_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *OncallUserShiftMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *OncallUserShiftMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the OncallUserShift entity.
// If the OncallUserShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *OncallUserShiftMutation) ResetEndAt() {
	m.end_at = nil
}

// SetProviderID sets the "provider_id" field.
func (m *OncallUserShiftMutation) SetProviderID(s string) {
	m.provider_id = &s
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *OncallUserShiftMutation) ProviderID() (r string, exists bool) {
	v := m.provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the OncallUserShift entity.
// If the OncallUserShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftMutation) OldProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ClearProviderID clears the value of the "provider_id" field.
func (m *OncallUserShiftMutation) ClearProviderID() {
	m.provider_id = nil
	m.clearedFields[oncallusershift.FieldProviderID] = struct{}{}
}

// ProviderIDCleared returns if the "provider_id" field was cleared in this mutation.
func (m *OncallUserShiftMutation) ProviderIDCleared() bool {
	_, ok := m.clearedFields[oncallusershift.FieldProviderID]
	return ok
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *OncallUserShiftMutation) ResetProviderID() {
	m.provider_id = nil
	delete(m.clearedFields, oncallusershift.FieldProviderID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *OncallUserShiftMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[oncallusershift.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OncallUserShiftMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OncallUserShiftMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OncallUserShiftMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRoster clears the "roster" edge to the OncallRoster entity.
func (m *OncallUserShiftMutation) ClearRoster() {
	m.clearedroster = true
	m.clearedFields[oncallusershift.FieldRosterID] = struct{}{}
}

// RosterCleared reports if the "roster" edge to the OncallRoster entity was cleared.
func (m *OncallUserShiftMutation) RosterCleared() bool {
	return m.clearedroster
}

// RosterIDs returns the "roster" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RosterID instead. It exists only for internal usage by the builders.
func (m *OncallUserShiftMutation) RosterIDs() (ids []uuid.UUID) {
	if id := m.roster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoster resets all changes to the "roster" edge.
func (m *OncallUserShiftMutation) ResetRoster() {
	m.roster = nil
	m.clearedroster = false
}

// AddCoverIDs adds the "covers" edge to the OncallUserShiftCover entity by ids.
func (m *OncallUserShiftMutation) AddCoverIDs(ids ...uuid.UUID) {
	if m.covers == nil {
		m.covers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.covers[ids[i]] = struct{}{}
	}
}

// ClearCovers clears the "covers" edge to the OncallUserShiftCover entity.
func (m *OncallUserShiftMutation) ClearCovers() {
	m.clearedcovers = true
}

// CoversCleared reports if the "covers" edge to the OncallUserShiftCover entity was cleared.
func (m *OncallUserShiftMutation) CoversCleared() bool {
	return m.clearedcovers
}

// RemoveCoverIDs removes the "covers" edge to the OncallUserShiftCover entity by IDs.
func (m *OncallUserShiftMutation) RemoveCoverIDs(ids ...uuid.UUID) {
	if m.removedcovers == nil {
		m.removedcovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.covers, ids[i])
		m.removedcovers[ids[i]] = struct{}{}
	}
}

// RemovedCovers returns the removed IDs of the "covers" edge to the OncallUserShiftCover entity.
func (m *OncallUserShiftMutation) RemovedCoversIDs() (ids []uuid.UUID) {
	for id := range m.removedcovers {
		ids = append(ids, id)
	}
	return
}

// CoversIDs returns the "covers" edge IDs in the mutation.
func (m *OncallUserShiftMutation) CoversIDs() (ids []uuid.UUID) {
	for id := range m.covers {
		ids = append(ids, id)
	}
	return
}

// ResetCovers resets all changes to the "covers" edge.
func (m *OncallUserShiftMutation) ResetCovers() {
	m.covers = nil
	m.clearedcovers = false
	m.removedcovers = nil
}

// AddAnnotationIDs adds the "annotations" edge to the OncallUserShiftAnnotation entity by ids.
func (m *OncallUserShiftMutation) AddAnnotationIDs(ids ...uuid.UUID) {
	if m.annotations == nil {
		m.annotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.annotations[ids[i]] = struct{}{}
	}
}

// ClearAnnotations clears the "annotations" edge to the OncallUserShiftAnnotation entity.
func (m *OncallUserShiftMutation) ClearAnnotations() {
	m.clearedannotations = true
}

// AnnotationsCleared reports if the "annotations" edge to the OncallUserShiftAnnotation entity was cleared.
func (m *OncallUserShiftMutation) AnnotationsCleared() bool {
	return m.clearedannotations
}

// RemoveAnnotationIDs removes the "annotations" edge to the OncallUserShiftAnnotation entity by IDs.
func (m *OncallUserShiftMutation) RemoveAnnotationIDs(ids ...uuid.UUID) {
	if m.removedannotations == nil {
		m.removedannotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.annotations, ids[i])
		m.removedannotations[ids[i]] = struct{}{}
	}
}

// RemovedAnnotations returns the removed IDs of the "annotations" edge to the OncallUserShiftAnnotation entity.
func (m *OncallUserShiftMutation) RemovedAnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.removedannotations {
		ids = append(ids, id)
	}
	return
}

// AnnotationsIDs returns the "annotations" edge IDs in the mutation.
func (m *OncallUserShiftMutation) AnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.annotations {
		ids = append(ids, id)
	}
	return
}

// ResetAnnotations resets all changes to the "annotations" edge.
func (m *OncallUserShiftMutation) ResetAnnotations() {
	m.annotations = nil
	m.clearedannotations = false
	m.removedannotations = nil
}

// SetHandoverID sets the "handover" edge to the OncallUserShiftHandover entity by id.
func (m *OncallUserShiftMutation) SetHandoverID(id uuid.UUID) {
	m.handover = &id
}

// ClearHandover clears the "handover" edge to the OncallUserShiftHandover entity.
func (m *OncallUserShiftMutation) ClearHandover() {
	m.clearedhandover = true
}

// HandoverCleared reports if the "handover" edge to the OncallUserShiftHandover entity was cleared.
func (m *OncallUserShiftMutation) HandoverCleared() bool {
	return m.clearedhandover
}

// HandoverID returns the "handover" edge ID in the mutation.
func (m *OncallUserShiftMutation) HandoverID() (id uuid.UUID, exists bool) {
	if m.handover != nil {
		return *m.handover, true
	}
	return
}

// HandoverIDs returns the "handover" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HandoverID instead. It exists only for internal usage by the builders.
func (m *OncallUserShiftMutation) HandoverIDs() (ids []uuid.UUID) {
	if id := m.handover; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHandover resets all changes to the "handover" edge.
func (m *OncallUserShiftMutation) ResetHandover() {
	m.handover = nil
	m.clearedhandover = false
}

// Where appends a list predicates to the OncallUserShiftMutation builder.
func (m *OncallUserShiftMutation) Where(ps ...predicate.OncallUserShift) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallUserShiftMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallUserShiftMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallUserShift, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallUserShiftMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallUserShiftMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallUserShift).
func (m *OncallUserShiftMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallUserShiftMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, oncallusershift.FieldUserID)
	}
	if m.roster != nil {
		fields = append(fields, oncallusershift.FieldRosterID)
	}
	if m.start_at != nil {
		fields = append(fields, oncallusershift.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, oncallusershift.FieldEndAt)
	}
	if m.provider_id != nil {
		fields = append(fields, oncallusershift.FieldProviderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallUserShiftMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallusershift.FieldUserID:
		return m.UserID()
	case oncallusershift.FieldRosterID:
		return m.RosterID()
	case oncallusershift.FieldStartAt:
		return m.StartAt()
	case oncallusershift.FieldEndAt:
		return m.EndAt()
	case oncallusershift.FieldProviderID:
		return m.ProviderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallUserShiftMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallusershift.FieldUserID:
		return m.OldUserID(ctx)
	case oncallusershift.FieldRosterID:
		return m.OldRosterID(ctx)
	case oncallusershift.FieldStartAt:
		return m.OldStartAt(ctx)
	case oncallusershift.FieldEndAt:
		return m.OldEndAt(ctx)
	case oncallusershift.FieldProviderID:
		return m.OldProviderID(ctx)
	}
	return nil, fmt.Errorf("unknown OncallUserShift field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallUserShiftMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallusershift.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oncallusershift.FieldRosterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosterID(v)
		return nil
	case oncallusershift.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case oncallusershift.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case oncallusershift.FieldProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	}
	return fmt.Errorf("unknown OncallUserShift field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallUserShiftMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallUserShiftMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallUserShiftMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallUserShift numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallUserShiftMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oncallusershift.FieldProviderID) {
		fields = append(fields, oncallusershift.FieldProviderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallUserShiftMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallUserShiftMutation) ClearField(name string) error {
	switch name {
	case oncallusershift.FieldProviderID:
		m.ClearProviderID()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShift nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallUserShiftMutation) ResetField(name string) error {
	switch name {
	case oncallusershift.FieldUserID:
		m.ResetUserID()
		return nil
	case oncallusershift.FieldRosterID:
		m.ResetRosterID()
		return nil
	case oncallusershift.FieldStartAt:
		m.ResetStartAt()
		return nil
	case oncallusershift.FieldEndAt:
		m.ResetEndAt()
		return nil
	case oncallusershift.FieldProviderID:
		m.ResetProviderID()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShift field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallUserShiftMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, oncallusershift.EdgeUser)
	}
	if m.roster != nil {
		edges = append(edges, oncallusershift.EdgeRoster)
	}
	if m.covers != nil {
		edges = append(edges, oncallusershift.EdgeCovers)
	}
	if m.annotations != nil {
		edges = append(edges, oncallusershift.EdgeAnnotations)
	}
	if m.handover != nil {
		edges = append(edges, oncallusershift.EdgeHandover)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallUserShiftMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallusershift.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case oncallusershift.EdgeRoster:
		if id := m.roster; id != nil {
			return []ent.Value{*id}
		}
	case oncallusershift.EdgeCovers:
		ids := make([]ent.Value, 0, len(m.covers))
		for id := range m.covers {
			ids = append(ids, id)
		}
		return ids
	case oncallusershift.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.annotations))
		for id := range m.annotations {
			ids = append(ids, id)
		}
		return ids
	case oncallusershift.EdgeHandover:
		if id := m.handover; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallUserShiftMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcovers != nil {
		edges = append(edges, oncallusershift.EdgeCovers)
	}
	if m.removedannotations != nil {
		edges = append(edges, oncallusershift.EdgeAnnotations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallUserShiftMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oncallusershift.EdgeCovers:
		ids := make([]ent.Value, 0, len(m.removedcovers))
		for id := range m.removedcovers {
			ids = append(ids, id)
		}
		return ids
	case oncallusershift.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.removedannotations))
		for id := range m.removedannotations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallUserShiftMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, oncallusershift.EdgeUser)
	}
	if m.clearedroster {
		edges = append(edges, oncallusershift.EdgeRoster)
	}
	if m.clearedcovers {
		edges = append(edges, oncallusershift.EdgeCovers)
	}
	if m.clearedannotations {
		edges = append(edges, oncallusershift.EdgeAnnotations)
	}
	if m.clearedhandover {
		edges = append(edges, oncallusershift.EdgeHandover)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallUserShiftMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallusershift.EdgeUser:
		return m.cleareduser
	case oncallusershift.EdgeRoster:
		return m.clearedroster
	case oncallusershift.EdgeCovers:
		return m.clearedcovers
	case oncallusershift.EdgeAnnotations:
		return m.clearedannotations
	case oncallusershift.EdgeHandover:
		return m.clearedhandover
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallUserShiftMutation) ClearEdge(name string) error {
	switch name {
	case oncallusershift.EdgeUser:
		m.ClearUser()
		return nil
	case oncallusershift.EdgeRoster:
		m.ClearRoster()
		return nil
	case oncallusershift.EdgeHandover:
		m.ClearHandover()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShift unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallUserShiftMutation) ResetEdge(name string) error {
	switch name {
	case oncallusershift.EdgeUser:
		m.ResetUser()
		return nil
	case oncallusershift.EdgeRoster:
		m.ResetRoster()
		return nil
	case oncallusershift.EdgeCovers:
		m.ResetCovers()
		return nil
	case oncallusershift.EdgeAnnotations:
		m.ResetAnnotations()
		return nil
	case oncallusershift.EdgeHandover:
		m.ResetHandover()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShift edge %s", name)
}

// OncallUserShiftAnnotationMutation represents an operation that mutates the OncallUserShiftAnnotation nodes in the graph.
type OncallUserShiftAnnotationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	event_id            *string
	event_kind          *oncallusershiftannotation.EventKind
	title               *string
	occurred_at         *time.Time
	minutes_occupied    *int
	addminutes_occupied *int
	notes               *string
	pinned              *bool
	clearedFields       map[string]struct{}
	shift               *uuid.UUID
	clearedshift        bool
	done                bool
	oldValue            func(context.Context) (*OncallUserShiftAnnotation, error)
	predicates          []predicate.OncallUserShiftAnnotation
}

var _ ent.Mutation = (*OncallUserShiftAnnotationMutation)(nil)

// oncallusershiftannotationOption allows management of the mutation configuration using functional options.
type oncallusershiftannotationOption func(*OncallUserShiftAnnotationMutation)

// newOncallUserShiftAnnotationMutation creates new mutation for the OncallUserShiftAnnotation entity.
func newOncallUserShiftAnnotationMutation(c config, op Op, opts ...oncallusershiftannotationOption) *OncallUserShiftAnnotationMutation {
	m := &OncallUserShiftAnnotationMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallUserShiftAnnotation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallUserShiftAnnotationID sets the ID field of the mutation.
func withOncallUserShiftAnnotationID(id uuid.UUID) oncallusershiftannotationOption {
	return func(m *OncallUserShiftAnnotationMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallUserShiftAnnotation
		)
		m.oldValue = func(ctx context.Context) (*OncallUserShiftAnnotation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallUserShiftAnnotation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallUserShiftAnnotation sets the old OncallUserShiftAnnotation of the mutation.
func withOncallUserShiftAnnotation(node *OncallUserShiftAnnotation) oncallusershiftannotationOption {
	return func(m *OncallUserShiftAnnotationMutation) {
		m.oldValue = func(context.Context) (*OncallUserShiftAnnotation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallUserShiftAnnotationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallUserShiftAnnotationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallUserShiftAnnotation entities.
func (m *OncallUserShiftAnnotationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallUserShiftAnnotationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallUserShiftAnnotationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallUserShiftAnnotation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetShiftID sets the "shift_id" field.
func (m *OncallUserShiftAnnotationMutation) SetShiftID(u uuid.UUID) {
	m.shift = &u
}

// ShiftID returns the value of the "shift_id" field in the mutation.
func (m *OncallUserShiftAnnotationMutation) ShiftID() (r uuid.UUID, exists bool) {
	v := m.shift
	if v == nil {
		return
	}
	return *v, true
}

// OldShiftID returns the old "shift_id" field's value of the OncallUserShiftAnnotation entity.
// If the OncallUserShiftAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftAnnotationMutation) OldShiftID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShiftID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShiftID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShiftID: %w", err)
	}
	return oldValue.ShiftID, nil
}

// ResetShiftID resets all changes to the "shift_id" field.
func (m *OncallUserShiftAnnotationMutation) ResetShiftID() {
	m.shift = nil
}

// SetEventID sets the "event_id" field.
func (m *OncallUserShiftAnnotationMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *OncallUserShiftAnnotationMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the OncallUserShiftAnnotation entity.
// If the OncallUserShiftAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftAnnotationMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *OncallUserShiftAnnotationMutation) ResetEventID() {
	m.event_id = nil
}

// SetEventKind sets the "event_kind" field.
func (m *OncallUserShiftAnnotationMutation) SetEventKind(ok oncallusershiftannotation.EventKind) {
	m.event_kind = &ok
}

// EventKind returns the value of the "event_kind" field in the mutation.
func (m *OncallUserShiftAnnotationMutation) EventKind() (r oncallusershiftannotation.EventKind, exists bool) {
	v := m.event_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldEventKind returns the old "event_kind" field's value of the OncallUserShiftAnnotation entity.
// If the OncallUserShiftAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftAnnotationMutation) OldEventKind(ctx context.Context) (v oncallusershiftannotation.EventKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventKind: %w", err)
	}
	return oldValue.EventKind, nil
}

// ResetEventKind resets all changes to the "event_kind" field.
func (m *OncallUserShiftAnnotationMutation) ResetEventKind() {
	m.event_kind = nil
}

// SetTitle sets the "title" field.
func (m *OncallUserShiftAnnotationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *OncallUserShiftAnnotationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the OncallUserShiftAnnotation entity.
// If the OncallUserShiftAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftAnnotationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *OncallUserShiftAnnotationMutation) ResetTitle() {
	m.title = nil
}

// SetOccurredAt sets the "occurred_at" field.
func (m *OncallUserShiftAnnotationMutation) SetOccurredAt(t time.Time) {
	m.occurred_at = &t
}

// OccurredAt returns the value of the "occurred_at" field in the mutation.
func (m *OncallUserShiftAnnotationMutation) OccurredAt() (r time.Time, exists bool) {
	v := m.occurred_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOccurredAt returns the old "occurred_at" field's value of the OncallUserShiftAnnotation entity.
// If the OncallUserShiftAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftAnnotationMutation) OldOccurredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccurredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccurredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccurredAt: %w", err)
	}
	return oldValue.OccurredAt, nil
}

// ResetOccurredAt resets all changes to the "occurred_at" field.
func (m *OncallUserShiftAnnotationMutation) ResetOccurredAt() {
	m.occurred_at = nil
}

// SetMinutesOccupied sets the "minutes_occupied" field.
func (m *OncallUserShiftAnnotationMutation) SetMinutesOccupied(i int) {
	m.minutes_occupied = &i
	m.addminutes_occupied = nil
}

// MinutesOccupied returns the value of the "minutes_occupied" field in the mutation.
func (m *OncallUserShiftAnnotationMutation) MinutesOccupied() (r int, exists bool) {
	v := m.minutes_occupied
	if v == nil {
		return
	}
	return *v, true
}

// OldMinutesOccupied returns the old "minutes_occupied" field's value of the OncallUserShiftAnnotation entity.
// If the OncallUserShiftAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftAnnotationMutation) OldMinutesOccupied(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinutesOccupied is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinutesOccupied requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinutesOccupied: %w", err)
	}
	return oldValue.MinutesOccupied, nil
}

// AddMinutesOccupied adds i to the "minutes_occupied" field.
func (m *OncallUserShiftAnnotationMutation) AddMinutesOccupied(i int) {
	if m.addminutes_occupied != nil {
		*m.addminutes_occupied += i
	} else {
		m.addminutes_occupied = &i
	}
}

// AddedMinutesOccupied returns the value that was added to the "minutes_occupied" field in this mutation.
func (m *OncallUserShiftAnnotationMutation) AddedMinutesOccupied() (r int, exists bool) {
	v := m.addminutes_occupied
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinutesOccupied resets all changes to the "minutes_occupied" field.
func (m *OncallUserShiftAnnotationMutation) ResetMinutesOccupied() {
	m.minutes_occupied = nil
	m.addminutes_occupied = nil
}

// SetNotes sets the "notes" field.
func (m *OncallUserShiftAnnotationMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *OncallUserShiftAnnotationMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the OncallUserShiftAnnotation entity.
// If the OncallUserShiftAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftAnnotationMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ResetNotes resets all changes to the "notes" field.
func (m *OncallUserShiftAnnotationMutation) ResetNotes() {
	m.notes = nil
}

// SetPinned sets the "pinned" field.
func (m *OncallUserShiftAnnotationMutation) SetPinned(b bool) {
	m.pinned = &b
}

// Pinned returns the value of the "pinned" field in the mutation.
func (m *OncallUserShiftAnnotationMutation) Pinned() (r bool, exists bool) {
	v := m.pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldPinned returns the old "pinned" field's value of the OncallUserShiftAnnotation entity.
// If the OncallUserShiftAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftAnnotationMutation) OldPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinned: %w", err)
	}
	return oldValue.Pinned, nil
}

// ResetPinned resets all changes to the "pinned" field.
func (m *OncallUserShiftAnnotationMutation) ResetPinned() {
	m.pinned = nil
}

// ClearShift clears the "shift" edge to the OncallUserShift entity.
func (m *OncallUserShiftAnnotationMutation) ClearShift() {
	m.clearedshift = true
	m.clearedFields[oncallusershiftannotation.FieldShiftID] = struct{}{}
}

// ShiftCleared reports if the "shift" edge to the OncallUserShift entity was cleared.
func (m *OncallUserShiftAnnotationMutation) ShiftCleared() bool {
	return m.clearedshift
}

// ShiftIDs returns the "shift" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShiftID instead. It exists only for internal usage by the builders.
func (m *OncallUserShiftAnnotationMutation) ShiftIDs() (ids []uuid.UUID) {
	if id := m.shift; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShift resets all changes to the "shift" edge.
func (m *OncallUserShiftAnnotationMutation) ResetShift() {
	m.shift = nil
	m.clearedshift = false
}

// Where appends a list predicates to the OncallUserShiftAnnotationMutation builder.
func (m *OncallUserShiftAnnotationMutation) Where(ps ...predicate.OncallUserShiftAnnotation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallUserShiftAnnotationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallUserShiftAnnotationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallUserShiftAnnotation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallUserShiftAnnotationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallUserShiftAnnotationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallUserShiftAnnotation).
func (m *OncallUserShiftAnnotationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallUserShiftAnnotationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.shift != nil {
		fields = append(fields, oncallusershiftannotation.FieldShiftID)
	}
	if m.event_id != nil {
		fields = append(fields, oncallusershiftannotation.FieldEventID)
	}
	if m.event_kind != nil {
		fields = append(fields, oncallusershiftannotation.FieldEventKind)
	}
	if m.title != nil {
		fields = append(fields, oncallusershiftannotation.FieldTitle)
	}
	if m.occurred_at != nil {
		fields = append(fields, oncallusershiftannotation.FieldOccurredAt)
	}
	if m.minutes_occupied != nil {
		fields = append(fields, oncallusershiftannotation.FieldMinutesOccupied)
	}
	if m.notes != nil {
		fields = append(fields, oncallusershiftannotation.FieldNotes)
	}
	if m.pinned != nil {
		fields = append(fields, oncallusershiftannotation.FieldPinned)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallUserShiftAnnotationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallusershiftannotation.FieldShiftID:
		return m.ShiftID()
	case oncallusershiftannotation.FieldEventID:
		return m.EventID()
	case oncallusershiftannotation.FieldEventKind:
		return m.EventKind()
	case oncallusershiftannotation.FieldTitle:
		return m.Title()
	case oncallusershiftannotation.FieldOccurredAt:
		return m.OccurredAt()
	case oncallusershiftannotation.FieldMinutesOccupied:
		return m.MinutesOccupied()
	case oncallusershiftannotation.FieldNotes:
		return m.Notes()
	case oncallusershiftannotation.FieldPinned:
		return m.Pinned()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallUserShiftAnnotationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallusershiftannotation.FieldShiftID:
		return m.OldShiftID(ctx)
	case oncallusershiftannotation.FieldEventID:
		return m.OldEventID(ctx)
	case oncallusershiftannotation.FieldEventKind:
		return m.OldEventKind(ctx)
	case oncallusershiftannotation.FieldTitle:
		return m.OldTitle(ctx)
	case oncallusershiftannotation.FieldOccurredAt:
		return m.OldOccurredAt(ctx)
	case oncallusershiftannotation.FieldMinutesOccupied:
		return m.OldMinutesOccupied(ctx)
	case oncallusershiftannotation.FieldNotes:
		return m.OldNotes(ctx)
	case oncallusershiftannotation.FieldPinned:
		return m.OldPinned(ctx)
	}
	return nil, fmt.Errorf("unknown OncallUserShiftAnnotation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallUserShiftAnnotationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallusershiftannotation.FieldShiftID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShiftID(v)
		return nil
	case oncallusershiftannotation.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case oncallusershiftannotation.FieldEventKind:
		v, ok := value.(oncallusershiftannotation.EventKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventKind(v)
		return nil
	case oncallusershiftannotation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case oncallusershiftannotation.FieldOccurredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccurredAt(v)
		return nil
	case oncallusershiftannotation.FieldMinutesOccupied:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinutesOccupied(v)
		return nil
	case oncallusershiftannotation.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case oncallusershiftannotation.FieldPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinned(v)
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftAnnotation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallUserShiftAnnotationMutation) AddedFields() []string {
	var fields []string
	if m.addminutes_occupied != nil {
		fields = append(fields, oncallusershiftannotation.FieldMinutesOccupied)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallUserShiftAnnotationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oncallusershiftannotation.FieldMinutesOccupied:
		return m.AddedMinutesOccupied()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallUserShiftAnnotationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oncallusershiftannotation.FieldMinutesOccupied:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinutesOccupied(v)
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftAnnotation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallUserShiftAnnotationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallUserShiftAnnotationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallUserShiftAnnotationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OncallUserShiftAnnotation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallUserShiftAnnotationMutation) ResetField(name string) error {
	switch name {
	case oncallusershiftannotation.FieldShiftID:
		m.ResetShiftID()
		return nil
	case oncallusershiftannotation.FieldEventID:
		m.ResetEventID()
		return nil
	case oncallusershiftannotation.FieldEventKind:
		m.ResetEventKind()
		return nil
	case oncallusershiftannotation.FieldTitle:
		m.ResetTitle()
		return nil
	case oncallusershiftannotation.FieldOccurredAt:
		m.ResetOccurredAt()
		return nil
	case oncallusershiftannotation.FieldMinutesOccupied:
		m.ResetMinutesOccupied()
		return nil
	case oncallusershiftannotation.FieldNotes:
		m.ResetNotes()
		return nil
	case oncallusershiftannotation.FieldPinned:
		m.ResetPinned()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftAnnotation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallUserShiftAnnotationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.shift != nil {
		edges = append(edges, oncallusershiftannotation.EdgeShift)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallUserShiftAnnotationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallusershiftannotation.EdgeShift:
		if id := m.shift; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallUserShiftAnnotationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallUserShiftAnnotationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallUserShiftAnnotationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedshift {
		edges = append(edges, oncallusershiftannotation.EdgeShift)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallUserShiftAnnotationMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallusershiftannotation.EdgeShift:
		return m.clearedshift
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallUserShiftAnnotationMutation) ClearEdge(name string) error {
	switch name {
	case oncallusershiftannotation.EdgeShift:
		m.ClearShift()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftAnnotation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallUserShiftAnnotationMutation) ResetEdge(name string) error {
	switch name {
	case oncallusershiftannotation.EdgeShift:
		m.ResetShift()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftAnnotation edge %s", name)
}

// OncallUserShiftCoverMutation represents an operation that mutates the OncallUserShiftCover nodes in the graph.
type OncallUserShiftCoverMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	start_at      *time.Time
	end_at        *time.Time
	provider_id   *string
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	shift         *uuid.UUID
	clearedshift  bool
	done          bool
	oldValue      func(context.Context) (*OncallUserShiftCover, error)
	predicates    []predicate.OncallUserShiftCover
}

var _ ent.Mutation = (*OncallUserShiftCoverMutation)(nil)

// oncallusershiftcoverOption allows management of the mutation configuration using functional options.
type oncallusershiftcoverOption func(*OncallUserShiftCoverMutation)

// newOncallUserShiftCoverMutation creates new mutation for the OncallUserShiftCover entity.
func newOncallUserShiftCoverMutation(c config, op Op, opts ...oncallusershiftcoverOption) *OncallUserShiftCoverMutation {
	m := &OncallUserShiftCoverMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallUserShiftCover,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallUserShiftCoverID sets the ID field of the mutation.
func withOncallUserShiftCoverID(id uuid.UUID) oncallusershiftcoverOption {
	return func(m *OncallUserShiftCoverMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallUserShiftCover
		)
		m.oldValue = func(ctx context.Context) (*OncallUserShiftCover, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallUserShiftCover.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallUserShiftCover sets the old OncallUserShiftCover of the mutation.
func withOncallUserShiftCover(node *OncallUserShiftCover) oncallusershiftcoverOption {
	return func(m *OncallUserShiftCoverMutation) {
		m.oldValue = func(context.Context) (*OncallUserShiftCover, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallUserShiftCoverMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallUserShiftCoverMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallUserShiftCover entities.
func (m *OncallUserShiftCoverMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallUserShiftCoverMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallUserShiftCoverMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallUserShiftCover.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *OncallUserShiftCoverMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OncallUserShiftCoverMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OncallUserShiftCover entity.
// If the OncallUserShiftCover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftCoverMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OncallUserShiftCoverMutation) ResetUserID() {
	m.user = nil
}

// SetShiftID sets the "shift_id" field.
func (m *OncallUserShiftCoverMutation) SetShiftID(u uuid.UUID) {
	m.shift = &u
}

// ShiftID returns the value of the "shift_id" field in the mutation.
func (m *OncallUserShiftCoverMutation) ShiftID() (r uuid.UUID, exists bool) {
	v := m.shift
	if v == nil {
		return
	}
	return *v, true
}

// OldShiftID returns the old "shift_id" field's value of the OncallUserShiftCover entity.
// If the OncallUserShiftCover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftCoverMutation) OldShiftID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShiftID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShiftID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShiftID: %w", err)
	}
	return oldValue.ShiftID, nil
}

// ResetShiftID resets all changes to the "shift_id" field.
func (m *OncallUserShiftCoverMutation) ResetShiftID() {
	m.shift = nil
}

// SetStartAt sets the "start_at" field.
func (m *OncallUserShiftCoverMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *OncallUserShiftCoverMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the OncallUserShiftCover entity.
// If the OncallUserShiftCover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftCoverMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *OncallUserShiftCoverMutation) ResetStartAt() {
	m.start_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *OncallUserShiftCoverMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *OncallUserShiftCoverMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the OncallUserShiftCover entity.
// If the OncallUserShiftCover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftCoverMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *OncallUserShiftCoverMutation) ResetEndAt() {
	m.end_at = nil
}

// SetProviderID sets the "provider_id" field.
func (m *OncallUserShiftCoverMutation) SetProviderID(s string) {
	m.provider_id = &s
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *OncallUserShiftCoverMutation) ProviderID() (r string, exists bool) {
	v := m.provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the OncallUserShiftCover entity.
// If the OncallUserShiftCover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftCoverMutation) OldProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ClearProviderID clears the value of the "provider_id" field.
func (m *OncallUserShiftCoverMutation) ClearProviderID() {
	m.provider_id = nil
	m.clearedFields[oncallusershiftcover.FieldProviderID] = struct{}{}
}

// ProviderIDCleared returns if the "provider_id" field was cleared in this mutation.
func (m *OncallUserShiftCoverMutation) ProviderIDCleared() bool {
	_, ok := m.clearedFields[oncallusershiftcover.FieldProviderID]
	return ok
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *OncallUserShiftCoverMutation) ResetProviderID() {
	m.provider_id = nil
	delete(m.clearedFields, oncallusershiftcover.FieldProviderID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *OncallUserShiftCoverMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[oncallusershiftcover.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OncallUserShiftCoverMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OncallUserShiftCoverMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OncallUserShiftCoverMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearShift clears the "shift" edge to the OncallUserShift entity.
func (m *OncallUserShiftCoverMutation) ClearShift() {
	m.clearedshift = true
	m.clearedFields[oncallusershiftcover.FieldShiftID] = struct{}{}
}

// ShiftCleared reports if the "shift" edge to the OncallUserShift entity was cleared.
func (m *OncallUserShiftCoverMutation) ShiftCleared() bool {
	return m.clearedshift
}

// ShiftIDs returns the "shift" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShiftID instead. It exists only for internal usage by the builders.
func (m *OncallUserShiftCoverMutation) ShiftIDs() (ids []uuid.UUID) {
	if id := m.shift; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShift resets all changes to the "shift" edge.
func (m *OncallUserShiftCoverMutation) ResetShift() {
	m.shift = nil
	m.clearedshift = false
}

// Where appends a list predicates to the OncallUserShiftCoverMutation builder.
func (m *OncallUserShiftCoverMutation) Where(ps ...predicate.OncallUserShiftCover) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallUserShiftCoverMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallUserShiftCoverMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallUserShiftCover, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallUserShiftCoverMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallUserShiftCoverMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallUserShiftCover).
func (m *OncallUserShiftCoverMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallUserShiftCoverMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, oncallusershiftcover.FieldUserID)
	}
	if m.shift != nil {
		fields = append(fields, oncallusershiftcover.FieldShiftID)
	}
	if m.start_at != nil {
		fields = append(fields, oncallusershiftcover.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, oncallusershiftcover.FieldEndAt)
	}
	if m.provider_id != nil {
		fields = append(fields, oncallusershiftcover.FieldProviderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallUserShiftCoverMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallusershiftcover.FieldUserID:
		return m.UserID()
	case oncallusershiftcover.FieldShiftID:
		return m.ShiftID()
	case oncallusershiftcover.FieldStartAt:
		return m.StartAt()
	case oncallusershiftcover.FieldEndAt:
		return m.EndAt()
	case oncallusershiftcover.FieldProviderID:
		return m.ProviderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallUserShiftCoverMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallusershiftcover.FieldUserID:
		return m.OldUserID(ctx)
	case oncallusershiftcover.FieldShiftID:
		return m.OldShiftID(ctx)
	case oncallusershiftcover.FieldStartAt:
		return m.OldStartAt(ctx)
	case oncallusershiftcover.FieldEndAt:
		return m.OldEndAt(ctx)
	case oncallusershiftcover.FieldProviderID:
		return m.OldProviderID(ctx)
	}
	return nil, fmt.Errorf("unknown OncallUserShiftCover field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallUserShiftCoverMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallusershiftcover.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oncallusershiftcover.FieldShiftID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShiftID(v)
		return nil
	case oncallusershiftcover.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case oncallusershiftcover.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case oncallusershiftcover.FieldProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftCover field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallUserShiftCoverMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallUserShiftCoverMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallUserShiftCoverMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallUserShiftCover numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallUserShiftCoverMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oncallusershiftcover.FieldProviderID) {
		fields = append(fields, oncallusershiftcover.FieldProviderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallUserShiftCoverMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallUserShiftCoverMutation) ClearField(name string) error {
	switch name {
	case oncallusershiftcover.FieldProviderID:
		m.ClearProviderID()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftCover nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallUserShiftCoverMutation) ResetField(name string) error {
	switch name {
	case oncallusershiftcover.FieldUserID:
		m.ResetUserID()
		return nil
	case oncallusershiftcover.FieldShiftID:
		m.ResetShiftID()
		return nil
	case oncallusershiftcover.FieldStartAt:
		m.ResetStartAt()
		return nil
	case oncallusershiftcover.FieldEndAt:
		m.ResetEndAt()
		return nil
	case oncallusershiftcover.FieldProviderID:
		m.ResetProviderID()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftCover field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallUserShiftCoverMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, oncallusershiftcover.EdgeUser)
	}
	if m.shift != nil {
		edges = append(edges, oncallusershiftcover.EdgeShift)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallUserShiftCoverMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallusershiftcover.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case oncallusershiftcover.EdgeShift:
		if id := m.shift; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallUserShiftCoverMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallUserShiftCoverMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallUserShiftCoverMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, oncallusershiftcover.EdgeUser)
	}
	if m.clearedshift {
		edges = append(edges, oncallusershiftcover.EdgeShift)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallUserShiftCoverMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallusershiftcover.EdgeUser:
		return m.cleareduser
	case oncallusershiftcover.EdgeShift:
		return m.clearedshift
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallUserShiftCoverMutation) ClearEdge(name string) error {
	switch name {
	case oncallusershiftcover.EdgeUser:
		m.ClearUser()
		return nil
	case oncallusershiftcover.EdgeShift:
		m.ClearShift()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftCover unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallUserShiftCoverMutation) ResetEdge(name string) error {
	switch name {
	case oncallusershiftcover.EdgeUser:
		m.ResetUser()
		return nil
	case oncallusershiftcover.EdgeShift:
		m.ResetShift()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftCover edge %s", name)
}

// OncallUserShiftHandoverMutation represents an operation that mutates the OncallUserShiftHandover nodes in the graph.
type OncallUserShiftHandoverMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	reminder_sent *bool
	updated_at    *time.Time
	sent_at       *time.Time
	contents      *[]byte
	clearedFields map[string]struct{}
	shift         *uuid.UUID
	clearedshift  bool
	done          bool
	oldValue      func(context.Context) (*OncallUserShiftHandover, error)
	predicates    []predicate.OncallUserShiftHandover
}

var _ ent.Mutation = (*OncallUserShiftHandoverMutation)(nil)

// oncallusershifthandoverOption allows management of the mutation configuration using functional options.
type oncallusershifthandoverOption func(*OncallUserShiftHandoverMutation)

// newOncallUserShiftHandoverMutation creates new mutation for the OncallUserShiftHandover entity.
func newOncallUserShiftHandoverMutation(c config, op Op, opts ...oncallusershifthandoverOption) *OncallUserShiftHandoverMutation {
	m := &OncallUserShiftHandoverMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallUserShiftHandover,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallUserShiftHandoverID sets the ID field of the mutation.
func withOncallUserShiftHandoverID(id uuid.UUID) oncallusershifthandoverOption {
	return func(m *OncallUserShiftHandoverMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallUserShiftHandover
		)
		m.oldValue = func(ctx context.Context) (*OncallUserShiftHandover, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallUserShiftHandover.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallUserShiftHandover sets the old OncallUserShiftHandover of the mutation.
func withOncallUserShiftHandover(node *OncallUserShiftHandover) oncallusershifthandoverOption {
	return func(m *OncallUserShiftHandoverMutation) {
		m.oldValue = func(context.Context) (*OncallUserShiftHandover, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallUserShiftHandoverMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallUserShiftHandoverMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallUserShiftHandover entities.
func (m *OncallUserShiftHandoverMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallUserShiftHandoverMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallUserShiftHandoverMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallUserShiftHandover.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetShiftID sets the "shift_id" field.
func (m *OncallUserShiftHandoverMutation) SetShiftID(u uuid.UUID) {
	m.shift = &u
}

// ShiftID returns the value of the "shift_id" field in the mutation.
func (m *OncallUserShiftHandoverMutation) ShiftID() (r uuid.UUID, exists bool) {
	v := m.shift
	if v == nil {
		return
	}
	return *v, true
}

// OldShiftID returns the old "shift_id" field's value of the OncallUserShiftHandover entity.
// If the OncallUserShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftHandoverMutation) OldShiftID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShiftID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShiftID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShiftID: %w", err)
	}
	return oldValue.ShiftID, nil
}

// ResetShiftID resets all changes to the "shift_id" field.
func (m *OncallUserShiftHandoverMutation) ResetShiftID() {
	m.shift = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OncallUserShiftHandoverMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OncallUserShiftHandoverMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OncallUserShiftHandover entity.
// If the OncallUserShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftHandoverMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OncallUserShiftHandoverMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetReminderSent sets the "reminder_sent" field.
func (m *OncallUserShiftHandoverMutation) SetReminderSent(b bool) {
	m.reminder_sent = &b
}

// ReminderSent returns the value of the "reminder_sent" field in the mutation.
func (m *OncallUserShiftHandoverMutation) ReminderSent() (r bool, exists bool) {
	v := m.reminder_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldReminderSent returns the old "reminder_sent" field's value of the OncallUserShiftHandover entity.
// If the OncallUserShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftHandoverMutation) OldReminderSent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReminderSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReminderSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReminderSent: %w", err)
	}
	return oldValue.ReminderSent, nil
}

// ResetReminderSent resets all changes to the "reminder_sent" field.
func (m *OncallUserShiftHandoverMutation) ResetReminderSent() {
	m.reminder_sent = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OncallUserShiftHandoverMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OncallUserShiftHandoverMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OncallUserShiftHandover entity.
// If the OncallUserShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftHandoverMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OncallUserShiftHandoverMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSentAt sets the "sent_at" field.
func (m *OncallUserShiftHandoverMutation) SetSentAt(t time.Time) {
	m.sent_at = &t
}

// SentAt returns the value of the "sent_at" field in the mutation.
func (m *OncallUserShiftHandoverMutation) SentAt() (r time.Time, exists bool) {
	v := m.sent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sent_at" field's value of the OncallUserShiftHandover entity.
// If the OncallUserShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftHandoverMutation) OldSentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ClearSentAt clears the value of the "sent_at" field.
func (m *OncallUserShiftHandoverMutation) ClearSentAt() {
	m.sent_at = nil
	m.clearedFields[oncallusershifthandover.FieldSentAt] = struct{}{}
}

// SentAtCleared returns if the "sent_at" field was cleared in this mutation.
func (m *OncallUserShiftHandoverMutation) SentAtCleared() bool {
	_, ok := m.clearedFields[oncallusershifthandover.FieldSentAt]
	return ok
}

// ResetSentAt resets all changes to the "sent_at" field.
func (m *OncallUserShiftHandoverMutation) ResetSentAt() {
	m.sent_at = nil
	delete(m.clearedFields, oncallusershifthandover.FieldSentAt)
}

// SetContents sets the "contents" field.
func (m *OncallUserShiftHandoverMutation) SetContents(b []byte) {
	m.contents = &b
}

// Contents returns the value of the "contents" field in the mutation.
func (m *OncallUserShiftHandoverMutation) Contents() (r []byte, exists bool) {
	v := m.contents
	if v == nil {
		return
	}
	return *v, true
}

// OldContents returns the old "contents" field's value of the OncallUserShiftHandover entity.
// If the OncallUserShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallUserShiftHandoverMutation) OldContents(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContents: %w", err)
	}
	return oldValue.Contents, nil
}

// ResetContents resets all changes to the "contents" field.
func (m *OncallUserShiftHandoverMutation) ResetContents() {
	m.contents = nil
}

// ClearShift clears the "shift" edge to the OncallUserShift entity.
func (m *OncallUserShiftHandoverMutation) ClearShift() {
	m.clearedshift = true
	m.clearedFields[oncallusershifthandover.FieldShiftID] = struct{}{}
}

// ShiftCleared reports if the "shift" edge to the OncallUserShift entity was cleared.
func (m *OncallUserShiftHandoverMutation) ShiftCleared() bool {
	return m.clearedshift
}

// ShiftIDs returns the "shift" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShiftID instead. It exists only for internal usage by the builders.
func (m *OncallUserShiftHandoverMutation) ShiftIDs() (ids []uuid.UUID) {
	if id := m.shift; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShift resets all changes to the "shift" edge.
func (m *OncallUserShiftHandoverMutation) ResetShift() {
	m.shift = nil
	m.clearedshift = false
}

// Where appends a list predicates to the OncallUserShiftHandoverMutation builder.
func (m *OncallUserShiftHandoverMutation) Where(ps ...predicate.OncallUserShiftHandover) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallUserShiftHandoverMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallUserShiftHandoverMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallUserShiftHandover, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallUserShiftHandoverMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallUserShiftHandoverMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallUserShiftHandover).
func (m *OncallUserShiftHandoverMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallUserShiftHandoverMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.shift != nil {
		fields = append(fields, oncallusershifthandover.FieldShiftID)
	}
	if m.created_at != nil {
		fields = append(fields, oncallusershifthandover.FieldCreatedAt)
	}
	if m.reminder_sent != nil {
		fields = append(fields, oncallusershifthandover.FieldReminderSent)
	}
	if m.updated_at != nil {
		fields = append(fields, oncallusershifthandover.FieldUpdatedAt)
	}
	if m.sent_at != nil {
		fields = append(fields, oncallusershifthandover.FieldSentAt)
	}
	if m.contents != nil {
		fields = append(fields, oncallusershifthandover.FieldContents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallUserShiftHandoverMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallusershifthandover.FieldShiftID:
		return m.ShiftID()
	case oncallusershifthandover.FieldCreatedAt:
		return m.CreatedAt()
	case oncallusershifthandover.FieldReminderSent:
		return m.ReminderSent()
	case oncallusershifthandover.FieldUpdatedAt:
		return m.UpdatedAt()
	case oncallusershifthandover.FieldSentAt:
		return m.SentAt()
	case oncallusershifthandover.FieldContents:
		return m.Contents()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallUserShiftHandoverMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallusershifthandover.FieldShiftID:
		return m.OldShiftID(ctx)
	case oncallusershifthandover.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oncallusershifthandover.FieldReminderSent:
		return m.OldReminderSent(ctx)
	case oncallusershifthandover.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oncallusershifthandover.FieldSentAt:
		return m.OldSentAt(ctx)
	case oncallusershifthandover.FieldContents:
		return m.OldContents(ctx)
	}
	return nil, fmt.Errorf("unknown OncallUserShiftHandover field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallUserShiftHandoverMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallusershifthandover.FieldShiftID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShiftID(v)
		return nil
	case oncallusershifthandover.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oncallusershifthandover.FieldReminderSent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReminderSent(v)
		return nil
	case oncallusershifthandover.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oncallusershifthandover.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	case oncallusershifthandover.FieldContents:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContents(v)
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftHandover field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallUserShiftHandoverMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallUserShiftHandoverMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallUserShiftHandoverMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallUserShiftHandover numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallUserShiftHandoverMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oncallusershifthandover.FieldSentAt) {
		fields = append(fields, oncallusershifthandover.FieldSentAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallUserShiftHandoverMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallUserShiftHandoverMutation) ClearField(name string) error {
	switch name {
	case oncallusershifthandover.FieldSentAt:
		m.ClearSentAt()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftHandover nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallUserShiftHandoverMutation) ResetField(name string) error {
	switch name {
	case oncallusershifthandover.FieldShiftID:
		m.ResetShiftID()
		return nil
	case oncallusershifthandover.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oncallusershifthandover.FieldReminderSent:
		m.ResetReminderSent()
		return nil
	case oncallusershifthandover.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oncallusershifthandover.FieldSentAt:
		m.ResetSentAt()
		return nil
	case oncallusershifthandover.FieldContents:
		m.ResetContents()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftHandover field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallUserShiftHandoverMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.shift != nil {
		edges = append(edges, oncallusershifthandover.EdgeShift)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallUserShiftHandoverMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallusershifthandover.EdgeShift:
		if id := m.shift; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallUserShiftHandoverMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallUserShiftHandoverMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallUserShiftHandoverMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedshift {
		edges = append(edges, oncallusershifthandover.EdgeShift)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallUserShiftHandoverMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallusershifthandover.EdgeShift:
		return m.clearedshift
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallUserShiftHandoverMutation) ClearEdge(name string) error {
	switch name {
	case oncallusershifthandover.EdgeShift:
		m.ClearShift()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftHandover unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallUserShiftHandoverMutation) ResetEdge(name string) error {
	switch name {
	case oncallusershifthandover.EdgeShift:
		m.ResetShift()
		return nil
	}
	return fmt.Errorf("unknown OncallUserShiftHandover edge %s", name)
}

// ProviderConfigMutation represents an operation that mutates the ProviderConfig nodes in the graph.
type ProviderConfigMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	provider_type   *providerconfig.ProviderType
	provider_name   *string
	provider_config *[]byte
	enabled         *bool
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ProviderConfig, error)
	predicates      []predicate.ProviderConfig
}

var _ ent.Mutation = (*ProviderConfigMutation)(nil)

// providerconfigOption allows management of the mutation configuration using functional options.
type providerconfigOption func(*ProviderConfigMutation)

// newProviderConfigMutation creates new mutation for the ProviderConfig entity.
func newProviderConfigMutation(c config, op Op, opts ...providerconfigOption) *ProviderConfigMutation {
	m := &ProviderConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeProviderConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderConfigID sets the ID field of the mutation.
func withProviderConfigID(id uuid.UUID) providerconfigOption {
	return func(m *ProviderConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ProviderConfig
		)
		m.oldValue = func(ctx context.Context) (*ProviderConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProviderConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProviderConfig sets the old ProviderConfig of the mutation.
func withProviderConfig(node *ProviderConfig) providerconfigOption {
	return func(m *ProviderConfigMutation) {
		m.oldValue = func(context.Context) (*ProviderConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProviderConfig entities.
func (m *ProviderConfigMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderConfigMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderConfigMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProviderConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProviderType sets the "provider_type" field.
func (m *ProviderConfigMutation) SetProviderType(pt providerconfig.ProviderType) {
	m.provider_type = &pt
}

// ProviderType returns the value of the "provider_type" field in the mutation.
func (m *ProviderConfigMutation) ProviderType() (r providerconfig.ProviderType, exists bool) {
	v := m.provider_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderType returns the old "provider_type" field's value of the ProviderConfig entity.
// If the ProviderConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderConfigMutation) OldProviderType(ctx context.Context) (v providerconfig.ProviderType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderType: %w", err)
	}
	return oldValue.ProviderType, nil
}

// ResetProviderType resets all changes to the "provider_type" field.
func (m *ProviderConfigMutation) ResetProviderType() {
	m.provider_type = nil
}

// SetProviderName sets the "provider_name" field.
func (m *ProviderConfigMutation) SetProviderName(s string) {
	m.provider_name = &s
}

// ProviderName returns the value of the "provider_name" field in the mutation.
func (m *ProviderConfigMutation) ProviderName() (r string, exists bool) {
	v := m.provider_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderName returns the old "provider_name" field's value of the ProviderConfig entity.
// If the ProviderConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderConfigMutation) OldProviderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderName: %w", err)
	}
	return oldValue.ProviderName, nil
}

// ResetProviderName resets all changes to the "provider_name" field.
func (m *ProviderConfigMutation) ResetProviderName() {
	m.provider_name = nil
}

// SetProviderConfig sets the "provider_config" field.
func (m *ProviderConfigMutation) SetProviderConfig(b []byte) {
	m.provider_config = &b
}

// ProviderConfig returns the value of the "provider_config" field in the mutation.
func (m *ProviderConfigMutation) ProviderConfig() (r []byte, exists bool) {
	v := m.provider_config
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderConfig returns the old "provider_config" field's value of the ProviderConfig entity.
// If the ProviderConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderConfigMutation) OldProviderConfig(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderConfig: %w", err)
	}
	return oldValue.ProviderConfig, nil
}

// ResetProviderConfig resets all changes to the "provider_config" field.
func (m *ProviderConfigMutation) ResetProviderConfig() {
	m.provider_config = nil
}

// SetEnabled sets the "enabled" field.
func (m *ProviderConfigMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ProviderConfigMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the ProviderConfig entity.
// If the ProviderConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderConfigMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ProviderConfigMutation) ResetEnabled() {
	m.enabled = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProviderConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProviderConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProviderConfig entity.
// If the ProviderConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProviderConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProviderConfigMutation builder.
func (m *ProviderConfigMutation) Where(ps ...predicate.ProviderConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProviderConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProviderConfig).
func (m *ProviderConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderConfigMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.provider_type != nil {
		fields = append(fields, providerconfig.FieldProviderType)
	}
	if m.provider_name != nil {
		fields = append(fields, providerconfig.FieldProviderName)
	}
	if m.provider_config != nil {
		fields = append(fields, providerconfig.FieldProviderConfig)
	}
	if m.enabled != nil {
		fields = append(fields, providerconfig.FieldEnabled)
	}
	if m.updated_at != nil {
		fields = append(fields, providerconfig.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case providerconfig.FieldProviderType:
		return m.ProviderType()
	case providerconfig.FieldProviderName:
		return m.ProviderName()
	case providerconfig.FieldProviderConfig:
		return m.ProviderConfig()
	case providerconfig.FieldEnabled:
		return m.Enabled()
	case providerconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case providerconfig.FieldProviderType:
		return m.OldProviderType(ctx)
	case providerconfig.FieldProviderName:
		return m.OldProviderName(ctx)
	case providerconfig.FieldProviderConfig:
		return m.OldProviderConfig(ctx)
	case providerconfig.FieldEnabled:
		return m.OldEnabled(ctx)
	case providerconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProviderConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case providerconfig.FieldProviderType:
		v, ok := value.(providerconfig.ProviderType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderType(v)
		return nil
	case providerconfig.FieldProviderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderName(v)
		return nil
	case providerconfig.FieldProviderConfig:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderConfig(v)
		return nil
	case providerconfig.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case providerconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProviderConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProviderConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderConfigMutation) ResetField(name string) error {
	switch name {
	case providerconfig.FieldProviderType:
		m.ResetProviderType()
		return nil
	case providerconfig.FieldProviderName:
		m.ResetProviderName()
		return nil
	case providerconfig.FieldProviderConfig:
		m.ResetProviderConfig()
		return nil
	case providerconfig.FieldEnabled:
		m.ResetEnabled()
		return nil
	case providerconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProviderConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProviderConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProviderConfig edge %s", name)
}

// ProviderSyncHistoryMutation represents an operation that mutates the ProviderSyncHistory nodes in the graph.
type ProviderSyncHistoryMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	data_type        *string
	started_at       *time.Time
	finished_at      *time.Time
	num_mutations    *int
	addnum_mutations *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ProviderSyncHistory, error)
	predicates       []predicate.ProviderSyncHistory
}

var _ ent.Mutation = (*ProviderSyncHistoryMutation)(nil)

// providersynchistoryOption allows management of the mutation configuration using functional options.
type providersynchistoryOption func(*ProviderSyncHistoryMutation)

// newProviderSyncHistoryMutation creates new mutation for the ProviderSyncHistory entity.
func newProviderSyncHistoryMutation(c config, op Op, opts ...providersynchistoryOption) *ProviderSyncHistoryMutation {
	m := &ProviderSyncHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProviderSyncHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderSyncHistoryID sets the ID field of the mutation.
func withProviderSyncHistoryID(id uuid.UUID) providersynchistoryOption {
	return func(m *ProviderSyncHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProviderSyncHistory
		)
		m.oldValue = func(ctx context.Context) (*ProviderSyncHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProviderSyncHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProviderSyncHistory sets the old ProviderSyncHistory of the mutation.
func withProviderSyncHistory(node *ProviderSyncHistory) providersynchistoryOption {
	return func(m *ProviderSyncHistoryMutation) {
		m.oldValue = func(context.Context) (*ProviderSyncHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderSyncHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderSyncHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProviderSyncHistory entities.
func (m *ProviderSyncHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderSyncHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderSyncHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProviderSyncHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDataType sets the "data_type" field.
func (m *ProviderSyncHistoryMutation) SetDataType(s string) {
	m.data_type = &s
}

// DataType returns the value of the "data_type" field in the mutation.
func (m *ProviderSyncHistoryMutation) DataType() (r string, exists bool) {
	v := m.data_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDataType returns the old "data_type" field's value of the ProviderSyncHistory entity.
// If the ProviderSyncHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderSyncHistoryMutation) OldDataType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataType: %w", err)
	}
	return oldValue.DataType, nil
}

// ResetDataType resets all changes to the "data_type" field.
func (m *ProviderSyncHistoryMutation) ResetDataType() {
	m.data_type = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ProviderSyncHistoryMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ProviderSyncHistoryMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ProviderSyncHistory entity.
// If the ProviderSyncHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderSyncHistoryMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ProviderSyncHistoryMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *ProviderSyncHistoryMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *ProviderSyncHistoryMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the ProviderSyncHistory entity.
// If the ProviderSyncHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderSyncHistoryMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *ProviderSyncHistoryMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetNumMutations sets the "num_mutations" field.
func (m *ProviderSyncHistoryMutation) SetNumMutations(i int) {
	m.num_mutations = &i
	m.addnum_mutations = nil
}

// NumMutations returns the value of the "num_mutations" field in the mutation.
func (m *ProviderSyncHistoryMutation) NumMutations() (r int, exists bool) {
	v := m.num_mutations
	if v == nil {
		return
	}
	return *v, true
}

// OldNumMutations returns the old "num_mutations" field's value of the ProviderSyncHistory entity.
// If the ProviderSyncHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderSyncHistoryMutation) OldNumMutations(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumMutations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumMutations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumMutations: %w", err)
	}
	return oldValue.NumMutations, nil
}

// AddNumMutations adds i to the "num_mutations" field.
func (m *ProviderSyncHistoryMutation) AddNumMutations(i int) {
	if m.addnum_mutations != nil {
		*m.addnum_mutations += i
	} else {
		m.addnum_mutations = &i
	}
}

// AddedNumMutations returns the value that was added to the "num_mutations" field in this mutation.
func (m *ProviderSyncHistoryMutation) AddedNumMutations() (r int, exists bool) {
	v := m.addnum_mutations
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumMutations resets all changes to the "num_mutations" field.
func (m *ProviderSyncHistoryMutation) ResetNumMutations() {
	m.num_mutations = nil
	m.addnum_mutations = nil
}

// Where appends a list predicates to the ProviderSyncHistoryMutation builder.
func (m *ProviderSyncHistoryMutation) Where(ps ...predicate.ProviderSyncHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderSyncHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderSyncHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProviderSyncHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderSyncHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderSyncHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProviderSyncHistory).
func (m *ProviderSyncHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderSyncHistoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.data_type != nil {
		fields = append(fields, providersynchistory.FieldDataType)
	}
	if m.started_at != nil {
		fields = append(fields, providersynchistory.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, providersynchistory.FieldFinishedAt)
	}
	if m.num_mutations != nil {
		fields = append(fields, providersynchistory.FieldNumMutations)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderSyncHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case providersynchistory.FieldDataType:
		return m.DataType()
	case providersynchistory.FieldStartedAt:
		return m.StartedAt()
	case providersynchistory.FieldFinishedAt:
		return m.FinishedAt()
	case providersynchistory.FieldNumMutations:
		return m.NumMutations()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderSyncHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case providersynchistory.FieldDataType:
		return m.OldDataType(ctx)
	case providersynchistory.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case providersynchistory.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case providersynchistory.FieldNumMutations:
		return m.OldNumMutations(ctx)
	}
	return nil, fmt.Errorf("unknown ProviderSyncHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderSyncHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case providersynchistory.FieldDataType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataType(v)
		return nil
	case providersynchistory.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case providersynchistory.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case providersynchistory.FieldNumMutations:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumMutations(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderSyncHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderSyncHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addnum_mutations != nil {
		fields = append(fields, providersynchistory.FieldNumMutations)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderSyncHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case providersynchistory.FieldNumMutations:
		return m.AddedNumMutations()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderSyncHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case providersynchistory.FieldNumMutations:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumMutations(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderSyncHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderSyncHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderSyncHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderSyncHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProviderSyncHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderSyncHistoryMutation) ResetField(name string) error {
	switch name {
	case providersynchistory.FieldDataType:
		m.ResetDataType()
		return nil
	case providersynchistory.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case providersynchistory.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case providersynchistory.FieldNumMutations:
		m.ResetNumMutations()
		return nil
	}
	return fmt.Errorf("unknown ProviderSyncHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderSyncHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderSyncHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderSyncHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderSyncHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderSyncHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderSyncHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderSyncHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProviderSyncHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderSyncHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProviderSyncHistory edge %s", name)
}

// RetrospectiveMutation represents an operation that mutates the Retrospective nodes in the graph.
type RetrospectiveMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	document_name      *string
	state              *retrospective.State
	clearedFields      map[string]struct{}
	incident           *uuid.UUID
	clearedincident    bool
	discussions        map[uuid.UUID]struct{}
	removeddiscussions map[uuid.UUID]struct{}
	cleareddiscussions bool
	done               bool
	oldValue           func(context.Context) (*Retrospective, error)
	predicates         []predicate.Retrospective
}

var _ ent.Mutation = (*RetrospectiveMutation)(nil)

// retrospectiveOption allows management of the mutation configuration using functional options.
type retrospectiveOption func(*RetrospectiveMutation)

// newRetrospectiveMutation creates new mutation for the Retrospective entity.
func newRetrospectiveMutation(c config, op Op, opts ...retrospectiveOption) *RetrospectiveMutation {
	m := &RetrospectiveMutation{
		config:        c,
		op:            op,
		typ:           TypeRetrospective,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRetrospectiveID sets the ID field of the mutation.
func withRetrospectiveID(id uuid.UUID) retrospectiveOption {
	return func(m *RetrospectiveMutation) {
		var (
			err   error
			once  sync.Once
			value *Retrospective
		)
		m.oldValue = func(ctx context.Context) (*Retrospective, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Retrospective.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRetrospective sets the old Retrospective of the mutation.
func withRetrospective(node *Retrospective) retrospectiveOption {
	return func(m *RetrospectiveMutation) {
		m.oldValue = func(context.Context) (*Retrospective, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RetrospectiveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RetrospectiveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Retrospective entities.
func (m *RetrospectiveMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RetrospectiveMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RetrospectiveMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Retrospective.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDocumentName sets the "document_name" field.
func (m *RetrospectiveMutation) SetDocumentName(s string) {
	m.document_name = &s
}

// DocumentName returns the value of the "document_name" field in the mutation.
func (m *RetrospectiveMutation) DocumentName() (r string, exists bool) {
	v := m.document_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentName returns the old "document_name" field's value of the Retrospective entity.
// If the Retrospective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveMutation) OldDocumentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentName: %w", err)
	}
	return oldValue.DocumentName, nil
}

// ResetDocumentName resets all changes to the "document_name" field.
func (m *RetrospectiveMutation) ResetDocumentName() {
	m.document_name = nil
}

// SetState sets the "state" field.
func (m *RetrospectiveMutation) SetState(r retrospective.State) {
	m.state = &r
}

// State returns the value of the "state" field in the mutation.
func (m *RetrospectiveMutation) State() (r retrospective.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Retrospective entity.
// If the Retrospective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveMutation) OldState(ctx context.Context) (v retrospective.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *RetrospectiveMutation) ResetState() {
	m.state = nil
}

// SetIncidentID sets the "incident" edge to the Incident entity by id.
func (m *RetrospectiveMutation) SetIncidentID(id uuid.UUID) {
	m.incident = &id
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *RetrospectiveMutation) ClearIncident() {
	m.clearedincident = true
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *RetrospectiveMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentID returns the "incident" edge ID in the mutation.
func (m *RetrospectiveMutation) IncidentID() (id uuid.UUID, exists bool) {
	if m.incident != nil {
		return *m.incident, true
	}
	return
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *RetrospectiveMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// AddDiscussionIDs adds the "discussions" edge to the RetrospectiveDiscussion entity by ids.
func (m *RetrospectiveMutation) AddDiscussionIDs(ids ...uuid.UUID) {
	if m.discussions == nil {
		m.discussions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.discussions[ids[i]] = struct{}{}
	}
}

// ClearDiscussions clears the "discussions" edge to the RetrospectiveDiscussion entity.
func (m *RetrospectiveMutation) ClearDiscussions() {
	m.cleareddiscussions = true
}

// DiscussionsCleared reports if the "discussions" edge to the RetrospectiveDiscussion entity was cleared.
func (m *RetrospectiveMutation) DiscussionsCleared() bool {
	return m.cleareddiscussions
}

// RemoveDiscussionIDs removes the "discussions" edge to the RetrospectiveDiscussion entity by IDs.
func (m *RetrospectiveMutation) RemoveDiscussionIDs(ids ...uuid.UUID) {
	if m.removeddiscussions == nil {
		m.removeddiscussions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.discussions, ids[i])
		m.removeddiscussions[ids[i]] = struct{}{}
	}
}

// RemovedDiscussions returns the removed IDs of the "discussions" edge to the RetrospectiveDiscussion entity.
func (m *RetrospectiveMutation) RemovedDiscussionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddiscussions {
		ids = append(ids, id)
	}
	return
}

// DiscussionsIDs returns the "discussions" edge IDs in the mutation.
func (m *RetrospectiveMutation) DiscussionsIDs() (ids []uuid.UUID) {
	for id := range m.discussions {
		ids = append(ids, id)
	}
	return
}

// ResetDiscussions resets all changes to the "discussions" edge.
func (m *RetrospectiveMutation) ResetDiscussions() {
	m.discussions = nil
	m.cleareddiscussions = false
	m.removeddiscussions = nil
}

// Where appends a list predicates to the RetrospectiveMutation builder.
func (m *RetrospectiveMutation) Where(ps ...predicate.Retrospective) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RetrospectiveMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RetrospectiveMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Retrospective, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RetrospectiveMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RetrospectiveMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Retrospective).
func (m *RetrospectiveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RetrospectiveMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.document_name != nil {
		fields = append(fields, retrospective.FieldDocumentName)
	}
	if m.state != nil {
		fields = append(fields, retrospective.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RetrospectiveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case retrospective.FieldDocumentName:
		return m.DocumentName()
	case retrospective.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RetrospectiveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case retrospective.FieldDocumentName:
		return m.OldDocumentName(ctx)
	case retrospective.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown Retrospective field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case retrospective.FieldDocumentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentName(v)
		return nil
	case retrospective.FieldState:
		v, ok := value.(retrospective.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown Retrospective field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RetrospectiveMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RetrospectiveMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Retrospective numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RetrospectiveMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RetrospectiveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RetrospectiveMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Retrospective nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RetrospectiveMutation) ResetField(name string) error {
	switch name {
	case retrospective.FieldDocumentName:
		m.ResetDocumentName()
		return nil
	case retrospective.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Retrospective field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RetrospectiveMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.incident != nil {
		edges = append(edges, retrospective.EdgeIncident)
	}
	if m.discussions != nil {
		edges = append(edges, retrospective.EdgeDiscussions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RetrospectiveMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case retrospective.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case retrospective.EdgeDiscussions:
		ids := make([]ent.Value, 0, len(m.discussions))
		for id := range m.discussions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RetrospectiveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddiscussions != nil {
		edges = append(edges, retrospective.EdgeDiscussions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RetrospectiveMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case retrospective.EdgeDiscussions:
		ids := make([]ent.Value, 0, len(m.removeddiscussions))
		for id := range m.removeddiscussions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RetrospectiveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedincident {
		edges = append(edges, retrospective.EdgeIncident)
	}
	if m.cleareddiscussions {
		edges = append(edges, retrospective.EdgeDiscussions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RetrospectiveMutation) EdgeCleared(name string) bool {
	switch name {
	case retrospective.EdgeIncident:
		return m.clearedincident
	case retrospective.EdgeDiscussions:
		return m.cleareddiscussions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RetrospectiveMutation) ClearEdge(name string) error {
	switch name {
	case retrospective.EdgeIncident:
		m.ClearIncident()
		return nil
	}
	return fmt.Errorf("unknown Retrospective unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RetrospectiveMutation) ResetEdge(name string) error {
	switch name {
	case retrospective.EdgeIncident:
		m.ResetIncident()
		return nil
	case retrospective.EdgeDiscussions:
		m.ResetDiscussions()
		return nil
	}
	return fmt.Errorf("unknown Retrospective edge %s", name)
}

// RetrospectiveDiscussionMutation represents an operation that mutates the RetrospectiveDiscussion nodes in the graph.
type RetrospectiveDiscussionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	content              *[]byte
	clearedFields        map[string]struct{}
	retrospective        *uuid.UUID
	clearedretrospective bool
	replies              map[uuid.UUID]struct{}
	removedreplies       map[uuid.UUID]struct{}
	clearedreplies       bool
	review               map[uuid.UUID]struct{}
	removedreview        map[uuid.UUID]struct{}
	clearedreview        bool
	done                 bool
	oldValue             func(context.Context) (*RetrospectiveDiscussion, error)
	predicates           []predicate.RetrospectiveDiscussion
}

var _ ent.Mutation = (*RetrospectiveDiscussionMutation)(nil)

// retrospectivediscussionOption allows management of the mutation configuration using functional options.
type retrospectivediscussionOption func(*RetrospectiveDiscussionMutation)

// newRetrospectiveDiscussionMutation creates new mutation for the RetrospectiveDiscussion entity.
func newRetrospectiveDiscussionMutation(c config, op Op, opts ...retrospectivediscussionOption) *RetrospectiveDiscussionMutation {
	m := &RetrospectiveDiscussionMutation{
		config:        c,
		op:            op,
		typ:           TypeRetrospectiveDiscussion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRetrospectiveDiscussionID sets the ID field of the mutation.
func withRetrospectiveDiscussionID(id uuid.UUID) retrospectivediscussionOption {
	return func(m *RetrospectiveDiscussionMutation) {
		var (
			err   error
			once  sync.Once
			value *RetrospectiveDiscussion
		)
		m.oldValue = func(ctx context.Context) (*RetrospectiveDiscussion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RetrospectiveDiscussion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRetrospectiveDiscussion sets the old RetrospectiveDiscussion of the mutation.
func withRetrospectiveDiscussion(node *RetrospectiveDiscussion) retrospectivediscussionOption {
	return func(m *RetrospectiveDiscussionMutation) {
		m.oldValue = func(context.Context) (*RetrospectiveDiscussion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RetrospectiveDiscussionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RetrospectiveDiscussionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RetrospectiveDiscussion entities.
func (m *RetrospectiveDiscussionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RetrospectiveDiscussionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RetrospectiveDiscussionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RetrospectiveDiscussion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRetrospectiveID sets the "retrospective_id" field.
func (m *RetrospectiveDiscussionMutation) SetRetrospectiveID(u uuid.UUID) {
	m.retrospective = &u
}

// RetrospectiveID returns the value of the "retrospective_id" field in the mutation.
func (m *RetrospectiveDiscussionMutation) RetrospectiveID() (r uuid.UUID, exists bool) {
	v := m.retrospective
	if v == nil {
		return
	}
	return *v, true
}

// OldRetrospectiveID returns the old "retrospective_id" field's value of the RetrospectiveDiscussion entity.
// If the RetrospectiveDiscussion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveDiscussionMutation) OldRetrospectiveID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetrospectiveID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetrospectiveID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetrospectiveID: %w", err)
	}
	return oldValue.RetrospectiveID, nil
}

// ResetRetrospectiveID resets all changes to the "retrospective_id" field.
func (m *RetrospectiveDiscussionMutation) ResetRetrospectiveID() {
	m.retrospective = nil
}

// SetContent sets the "content" field.
func (m *RetrospectiveDiscussionMutation) SetContent(b []byte) {
	m.content = &b
}

// Content returns the value of the "content" field in the mutation.
func (m *RetrospectiveDiscussionMutation) Content() (r []byte, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the RetrospectiveDiscussion entity.
// If the RetrospectiveDiscussion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveDiscussionMutation) OldContent(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *RetrospectiveDiscussionMutation) ResetContent() {
	m.content = nil
}

// ClearRetrospective clears the "retrospective" edge to the Retrospective entity.
func (m *RetrospectiveDiscussionMutation) ClearRetrospective() {
	m.clearedretrospective = true
	m.clearedFields[retrospectivediscussion.FieldRetrospectiveID] = struct{}{}
}

// RetrospectiveCleared reports if the "retrospective" edge to the Retrospective entity was cleared.
func (m *RetrospectiveDiscussionMutation) RetrospectiveCleared() bool {
	return m.clearedretrospective
}

// RetrospectiveIDs returns the "retrospective" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RetrospectiveID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveDiscussionMutation) RetrospectiveIDs() (ids []uuid.UUID) {
	if id := m.retrospective; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRetrospective resets all changes to the "retrospective" edge.
func (m *RetrospectiveDiscussionMutation) ResetRetrospective() {
	m.retrospective = nil
	m.clearedretrospective = false
}

// AddReplyIDs adds the "replies" edge to the RetrospectiveDiscussionReply entity by ids.
func (m *RetrospectiveDiscussionMutation) AddReplyIDs(ids ...uuid.UUID) {
	if m.replies == nil {
		m.replies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the RetrospectiveDiscussionReply entity.
func (m *RetrospectiveDiscussionMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the RetrospectiveDiscussionReply entity was cleared.
func (m *RetrospectiveDiscussionMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the RetrospectiveDiscussionReply entity by IDs.
func (m *RetrospectiveDiscussionMutation) RemoveReplyIDs(ids ...uuid.UUID) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the RetrospectiveDiscussionReply entity.
func (m *RetrospectiveDiscussionMutation) RemovedRepliesIDs() (ids []uuid.UUID) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *RetrospectiveDiscussionMutation) RepliesIDs() (ids []uuid.UUID) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *RetrospectiveDiscussionMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// AddReviewIDs adds the "review" edge to the RetrospectiveReview entity by ids.
func (m *RetrospectiveDiscussionMutation) AddReviewIDs(ids ...uuid.UUID) {
	if m.review == nil {
		m.review = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.review[ids[i]] = struct{}{}
	}
}

// ClearReview clears the "review" edge to the RetrospectiveReview entity.
func (m *RetrospectiveDiscussionMutation) ClearReview() {
	m.clearedreview = true
}

// ReviewCleared reports if the "review" edge to the RetrospectiveReview entity was cleared.
func (m *RetrospectiveDiscussionMutation) ReviewCleared() bool {
	return m.clearedreview
}

// RemoveReviewIDs removes the "review" edge to the RetrospectiveReview entity by IDs.
func (m *RetrospectiveDiscussionMutation) RemoveReviewIDs(ids ...uuid.UUID) {
	if m.removedreview == nil {
		m.removedreview = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.review, ids[i])
		m.removedreview[ids[i]] = struct{}{}
	}
}

// RemovedReview returns the removed IDs of the "review" edge to the RetrospectiveReview entity.
func (m *RetrospectiveDiscussionMutation) RemovedReviewIDs() (ids []uuid.UUID) {
	for id := range m.removedreview {
		ids = append(ids, id)
	}
	return
}

// ReviewIDs returns the "review" edge IDs in the mutation.
func (m *RetrospectiveDiscussionMutation) ReviewIDs() (ids []uuid.UUID) {
	for id := range m.review {
		ids = append(ids, id)
	}
	return
}

// ResetReview resets all changes to the "review" edge.
func (m *RetrospectiveDiscussionMutation) ResetReview() {
	m.review = nil
	m.clearedreview = false
	m.removedreview = nil
}

// Where appends a list predicates to the RetrospectiveDiscussionMutation builder.
func (m *RetrospectiveDiscussionMutation) Where(ps ...predicate.RetrospectiveDiscussion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RetrospectiveDiscussionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RetrospectiveDiscussionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RetrospectiveDiscussion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RetrospectiveDiscussionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RetrospectiveDiscussionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RetrospectiveDiscussion).
func (m *RetrospectiveDiscussionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RetrospectiveDiscussionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.retrospective != nil {
		fields = append(fields, retrospectivediscussion.FieldRetrospectiveID)
	}
	if m.content != nil {
		fields = append(fields, retrospectivediscussion.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RetrospectiveDiscussionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case retrospectivediscussion.FieldRetrospectiveID:
		return m.RetrospectiveID()
	case retrospectivediscussion.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RetrospectiveDiscussionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case retrospectivediscussion.FieldRetrospectiveID:
		return m.OldRetrospectiveID(ctx)
	case retrospectivediscussion.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown RetrospectiveDiscussion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveDiscussionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case retrospectivediscussion.FieldRetrospectiveID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetrospectiveID(v)
		return nil
	case retrospectivediscussion.FieldContent:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveDiscussion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RetrospectiveDiscussionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RetrospectiveDiscussionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveDiscussionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RetrospectiveDiscussion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RetrospectiveDiscussionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RetrospectiveDiscussionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RetrospectiveDiscussionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RetrospectiveDiscussion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RetrospectiveDiscussionMutation) ResetField(name string) error {
	switch name {
	case retrospectivediscussion.FieldRetrospectiveID:
		m.ResetRetrospectiveID()
		return nil
	case retrospectivediscussion.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveDiscussion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RetrospectiveDiscussionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.retrospective != nil {
		edges = append(edges, retrospectivediscussion.EdgeRetrospective)
	}
	if m.replies != nil {
		edges = append(edges, retrospectivediscussion.EdgeReplies)
	}
	if m.review != nil {
		edges = append(edges, retrospectivediscussion.EdgeReview)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RetrospectiveDiscussionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case retrospectivediscussion.EdgeRetrospective:
		if id := m.retrospective; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivediscussion.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	case retrospectivediscussion.EdgeReview:
		ids := make([]ent.Value, 0, len(m.review))
		for id := range m.review {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RetrospectiveDiscussionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreplies != nil {
		edges = append(edges, retrospectivediscussion.EdgeReplies)
	}
	if m.removedreview != nil {
		edges = append(edges, retrospectivediscussion.EdgeReview)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RetrospectiveDiscussionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case retrospectivediscussion.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	case retrospectivediscussion.EdgeReview:
		ids := make([]ent.Value, 0, len(m.removedreview))
		for id := range m.removedreview {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RetrospectiveDiscussionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedretrospective {
		edges = append(edges, retrospectivediscussion.EdgeRetrospective)
	}
	if m.clearedreplies {
		edges = append(edges, retrospectivediscussion.EdgeReplies)
	}
	if m.clearedreview {
		edges = append(edges, retrospectivediscussion.EdgeReview)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RetrospectiveDiscussionMutation) EdgeCleared(name string) bool {
	switch name {
	case retrospectivediscussion.EdgeRetrospective:
		return m.clearedretrospective
	case retrospectivediscussion.EdgeReplies:
		return m.clearedreplies
	case retrospectivediscussion.EdgeReview:
		return m.clearedreview
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RetrospectiveDiscussionMutation) ClearEdge(name string) error {
	switch name {
	case retrospectivediscussion.EdgeRetrospective:
		m.ClearRetrospective()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveDiscussion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RetrospectiveDiscussionMutation) ResetEdge(name string) error {
	switch name {
	case retrospectivediscussion.EdgeRetrospective:
		m.ResetRetrospective()
		return nil
	case retrospectivediscussion.EdgeReplies:
		m.ResetReplies()
		return nil
	case retrospectivediscussion.EdgeReview:
		m.ResetReview()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveDiscussion edge %s", name)
}

// RetrospectiveDiscussionReplyMutation represents an operation that mutates the RetrospectiveDiscussionReply nodes in the graph.
type RetrospectiveDiscussionReplyMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	content             *[]byte
	clearedFields       map[string]struct{}
	discussion          *uuid.UUID
	cleareddiscussion   bool
	parent_reply        *uuid.UUID
	clearedparent_reply bool
	replies             map[uuid.UUID]struct{}
	removedreplies      map[uuid.UUID]struct{}
	clearedreplies      bool
	done                bool
	oldValue            func(context.Context) (*RetrospectiveDiscussionReply, error)
	predicates          []predicate.RetrospectiveDiscussionReply
}

var _ ent.Mutation = (*RetrospectiveDiscussionReplyMutation)(nil)

// retrospectivediscussionreplyOption allows management of the mutation configuration using functional options.
type retrospectivediscussionreplyOption func(*RetrospectiveDiscussionReplyMutation)

// newRetrospectiveDiscussionReplyMutation creates new mutation for the RetrospectiveDiscussionReply entity.
func newRetrospectiveDiscussionReplyMutation(c config, op Op, opts ...retrospectivediscussionreplyOption) *RetrospectiveDiscussionReplyMutation {
	m := &RetrospectiveDiscussionReplyMutation{
		config:        c,
		op:            op,
		typ:           TypeRetrospectiveDiscussionReply,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRetrospectiveDiscussionReplyID sets the ID field of the mutation.
func withRetrospectiveDiscussionReplyID(id uuid.UUID) retrospectivediscussionreplyOption {
	return func(m *RetrospectiveDiscussionReplyMutation) {
		var (
			err   error
			once  sync.Once
			value *RetrospectiveDiscussionReply
		)
		m.oldValue = func(ctx context.Context) (*RetrospectiveDiscussionReply, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RetrospectiveDiscussionReply.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRetrospectiveDiscussionReply sets the old RetrospectiveDiscussionReply of the mutation.
func withRetrospectiveDiscussionReply(node *RetrospectiveDiscussionReply) retrospectivediscussionreplyOption {
	return func(m *RetrospectiveDiscussionReplyMutation) {
		m.oldValue = func(context.Context) (*RetrospectiveDiscussionReply, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RetrospectiveDiscussionReplyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RetrospectiveDiscussionReplyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RetrospectiveDiscussionReply entities.
func (m *RetrospectiveDiscussionReplyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RetrospectiveDiscussionReplyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RetrospectiveDiscussionReplyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RetrospectiveDiscussionReply.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *RetrospectiveDiscussionReplyMutation) SetContent(b []byte) {
	m.content = &b
}

// Content returns the value of the "content" field in the mutation.
func (m *RetrospectiveDiscussionReplyMutation) Content() (r []byte, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the RetrospectiveDiscussionReply entity.
// If the RetrospectiveDiscussionReply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveDiscussionReplyMutation) OldContent(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *RetrospectiveDiscussionReplyMutation) ResetContent() {
	m.content = nil
}

// SetDiscussionID sets the "discussion" edge to the RetrospectiveDiscussion entity by id.
func (m *RetrospectiveDiscussionReplyMutation) SetDiscussionID(id uuid.UUID) {
	m.discussion = &id
}

// ClearDiscussion clears the "discussion" edge to the RetrospectiveDiscussion entity.
func (m *RetrospectiveDiscussionReplyMutation) ClearDiscussion() {
	m.cleareddiscussion = true
}

// DiscussionCleared reports if the "discussion" edge to the RetrospectiveDiscussion entity was cleared.
func (m *RetrospectiveDiscussionReplyMutation) DiscussionCleared() bool {
	return m.cleareddiscussion
}

// DiscussionID returns the "discussion" edge ID in the mutation.
func (m *RetrospectiveDiscussionReplyMutation) DiscussionID() (id uuid.UUID, exists bool) {
	if m.discussion != nil {
		return *m.discussion, true
	}
	return
}

// DiscussionIDs returns the "discussion" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DiscussionID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveDiscussionReplyMutation) DiscussionIDs() (ids []uuid.UUID) {
	if id := m.discussion; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDiscussion resets all changes to the "discussion" edge.
func (m *RetrospectiveDiscussionReplyMutation) ResetDiscussion() {
	m.discussion = nil
	m.cleareddiscussion = false
}

// SetParentReplyID sets the "parent_reply" edge to the RetrospectiveDiscussionReply entity by id.
func (m *RetrospectiveDiscussionReplyMutation) SetParentReplyID(id uuid.UUID) {
	m.parent_reply = &id
}

// ClearParentReply clears the "parent_reply" edge to the RetrospectiveDiscussionReply entity.
func (m *RetrospectiveDiscussionReplyMutation) ClearParentReply() {
	m.clearedparent_reply = true
}

// ParentReplyCleared reports if the "parent_reply" edge to the RetrospectiveDiscussionReply entity was cleared.
func (m *RetrospectiveDiscussionReplyMutation) ParentReplyCleared() bool {
	return m.clearedparent_reply
}

// ParentReplyID returns the "parent_reply" edge ID in the mutation.
func (m *RetrospectiveDiscussionReplyMutation) ParentReplyID() (id uuid.UUID, exists bool) {
	if m.parent_reply != nil {
		return *m.parent_reply, true
	}
	return
}

// ParentReplyIDs returns the "parent_reply" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentReplyID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveDiscussionReplyMutation) ParentReplyIDs() (ids []uuid.UUID) {
	if id := m.parent_reply; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentReply resets all changes to the "parent_reply" edge.
func (m *RetrospectiveDiscussionReplyMutation) ResetParentReply() {
	m.parent_reply = nil
	m.clearedparent_reply = false
}

// AddReplyIDs adds the "replies" edge to the RetrospectiveDiscussionReply entity by ids.
func (m *RetrospectiveDiscussionReplyMutation) AddReplyIDs(ids ...uuid.UUID) {
	if m.replies == nil {
		m.replies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the RetrospectiveDiscussionReply entity.
func (m *RetrospectiveDiscussionReplyMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the RetrospectiveDiscussionReply entity was cleared.
func (m *RetrospectiveDiscussionReplyMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the RetrospectiveDiscussionReply entity by IDs.
func (m *RetrospectiveDiscussionReplyMutation) RemoveReplyIDs(ids ...uuid.UUID) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the RetrospectiveDiscussionReply entity.
func (m *RetrospectiveDiscussionReplyMutation) RemovedRepliesIDs() (ids []uuid.UUID) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *RetrospectiveDiscussionReplyMutation) RepliesIDs() (ids []uuid.UUID) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *RetrospectiveDiscussionReplyMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// Where appends a list predicates to the RetrospectiveDiscussionReplyMutation builder.
func (m *RetrospectiveDiscussionReplyMutation) Where(ps ...predicate.RetrospectiveDiscussionReply) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RetrospectiveDiscussionReplyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RetrospectiveDiscussionReplyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RetrospectiveDiscussionReply, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RetrospectiveDiscussionReplyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RetrospectiveDiscussionReplyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RetrospectiveDiscussionReply).
func (m *RetrospectiveDiscussionReplyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RetrospectiveDiscussionReplyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.content != nil {
		fields = append(fields, retrospectivediscussionreply.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RetrospectiveDiscussionReplyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case retrospectivediscussionreply.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RetrospectiveDiscussionReplyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case retrospectivediscussionreply.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown RetrospectiveDiscussionReply field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveDiscussionReplyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case retrospectivediscussionreply.FieldContent:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveDiscussionReply field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RetrospectiveDiscussionReplyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RetrospectiveDiscussionReplyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveDiscussionReplyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RetrospectiveDiscussionReply numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RetrospectiveDiscussionReplyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RetrospectiveDiscussionReplyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RetrospectiveDiscussionReplyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RetrospectiveDiscussionReply nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RetrospectiveDiscussionReplyMutation) ResetField(name string) error {
	switch name {
	case retrospectivediscussionreply.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveDiscussionReply field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RetrospectiveDiscussionReplyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.discussion != nil {
		edges = append(edges, retrospectivediscussionreply.EdgeDiscussion)
	}
	if m.parent_reply != nil {
		edges = append(edges, retrospectivediscussionreply.EdgeParentReply)
	}
	if m.replies != nil {
		edges = append(edges, retrospectivediscussionreply.EdgeReplies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RetrospectiveDiscussionReplyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case retrospectivediscussionreply.EdgeDiscussion:
		if id := m.discussion; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivediscussionreply.EdgeParentReply:
		if id := m.parent_reply; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivediscussionreply.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RetrospectiveDiscussionReplyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreplies != nil {
		edges = append(edges, retrospectivediscussionreply.EdgeReplies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RetrospectiveDiscussionReplyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case retrospectivediscussionreply.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RetrospectiveDiscussionReplyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddiscussion {
		edges = append(edges, retrospectivediscussionreply.EdgeDiscussion)
	}
	if m.clearedparent_reply {
		edges = append(edges, retrospectivediscussionreply.EdgeParentReply)
	}
	if m.clearedreplies {
		edges = append(edges, retrospectivediscussionreply.EdgeReplies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RetrospectiveDiscussionReplyMutation) EdgeCleared(name string) bool {
	switch name {
	case retrospectivediscussionreply.EdgeDiscussion:
		return m.cleareddiscussion
	case retrospectivediscussionreply.EdgeParentReply:
		return m.clearedparent_reply
	case retrospectivediscussionreply.EdgeReplies:
		return m.clearedreplies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RetrospectiveDiscussionReplyMutation) ClearEdge(name string) error {
	switch name {
	case retrospectivediscussionreply.EdgeDiscussion:
		m.ClearDiscussion()
		return nil
	case retrospectivediscussionreply.EdgeParentReply:
		m.ClearParentReply()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveDiscussionReply unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RetrospectiveDiscussionReplyMutation) ResetEdge(name string) error {
	switch name {
	case retrospectivediscussionreply.EdgeDiscussion:
		m.ResetDiscussion()
		return nil
	case retrospectivediscussionreply.EdgeParentReply:
		m.ResetParentReply()
		return nil
	case retrospectivediscussionreply.EdgeReplies:
		m.ResetReplies()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveDiscussionReply edge %s", name)
}

// RetrospectiveReviewMutation represents an operation that mutates the RetrospectiveReview nodes in the graph.
type RetrospectiveReviewMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	state                *retrospectivereview.State
	clearedFields        map[string]struct{}
	retrospective        *uuid.UUID
	clearedretrospective bool
	requester            *uuid.UUID
	clearedrequester     bool
	reviewer             *uuid.UUID
	clearedreviewer      bool
	discussion           *uuid.UUID
	cleareddiscussion    bool
	done                 bool
	oldValue             func(context.Context) (*RetrospectiveReview, error)
	predicates           []predicate.RetrospectiveReview
}

var _ ent.Mutation = (*RetrospectiveReviewMutation)(nil)

// retrospectivereviewOption allows management of the mutation configuration using functional options.
type retrospectivereviewOption func(*RetrospectiveReviewMutation)

// newRetrospectiveReviewMutation creates new mutation for the RetrospectiveReview entity.
func newRetrospectiveReviewMutation(c config, op Op, opts ...retrospectivereviewOption) *RetrospectiveReviewMutation {
	m := &RetrospectiveReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeRetrospectiveReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRetrospectiveReviewID sets the ID field of the mutation.
func withRetrospectiveReviewID(id uuid.UUID) retrospectivereviewOption {
	return func(m *RetrospectiveReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *RetrospectiveReview
		)
		m.oldValue = func(ctx context.Context) (*RetrospectiveReview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RetrospectiveReview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRetrospectiveReview sets the old RetrospectiveReview of the mutation.
func withRetrospectiveReview(node *RetrospectiveReview) retrospectivereviewOption {
	return func(m *RetrospectiveReviewMutation) {
		m.oldValue = func(context.Context) (*RetrospectiveReview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RetrospectiveReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RetrospectiveReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RetrospectiveReview entities.
func (m *RetrospectiveReviewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RetrospectiveReviewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RetrospectiveReviewMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RetrospectiveReview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRetrospectiveID sets the "retrospective_id" field.
func (m *RetrospectiveReviewMutation) SetRetrospectiveID(u uuid.UUID) {
	m.retrospective = &u
}

// RetrospectiveID returns the value of the "retrospective_id" field in the mutation.
func (m *RetrospectiveReviewMutation) RetrospectiveID() (r uuid.UUID, exists bool) {
	v := m.retrospective
	if v == nil {
		return
	}
	return *v, true
}

// OldRetrospectiveID returns the old "retrospective_id" field's value of the RetrospectiveReview entity.
// If the RetrospectiveReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveReviewMutation) OldRetrospectiveID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetrospectiveID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetrospectiveID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetrospectiveID: %w", err)
	}
	return oldValue.RetrospectiveID, nil
}

// ResetRetrospectiveID resets all changes to the "retrospective_id" field.
func (m *RetrospectiveReviewMutation) ResetRetrospectiveID() {
	m.retrospective = nil
}

// SetRequesterID sets the "requester_id" field.
func (m *RetrospectiveReviewMutation) SetRequesterID(u uuid.UUID) {
	m.requester = &u
}

// RequesterID returns the value of the "requester_id" field in the mutation.
func (m *RetrospectiveReviewMutation) RequesterID() (r uuid.UUID, exists bool) {
	v := m.requester
	if v == nil {
		return
	}
	return *v, true
}

// OldRequesterID returns the old "requester_id" field's value of the RetrospectiveReview entity.
// If the RetrospectiveReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveReviewMutation) OldRequesterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequesterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequesterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequesterID: %w", err)
	}
	return oldValue.RequesterID, nil
}

// ResetRequesterID resets all changes to the "requester_id" field.
func (m *RetrospectiveReviewMutation) ResetRequesterID() {
	m.requester = nil
}

// SetReviewerID sets the "reviewer_id" field.
func (m *RetrospectiveReviewMutation) SetReviewerID(u uuid.UUID) {
	m.reviewer = &u
}

// ReviewerID returns the value of the "reviewer_id" field in the mutation.
func (m *RetrospectiveReviewMutation) ReviewerID() (r uuid.UUID, exists bool) {
	v := m.reviewer
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewerID returns the old "reviewer_id" field's value of the RetrospectiveReview entity.
// If the RetrospectiveReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveReviewMutation) OldReviewerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewerID: %w", err)
	}
	return oldValue.ReviewerID, nil
}

// ResetReviewerID resets all changes to the "reviewer_id" field.
func (m *RetrospectiveReviewMutation) ResetReviewerID() {
	m.reviewer = nil
}

// SetState sets the "state" field.
func (m *RetrospectiveReviewMutation) SetState(r retrospectivereview.State) {
	m.state = &r
}

// State returns the value of the "state" field in the mutation.
func (m *RetrospectiveReviewMutation) State() (r retrospectivereview.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the RetrospectiveReview entity.
// If the RetrospectiveReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveReviewMutation) OldState(ctx context.Context) (v retrospectivereview.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *RetrospectiveReviewMutation) ResetState() {
	m.state = nil
}

// ClearRetrospective clears the "retrospective" edge to the Retrospective entity.
func (m *RetrospectiveReviewMutation) ClearRetrospective() {
	m.clearedretrospective = true
	m.clearedFields[retrospectivereview.FieldRetrospectiveID] = struct{}{}
}

// RetrospectiveCleared reports if the "retrospective" edge to the Retrospective entity was cleared.
func (m *RetrospectiveReviewMutation) RetrospectiveCleared() bool {
	return m.clearedretrospective
}

// RetrospectiveIDs returns the "retrospective" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RetrospectiveID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveReviewMutation) RetrospectiveIDs() (ids []uuid.UUID) {
	if id := m.retrospective; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRetrospective resets all changes to the "retrospective" edge.
func (m *RetrospectiveReviewMutation) ResetRetrospective() {
	m.retrospective = nil
	m.clearedretrospective = false
}

// ClearRequester clears the "requester" edge to the User entity.
func (m *RetrospectiveReviewMutation) ClearRequester() {
	m.clearedrequester = true
	m.clearedFields[retrospectivereview.FieldRequesterID] = struct{}{}
}

// RequesterCleared reports if the "requester" edge to the User entity was cleared.
func (m *RetrospectiveReviewMutation) RequesterCleared() bool {
	return m.clearedrequester
}

// RequesterIDs returns the "requester" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequesterID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveReviewMutation) RequesterIDs() (ids []uuid.UUID) {
	if id := m.requester; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequester resets all changes to the "requester" edge.
func (m *RetrospectiveReviewMutation) ResetRequester() {
	m.requester = nil
	m.clearedrequester = false
}

// ClearReviewer clears the "reviewer" edge to the User entity.
func (m *RetrospectiveReviewMutation) ClearReviewer() {
	m.clearedreviewer = true
	m.clearedFields[retrospectivereview.FieldReviewerID] = struct{}{}
}

// ReviewerCleared reports if the "reviewer" edge to the User entity was cleared.
func (m *RetrospectiveReviewMutation) ReviewerCleared() bool {
	return m.clearedreviewer
}

// ReviewerIDs returns the "reviewer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReviewerID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveReviewMutation) ReviewerIDs() (ids []uuid.UUID) {
	if id := m.reviewer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReviewer resets all changes to the "reviewer" edge.
func (m *RetrospectiveReviewMutation) ResetReviewer() {
	m.reviewer = nil
	m.clearedreviewer = false
}

// SetDiscussionID sets the "discussion" edge to the RetrospectiveDiscussion entity by id.
func (m *RetrospectiveReviewMutation) SetDiscussionID(id uuid.UUID) {
	m.discussion = &id
}

// ClearDiscussion clears the "discussion" edge to the RetrospectiveDiscussion entity.
func (m *RetrospectiveReviewMutation) ClearDiscussion() {
	m.cleareddiscussion = true
}

// DiscussionCleared reports if the "discussion" edge to the RetrospectiveDiscussion entity was cleared.
func (m *RetrospectiveReviewMutation) DiscussionCleared() bool {
	return m.cleareddiscussion
}

// DiscussionID returns the "discussion" edge ID in the mutation.
func (m *RetrospectiveReviewMutation) DiscussionID() (id uuid.UUID, exists bool) {
	if m.discussion != nil {
		return *m.discussion, true
	}
	return
}

// DiscussionIDs returns the "discussion" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DiscussionID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveReviewMutation) DiscussionIDs() (ids []uuid.UUID) {
	if id := m.discussion; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDiscussion resets all changes to the "discussion" edge.
func (m *RetrospectiveReviewMutation) ResetDiscussion() {
	m.discussion = nil
	m.cleareddiscussion = false
}

// Where appends a list predicates to the RetrospectiveReviewMutation builder.
func (m *RetrospectiveReviewMutation) Where(ps ...predicate.RetrospectiveReview) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RetrospectiveReviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RetrospectiveReviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RetrospectiveReview, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RetrospectiveReviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RetrospectiveReviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RetrospectiveReview).
func (m *RetrospectiveReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RetrospectiveReviewMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.retrospective != nil {
		fields = append(fields, retrospectivereview.FieldRetrospectiveID)
	}
	if m.requester != nil {
		fields = append(fields, retrospectivereview.FieldRequesterID)
	}
	if m.reviewer != nil {
		fields = append(fields, retrospectivereview.FieldReviewerID)
	}
	if m.state != nil {
		fields = append(fields, retrospectivereview.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RetrospectiveReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case retrospectivereview.FieldRetrospectiveID:
		return m.RetrospectiveID()
	case retrospectivereview.FieldRequesterID:
		return m.RequesterID()
	case retrospectivereview.FieldReviewerID:
		return m.ReviewerID()
	case retrospectivereview.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RetrospectiveReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case retrospectivereview.FieldRetrospectiveID:
		return m.OldRetrospectiveID(ctx)
	case retrospectivereview.FieldRequesterID:
		return m.OldRequesterID(ctx)
	case retrospectivereview.FieldReviewerID:
		return m.OldReviewerID(ctx)
	case retrospectivereview.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown RetrospectiveReview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case retrospectivereview.FieldRetrospectiveID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetrospectiveID(v)
		return nil
	case retrospectivereview.FieldRequesterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequesterID(v)
		return nil
	case retrospectivereview.FieldReviewerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewerID(v)
		return nil
	case retrospectivereview.FieldState:
		v, ok := value.(retrospectivereview.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveReview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RetrospectiveReviewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RetrospectiveReviewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RetrospectiveReview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RetrospectiveReviewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RetrospectiveReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RetrospectiveReviewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RetrospectiveReview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RetrospectiveReviewMutation) ResetField(name string) error {
	switch name {
	case retrospectivereview.FieldRetrospectiveID:
		m.ResetRetrospectiveID()
		return nil
	case retrospectivereview.FieldRequesterID:
		m.ResetRequesterID()
		return nil
	case retrospectivereview.FieldReviewerID:
		m.ResetReviewerID()
		return nil
	case retrospectivereview.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveReview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RetrospectiveReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.retrospective != nil {
		edges = append(edges, retrospectivereview.EdgeRetrospective)
	}
	if m.requester != nil {
		edges = append(edges, retrospectivereview.EdgeRequester)
	}
	if m.reviewer != nil {
		edges = append(edges, retrospectivereview.EdgeReviewer)
	}
	if m.discussion != nil {
		edges = append(edges, retrospectivereview.EdgeDiscussion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RetrospectiveReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case retrospectivereview.EdgeRetrospective:
		if id := m.retrospective; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivereview.EdgeRequester:
		if id := m.requester; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivereview.EdgeReviewer:
		if id := m.reviewer; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivereview.EdgeDiscussion:
		if id := m.discussion; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RetrospectiveReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RetrospectiveReviewMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RetrospectiveReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedretrospective {
		edges = append(edges, retrospectivereview.EdgeRetrospective)
	}
	if m.clearedrequester {
		edges = append(edges, retrospectivereview.EdgeRequester)
	}
	if m.clearedreviewer {
		edges = append(edges, retrospectivereview.EdgeReviewer)
	}
	if m.cleareddiscussion {
		edges = append(edges, retrospectivereview.EdgeDiscussion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RetrospectiveReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case retrospectivereview.EdgeRetrospective:
		return m.clearedretrospective
	case retrospectivereview.EdgeRequester:
		return m.clearedrequester
	case retrospectivereview.EdgeReviewer:
		return m.clearedreviewer
	case retrospectivereview.EdgeDiscussion:
		return m.cleareddiscussion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RetrospectiveReviewMutation) ClearEdge(name string) error {
	switch name {
	case retrospectivereview.EdgeRetrospective:
		m.ClearRetrospective()
		return nil
	case retrospectivereview.EdgeRequester:
		m.ClearRequester()
		return nil
	case retrospectivereview.EdgeReviewer:
		m.ClearReviewer()
		return nil
	case retrospectivereview.EdgeDiscussion:
		m.ClearDiscussion()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveReview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RetrospectiveReviewMutation) ResetEdge(name string) error {
	switch name {
	case retrospectivereview.EdgeRetrospective:
		m.ResetRetrospective()
		return nil
	case retrospectivereview.EdgeRequester:
		m.ResetRequester()
		return nil
	case retrospectivereview.EdgeReviewer:
		m.ResetReviewer()
		return nil
	case retrospectivereview.EdgeDiscussion:
		m.ResetDiscussion()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveReview edge %s", name)
}

// SystemComponentMutation represents an operation that mutates the SystemComponent nodes in the graph.
type SystemComponentMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	name                          *string
	_type                         *systemcomponent.Type
	description                   *string
	properties                    *map[string]interface{}
	created_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	parent                        *uuid.UUID
	clearedparent                 bool
	children                      map[uuid.UUID]struct{}
	removedchildren               map[uuid.UUID]struct{}
	clearedchildren               bool
	controls                      map[uuid.UUID]struct{}
	removedcontrols               map[uuid.UUID]struct{}
	clearedcontrols               bool
	feedback_to                   map[uuid.UUID]struct{}
	removedfeedback_to            map[uuid.UUID]struct{}
	clearedfeedback_to            bool
	control_relationships         map[uuid.UUID]struct{}
	removedcontrol_relationships  map[uuid.UUID]struct{}
	clearedcontrol_relationships  bool
	feedback_relationships        map[uuid.UUID]struct{}
	removedfeedback_relationships map[uuid.UUID]struct{}
	clearedfeedback_relationships bool
	done                          bool
	oldValue                      func(context.Context) (*SystemComponent, error)
	predicates                    []predicate.SystemComponent
}

var _ ent.Mutation = (*SystemComponentMutation)(nil)

// systemcomponentOption allows management of the mutation configuration using functional options.
type systemcomponentOption func(*SystemComponentMutation)

// newSystemComponentMutation creates new mutation for the SystemComponent entity.
func newSystemComponentMutation(c config, op Op, opts ...systemcomponentOption) *SystemComponentMutation {
	m := &SystemComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemComponentID sets the ID field of the mutation.
func withSystemComponentID(id uuid.UUID) systemcomponentOption {
	return func(m *SystemComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemComponent
		)
		m.oldValue = func(ctx context.Context) (*SystemComponent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemComponent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemComponent sets the old SystemComponent of the mutation.
func withSystemComponent(node *SystemComponent) systemcomponentOption {
	return func(m *SystemComponentMutation) {
		m.oldValue = func(context.Context) (*SystemComponent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemComponent entities.
func (m *SystemComponentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemComponentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemComponentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemComponent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SystemComponentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SystemComponentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SystemComponentMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *SystemComponentMutation) SetType(s systemcomponent.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SystemComponentMutation) GetType() (r systemcomponent.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldType(ctx context.Context) (v systemcomponent.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SystemComponentMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *SystemComponentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemComponentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemComponentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemcomponent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemComponentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemcomponent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemComponentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemcomponent.FieldDescription)
}

// SetProperties sets the "properties" field.
func (m *SystemComponentMutation) SetProperties(value map[string]interface{}) {
	m.properties = &value
}

// Properties returns the value of the "properties" field in the mutation.
func (m *SystemComponentMutation) Properties() (r map[string]interface{}, exists bool) {
	v := m.properties
	if v == nil {
		return
	}
	return *v, true
}

// OldProperties returns the old "properties" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldProperties(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProperties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProperties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProperties: %w", err)
	}
	return oldValue.Properties, nil
}

// ClearProperties clears the value of the "properties" field.
func (m *SystemComponentMutation) ClearProperties() {
	m.properties = nil
	m.clearedFields[systemcomponent.FieldProperties] = struct{}{}
}

// PropertiesCleared returns if the "properties" field was cleared in this mutation.
func (m *SystemComponentMutation) PropertiesCleared() bool {
	_, ok := m.clearedFields[systemcomponent.FieldProperties]
	return ok
}

// ResetProperties resets all changes to the "properties" field.
func (m *SystemComponentMutation) ResetProperties() {
	m.properties = nil
	delete(m.clearedFields, systemcomponent.FieldProperties)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemComponentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemComponentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemComponentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemComponentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemComponentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemComponentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetParentID sets the "parent" edge to the SystemComponent entity by id.
func (m *SystemComponentMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the SystemComponent entity.
func (m *SystemComponentMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the SystemComponent entity was cleared.
func (m *SystemComponentMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *SystemComponentMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *SystemComponentMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *SystemComponentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the SystemComponent entity by ids.
func (m *SystemComponentMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the SystemComponent entity.
func (m *SystemComponentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the SystemComponent entity was cleared.
func (m *SystemComponentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the SystemComponent entity by IDs.
func (m *SystemComponentMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the SystemComponent entity.
func (m *SystemComponentMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *SystemComponentMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *SystemComponentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddControlIDs adds the "controls" edge to the SystemComponent entity by ids.
func (m *SystemComponentMutation) AddControlIDs(ids ...uuid.UUID) {
	if m.controls == nil {
		m.controls = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.controls[ids[i]] = struct{}{}
	}
}

// ClearControls clears the "controls" edge to the SystemComponent entity.
func (m *SystemComponentMutation) ClearControls() {
	m.clearedcontrols = true
}

// ControlsCleared reports if the "controls" edge to the SystemComponent entity was cleared.
func (m *SystemComponentMutation) ControlsCleared() bool {
	return m.clearedcontrols
}

// RemoveControlIDs removes the "controls" edge to the SystemComponent entity by IDs.
func (m *SystemComponentMutation) RemoveControlIDs(ids ...uuid.UUID) {
	if m.removedcontrols == nil {
		m.removedcontrols = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.controls, ids[i])
		m.removedcontrols[ids[i]] = struct{}{}
	}
}

// RemovedControls returns the removed IDs of the "controls" edge to the SystemComponent entity.
func (m *SystemComponentMutation) RemovedControlsIDs() (ids []uuid.UUID) {
	for id := range m.removedcontrols {
		ids = append(ids, id)
	}
	return
}

// ControlsIDs returns the "controls" edge IDs in the mutation.
func (m *SystemComponentMutation) ControlsIDs() (ids []uuid.UUID) {
	for id := range m.controls {
		ids = append(ids, id)
	}
	return
}

// ResetControls resets all changes to the "controls" edge.
func (m *SystemComponentMutation) ResetControls() {
	m.controls = nil
	m.clearedcontrols = false
	m.removedcontrols = nil
}

// AddFeedbackToIDs adds the "feedback_to" edge to the SystemComponent entity by ids.
func (m *SystemComponentMutation) AddFeedbackToIDs(ids ...uuid.UUID) {
	if m.feedback_to == nil {
		m.feedback_to = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.feedback_to[ids[i]] = struct{}{}
	}
}

// ClearFeedbackTo clears the "feedback_to" edge to the SystemComponent entity.
func (m *SystemComponentMutation) ClearFeedbackTo() {
	m.clearedfeedback_to = true
}

// FeedbackToCleared reports if the "feedback_to" edge to the SystemComponent entity was cleared.
func (m *SystemComponentMutation) FeedbackToCleared() bool {
	return m.clearedfeedback_to
}

// RemoveFeedbackToIDs removes the "feedback_to" edge to the SystemComponent entity by IDs.
func (m *SystemComponentMutation) RemoveFeedbackToIDs(ids ...uuid.UUID) {
	if m.removedfeedback_to == nil {
		m.removedfeedback_to = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.feedback_to, ids[i])
		m.removedfeedback_to[ids[i]] = struct{}{}
	}
}

// RemovedFeedbackTo returns the removed IDs of the "feedback_to" edge to the SystemComponent entity.
func (m *SystemComponentMutation) RemovedFeedbackToIDs() (ids []uuid.UUID) {
	for id := range m.removedfeedback_to {
		ids = append(ids, id)
	}
	return
}

// FeedbackToIDs returns the "feedback_to" edge IDs in the mutation.
func (m *SystemComponentMutation) FeedbackToIDs() (ids []uuid.UUID) {
	for id := range m.feedback_to {
		ids = append(ids, id)
	}
	return
}

// ResetFeedbackTo resets all changes to the "feedback_to" edge.
func (m *SystemComponentMutation) ResetFeedbackTo() {
	m.feedback_to = nil
	m.clearedfeedback_to = false
	m.removedfeedback_to = nil
}

// AddControlRelationshipIDs adds the "control_relationships" edge to the SystemComponentControlRelationship entity by ids.
func (m *SystemComponentMutation) AddControlRelationshipIDs(ids ...uuid.UUID) {
	if m.control_relationships == nil {
		m.control_relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.control_relationships[ids[i]] = struct{}{}
	}
}

// ClearControlRelationships clears the "control_relationships" edge to the SystemComponentControlRelationship entity.
func (m *SystemComponentMutation) ClearControlRelationships() {
	m.clearedcontrol_relationships = true
}

// ControlRelationshipsCleared reports if the "control_relationships" edge to the SystemComponentControlRelationship entity was cleared.
func (m *SystemComponentMutation) ControlRelationshipsCleared() bool {
	return m.clearedcontrol_relationships
}

// RemoveControlRelationshipIDs removes the "control_relationships" edge to the SystemComponentControlRelationship entity by IDs.
func (m *SystemComponentMutation) RemoveControlRelationshipIDs(ids ...uuid.UUID) {
	if m.removedcontrol_relationships == nil {
		m.removedcontrol_relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.control_relationships, ids[i])
		m.removedcontrol_relationships[ids[i]] = struct{}{}
	}
}

// RemovedControlRelationships returns the removed IDs of the "control_relationships" edge to the SystemComponentControlRelationship entity.
func (m *SystemComponentMutation) RemovedControlRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.removedcontrol_relationships {
		ids = append(ids, id)
	}
	return
}

// ControlRelationshipsIDs returns the "control_relationships" edge IDs in the mutation.
func (m *SystemComponentMutation) ControlRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.control_relationships {
		ids = append(ids, id)
	}
	return
}

// ResetControlRelationships resets all changes to the "control_relationships" edge.
func (m *SystemComponentMutation) ResetControlRelationships() {
	m.control_relationships = nil
	m.clearedcontrol_relationships = false
	m.removedcontrol_relationships = nil
}

// AddFeedbackRelationshipIDs adds the "feedback_relationships" edge to the SystemComponentFeedbackRelationship entity by ids.
func (m *SystemComponentMutation) AddFeedbackRelationshipIDs(ids ...uuid.UUID) {
	if m.feedback_relationships == nil {
		m.feedback_relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.feedback_relationships[ids[i]] = struct{}{}
	}
}

// ClearFeedbackRelationships clears the "feedback_relationships" edge to the SystemComponentFeedbackRelationship entity.
func (m *SystemComponentMutation) ClearFeedbackRelationships() {
	m.clearedfeedback_relationships = true
}

// FeedbackRelationshipsCleared reports if the "feedback_relationships" edge to the SystemComponentFeedbackRelationship entity was cleared.
func (m *SystemComponentMutation) FeedbackRelationshipsCleared() bool {
	return m.clearedfeedback_relationships
}

// RemoveFeedbackRelationshipIDs removes the "feedback_relationships" edge to the SystemComponentFeedbackRelationship entity by IDs.
func (m *SystemComponentMutation) RemoveFeedbackRelationshipIDs(ids ...uuid.UUID) {
	if m.removedfeedback_relationships == nil {
		m.removedfeedback_relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.feedback_relationships, ids[i])
		m.removedfeedback_relationships[ids[i]] = struct{}{}
	}
}

// RemovedFeedbackRelationships returns the removed IDs of the "feedback_relationships" edge to the SystemComponentFeedbackRelationship entity.
func (m *SystemComponentMutation) RemovedFeedbackRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.removedfeedback_relationships {
		ids = append(ids, id)
	}
	return
}

// FeedbackRelationshipsIDs returns the "feedback_relationships" edge IDs in the mutation.
func (m *SystemComponentMutation) FeedbackRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.feedback_relationships {
		ids = append(ids, id)
	}
	return
}

// ResetFeedbackRelationships resets all changes to the "feedback_relationships" edge.
func (m *SystemComponentMutation) ResetFeedbackRelationships() {
	m.feedback_relationships = nil
	m.clearedfeedback_relationships = false
	m.removedfeedback_relationships = nil
}

// Where appends a list predicates to the SystemComponentMutation builder.
func (m *SystemComponentMutation) Where(ps ...predicate.SystemComponent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemComponentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemComponentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemComponent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemComponentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemComponentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemComponent).
func (m *SystemComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemComponentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, systemcomponent.FieldName)
	}
	if m._type != nil {
		fields = append(fields, systemcomponent.FieldType)
	}
	if m.description != nil {
		fields = append(fields, systemcomponent.FieldDescription)
	}
	if m.properties != nil {
		fields = append(fields, systemcomponent.FieldProperties)
	}
	if m.created_at != nil {
		fields = append(fields, systemcomponent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, systemcomponent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemcomponent.FieldName:
		return m.Name()
	case systemcomponent.FieldType:
		return m.GetType()
	case systemcomponent.FieldDescription:
		return m.Description()
	case systemcomponent.FieldProperties:
		return m.Properties()
	case systemcomponent.FieldCreatedAt:
		return m.CreatedAt()
	case systemcomponent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemcomponent.FieldName:
		return m.OldName(ctx)
	case systemcomponent.FieldType:
		return m.OldType(ctx)
	case systemcomponent.FieldDescription:
		return m.OldDescription(ctx)
	case systemcomponent.FieldProperties:
		return m.OldProperties(ctx)
	case systemcomponent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case systemcomponent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemComponent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemcomponent.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case systemcomponent.FieldType:
		v, ok := value.(systemcomponent.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case systemcomponent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemcomponent.FieldProperties:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProperties(v)
		return nil
	case systemcomponent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case systemcomponent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemComponent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemComponent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemComponentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemcomponent.FieldDescription) {
		fields = append(fields, systemcomponent.FieldDescription)
	}
	if m.FieldCleared(systemcomponent.FieldProperties) {
		fields = append(fields, systemcomponent.FieldProperties)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemComponentMutation) ClearField(name string) error {
	switch name {
	case systemcomponent.FieldDescription:
		m.ClearDescription()
		return nil
	case systemcomponent.FieldProperties:
		m.ClearProperties()
		return nil
	}
	return fmt.Errorf("unknown SystemComponent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemComponentMutation) ResetField(name string) error {
	switch name {
	case systemcomponent.FieldName:
		m.ResetName()
		return nil
	case systemcomponent.FieldType:
		m.ResetType()
		return nil
	case systemcomponent.FieldDescription:
		m.ResetDescription()
		return nil
	case systemcomponent.FieldProperties:
		m.ResetProperties()
		return nil
	case systemcomponent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case systemcomponent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemComponent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.parent != nil {
		edges = append(edges, systemcomponent.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, systemcomponent.EdgeChildren)
	}
	if m.controls != nil {
		edges = append(edges, systemcomponent.EdgeControls)
	}
	if m.feedback_to != nil {
		edges = append(edges, systemcomponent.EdgeFeedbackTo)
	}
	if m.control_relationships != nil {
		edges = append(edges, systemcomponent.EdgeControlRelationships)
	}
	if m.feedback_relationships != nil {
		edges = append(edges, systemcomponent.EdgeFeedbackRelationships)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemcomponent.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponent.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeControls:
		ids := make([]ent.Value, 0, len(m.controls))
		for id := range m.controls {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeFeedbackTo:
		ids := make([]ent.Value, 0, len(m.feedback_to))
		for id := range m.feedback_to {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeControlRelationships:
		ids := make([]ent.Value, 0, len(m.control_relationships))
		for id := range m.control_relationships {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeFeedbackRelationships:
		ids := make([]ent.Value, 0, len(m.feedback_relationships))
		for id := range m.feedback_relationships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedchildren != nil {
		edges = append(edges, systemcomponent.EdgeChildren)
	}
	if m.removedcontrols != nil {
		edges = append(edges, systemcomponent.EdgeControls)
	}
	if m.removedfeedback_to != nil {
		edges = append(edges, systemcomponent.EdgeFeedbackTo)
	}
	if m.removedcontrol_relationships != nil {
		edges = append(edges, systemcomponent.EdgeControlRelationships)
	}
	if m.removedfeedback_relationships != nil {
		edges = append(edges, systemcomponent.EdgeFeedbackRelationships)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemComponentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case systemcomponent.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeControls:
		ids := make([]ent.Value, 0, len(m.removedcontrols))
		for id := range m.removedcontrols {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeFeedbackTo:
		ids := make([]ent.Value, 0, len(m.removedfeedback_to))
		for id := range m.removedfeedback_to {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeControlRelationships:
		ids := make([]ent.Value, 0, len(m.removedcontrol_relationships))
		for id := range m.removedcontrol_relationships {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeFeedbackRelationships:
		ids := make([]ent.Value, 0, len(m.removedfeedback_relationships))
		for id := range m.removedfeedback_relationships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedparent {
		edges = append(edges, systemcomponent.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, systemcomponent.EdgeChildren)
	}
	if m.clearedcontrols {
		edges = append(edges, systemcomponent.EdgeControls)
	}
	if m.clearedfeedback_to {
		edges = append(edges, systemcomponent.EdgeFeedbackTo)
	}
	if m.clearedcontrol_relationships {
		edges = append(edges, systemcomponent.EdgeControlRelationships)
	}
	if m.clearedfeedback_relationships {
		edges = append(edges, systemcomponent.EdgeFeedbackRelationships)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case systemcomponent.EdgeParent:
		return m.clearedparent
	case systemcomponent.EdgeChildren:
		return m.clearedchildren
	case systemcomponent.EdgeControls:
		return m.clearedcontrols
	case systemcomponent.EdgeFeedbackTo:
		return m.clearedfeedback_to
	case systemcomponent.EdgeControlRelationships:
		return m.clearedcontrol_relationships
	case systemcomponent.EdgeFeedbackRelationships:
		return m.clearedfeedback_relationships
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemComponentMutation) ClearEdge(name string) error {
	switch name {
	case systemcomponent.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown SystemComponent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemComponentMutation) ResetEdge(name string) error {
	switch name {
	case systemcomponent.EdgeParent:
		m.ResetParent()
		return nil
	case systemcomponent.EdgeChildren:
		m.ResetChildren()
		return nil
	case systemcomponent.EdgeControls:
		m.ResetControls()
		return nil
	case systemcomponent.EdgeFeedbackTo:
		m.ResetFeedbackTo()
		return nil
	case systemcomponent.EdgeControlRelationships:
		m.ResetControlRelationships()
		return nil
	case systemcomponent.EdgeFeedbackRelationships:
		m.ResetFeedbackRelationships()
		return nil
	}
	return fmt.Errorf("unknown SystemComponent edge %s", name)
}

// SystemComponentControlRelationshipMutation represents an operation that mutates the SystemComponentControlRelationship nodes in the graph.
type SystemComponentControlRelationshipMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	_type             *string
	description       *string
	created_at        *time.Time
	clearedFields     map[string]struct{}
	controller        *uuid.UUID
	clearedcontroller bool
	controlled        *uuid.UUID
	clearedcontrolled bool
	done              bool
	oldValue          func(context.Context) (*SystemComponentControlRelationship, error)
	predicates        []predicate.SystemComponentControlRelationship
}

var _ ent.Mutation = (*SystemComponentControlRelationshipMutation)(nil)

// systemcomponentcontrolrelationshipOption allows management of the mutation configuration using functional options.
type systemcomponentcontrolrelationshipOption func(*SystemComponentControlRelationshipMutation)

// newSystemComponentControlRelationshipMutation creates new mutation for the SystemComponentControlRelationship entity.
func newSystemComponentControlRelationshipMutation(c config, op Op, opts ...systemcomponentcontrolrelationshipOption) *SystemComponentControlRelationshipMutation {
	m := &SystemComponentControlRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemComponentControlRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemComponentControlRelationshipID sets the ID field of the mutation.
func withSystemComponentControlRelationshipID(id uuid.UUID) systemcomponentcontrolrelationshipOption {
	return func(m *SystemComponentControlRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemComponentControlRelationship
		)
		m.oldValue = func(ctx context.Context) (*SystemComponentControlRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemComponentControlRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemComponentControlRelationship sets the old SystemComponentControlRelationship of the mutation.
func withSystemComponentControlRelationship(node *SystemComponentControlRelationship) systemcomponentcontrolrelationshipOption {
	return func(m *SystemComponentControlRelationshipMutation) {
		m.oldValue = func(context.Context) (*SystemComponentControlRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemComponentControlRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemComponentControlRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemComponentControlRelationship entities.
func (m *SystemComponentControlRelationshipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemComponentControlRelationshipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemComponentControlRelationshipMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemComponentControlRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetControllerID sets the "controller_id" field.
func (m *SystemComponentControlRelationshipMutation) SetControllerID(u uuid.UUID) {
	m.controller = &u
}

// ControllerID returns the value of the "controller_id" field in the mutation.
func (m *SystemComponentControlRelationshipMutation) ControllerID() (r uuid.UUID, exists bool) {
	v := m.controller
	if v == nil {
		return
	}
	return *v, true
}

// OldControllerID returns the old "controller_id" field's value of the SystemComponentControlRelationship entity.
// If the SystemComponentControlRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentControlRelationshipMutation) OldControllerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControllerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControllerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControllerID: %w", err)
	}
	return oldValue.ControllerID, nil
}

// ResetControllerID resets all changes to the "controller_id" field.
func (m *SystemComponentControlRelationshipMutation) ResetControllerID() {
	m.controller = nil
}

// SetControlledID sets the "controlled_id" field.
func (m *SystemComponentControlRelationshipMutation) SetControlledID(u uuid.UUID) {
	m.controlled = &u
}

// ControlledID returns the value of the "controlled_id" field in the mutation.
func (m *SystemComponentControlRelationshipMutation) ControlledID() (r uuid.UUID, exists bool) {
	v := m.controlled
	if v == nil {
		return
	}
	return *v, true
}

// OldControlledID returns the old "controlled_id" field's value of the SystemComponentControlRelationship entity.
// If the SystemComponentControlRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentControlRelationshipMutation) OldControlledID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlledID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlledID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlledID: %w", err)
	}
	return oldValue.ControlledID, nil
}

// ResetControlledID resets all changes to the "controlled_id" field.
func (m *SystemComponentControlRelationshipMutation) ResetControlledID() {
	m.controlled = nil
}

// SetType sets the "type" field.
func (m *SystemComponentControlRelationshipMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SystemComponentControlRelationshipMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SystemComponentControlRelationship entity.
// If the SystemComponentControlRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentControlRelationshipMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SystemComponentControlRelationshipMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *SystemComponentControlRelationshipMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemComponentControlRelationshipMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemComponentControlRelationship entity.
// If the SystemComponentControlRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentControlRelationshipMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemComponentControlRelationshipMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemcomponentcontrolrelationship.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemComponentControlRelationshipMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemcomponentcontrolrelationship.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemComponentControlRelationshipMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemcomponentcontrolrelationship.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemComponentControlRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemComponentControlRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemComponentControlRelationship entity.
// If the SystemComponentControlRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentControlRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemComponentControlRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearController clears the "controller" edge to the SystemComponent entity.
func (m *SystemComponentControlRelationshipMutation) ClearController() {
	m.clearedcontroller = true
	m.clearedFields[systemcomponentcontrolrelationship.FieldControllerID] = struct{}{}
}

// ControllerCleared reports if the "controller" edge to the SystemComponent entity was cleared.
func (m *SystemComponentControlRelationshipMutation) ControllerCleared() bool {
	return m.clearedcontroller
}

// ControllerIDs returns the "controller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ControllerID instead. It exists only for internal usage by the builders.
func (m *SystemComponentControlRelationshipMutation) ControllerIDs() (ids []uuid.UUID) {
	if id := m.controller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetController resets all changes to the "controller" edge.
func (m *SystemComponentControlRelationshipMutation) ResetController() {
	m.controller = nil
	m.clearedcontroller = false
}

// ClearControlled clears the "controlled" edge to the SystemComponent entity.
func (m *SystemComponentControlRelationshipMutation) ClearControlled() {
	m.clearedcontrolled = true
	m.clearedFields[systemcomponentcontrolrelationship.FieldControlledID] = struct{}{}
}

// ControlledCleared reports if the "controlled" edge to the SystemComponent entity was cleared.
func (m *SystemComponentControlRelationshipMutation) ControlledCleared() bool {
	return m.clearedcontrolled
}

// ControlledIDs returns the "controlled" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ControlledID instead. It exists only for internal usage by the builders.
func (m *SystemComponentControlRelationshipMutation) ControlledIDs() (ids []uuid.UUID) {
	if id := m.controlled; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetControlled resets all changes to the "controlled" edge.
func (m *SystemComponentControlRelationshipMutation) ResetControlled() {
	m.controlled = nil
	m.clearedcontrolled = false
}

// Where appends a list predicates to the SystemComponentControlRelationshipMutation builder.
func (m *SystemComponentControlRelationshipMutation) Where(ps ...predicate.SystemComponentControlRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemComponentControlRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemComponentControlRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemComponentControlRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemComponentControlRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemComponentControlRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemComponentControlRelationship).
func (m *SystemComponentControlRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemComponentControlRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.controller != nil {
		fields = append(fields, systemcomponentcontrolrelationship.FieldControllerID)
	}
	if m.controlled != nil {
		fields = append(fields, systemcomponentcontrolrelationship.FieldControlledID)
	}
	if m._type != nil {
		fields = append(fields, systemcomponentcontrolrelationship.FieldType)
	}
	if m.description != nil {
		fields = append(fields, systemcomponentcontrolrelationship.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, systemcomponentcontrolrelationship.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemComponentControlRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemcomponentcontrolrelationship.FieldControllerID:
		return m.ControllerID()
	case systemcomponentcontrolrelationship.FieldControlledID:
		return m.ControlledID()
	case systemcomponentcontrolrelationship.FieldType:
		return m.GetType()
	case systemcomponentcontrolrelationship.FieldDescription:
		return m.Description()
	case systemcomponentcontrolrelationship.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemComponentControlRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemcomponentcontrolrelationship.FieldControllerID:
		return m.OldControllerID(ctx)
	case systemcomponentcontrolrelationship.FieldControlledID:
		return m.OldControlledID(ctx)
	case systemcomponentcontrolrelationship.FieldType:
		return m.OldType(ctx)
	case systemcomponentcontrolrelationship.FieldDescription:
		return m.OldDescription(ctx)
	case systemcomponentcontrolrelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemComponentControlRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentControlRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemcomponentcontrolrelationship.FieldControllerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControllerID(v)
		return nil
	case systemcomponentcontrolrelationship.FieldControlledID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlledID(v)
		return nil
	case systemcomponentcontrolrelationship.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case systemcomponentcontrolrelationship.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemcomponentcontrolrelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemComponentControlRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemComponentControlRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemComponentControlRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentControlRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemComponentControlRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemComponentControlRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemcomponentcontrolrelationship.FieldDescription) {
		fields = append(fields, systemcomponentcontrolrelationship.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemComponentControlRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemComponentControlRelationshipMutation) ClearField(name string) error {
	switch name {
	case systemcomponentcontrolrelationship.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentControlRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemComponentControlRelationshipMutation) ResetField(name string) error {
	switch name {
	case systemcomponentcontrolrelationship.FieldControllerID:
		m.ResetControllerID()
		return nil
	case systemcomponentcontrolrelationship.FieldControlledID:
		m.ResetControlledID()
		return nil
	case systemcomponentcontrolrelationship.FieldType:
		m.ResetType()
		return nil
	case systemcomponentcontrolrelationship.FieldDescription:
		m.ResetDescription()
		return nil
	case systemcomponentcontrolrelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentControlRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemComponentControlRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.controller != nil {
		edges = append(edges, systemcomponentcontrolrelationship.EdgeController)
	}
	if m.controlled != nil {
		edges = append(edges, systemcomponentcontrolrelationship.EdgeControlled)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemComponentControlRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentcontrolrelationship.EdgeController:
		if id := m.controller; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentcontrolrelationship.EdgeControlled:
		if id := m.controlled; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemComponentControlRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemComponentControlRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemComponentControlRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontroller {
		edges = append(edges, systemcomponentcontrolrelationship.EdgeController)
	}
	if m.clearedcontrolled {
		edges = append(edges, systemcomponentcontrolrelationship.EdgeControlled)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemComponentControlRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case systemcomponentcontrolrelationship.EdgeController:
		return m.clearedcontroller
	case systemcomponentcontrolrelationship.EdgeControlled:
		return m.clearedcontrolled
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemComponentControlRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case systemcomponentcontrolrelationship.EdgeController:
		m.ClearController()
		return nil
	case systemcomponentcontrolrelationship.EdgeControlled:
		m.ClearControlled()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentControlRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemComponentControlRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case systemcomponentcontrolrelationship.EdgeController:
		m.ResetController()
		return nil
	case systemcomponentcontrolrelationship.EdgeControlled:
		m.ResetControlled()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentControlRelationship edge %s", name)
}

// SystemComponentFeedbackRelationshipMutation represents an operation that mutates the SystemComponentFeedbackRelationship nodes in the graph.
type SystemComponentFeedbackRelationshipMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	_type         *string
	description   *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	source        *uuid.UUID
	clearedsource bool
	target        *uuid.UUID
	clearedtarget bool
	done          bool
	oldValue      func(context.Context) (*SystemComponentFeedbackRelationship, error)
	predicates    []predicate.SystemComponentFeedbackRelationship
}

var _ ent.Mutation = (*SystemComponentFeedbackRelationshipMutation)(nil)

// systemcomponentfeedbackrelationshipOption allows management of the mutation configuration using functional options.
type systemcomponentfeedbackrelationshipOption func(*SystemComponentFeedbackRelationshipMutation)

// newSystemComponentFeedbackRelationshipMutation creates new mutation for the SystemComponentFeedbackRelationship entity.
func newSystemComponentFeedbackRelationshipMutation(c config, op Op, opts ...systemcomponentfeedbackrelationshipOption) *SystemComponentFeedbackRelationshipMutation {
	m := &SystemComponentFeedbackRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemComponentFeedbackRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemComponentFeedbackRelationshipID sets the ID field of the mutation.
func withSystemComponentFeedbackRelationshipID(id uuid.UUID) systemcomponentfeedbackrelationshipOption {
	return func(m *SystemComponentFeedbackRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemComponentFeedbackRelationship
		)
		m.oldValue = func(ctx context.Context) (*SystemComponentFeedbackRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemComponentFeedbackRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemComponentFeedbackRelationship sets the old SystemComponentFeedbackRelationship of the mutation.
func withSystemComponentFeedbackRelationship(node *SystemComponentFeedbackRelationship) systemcomponentfeedbackrelationshipOption {
	return func(m *SystemComponentFeedbackRelationshipMutation) {
		m.oldValue = func(context.Context) (*SystemComponentFeedbackRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemComponentFeedbackRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemComponentFeedbackRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemComponentFeedbackRelationship entities.
func (m *SystemComponentFeedbackRelationshipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemComponentFeedbackRelationshipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemComponentFeedbackRelationshipMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemComponentFeedbackRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceID sets the "source_id" field.
func (m *SystemComponentFeedbackRelationshipMutation) SetSourceID(u uuid.UUID) {
	m.source = &u
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *SystemComponentFeedbackRelationshipMutation) SourceID() (r uuid.UUID, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the SystemComponentFeedbackRelationship entity.
// If the SystemComponentFeedbackRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentFeedbackRelationshipMutation) OldSourceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *SystemComponentFeedbackRelationshipMutation) ResetSourceID() {
	m.source = nil
}

// SetTargetID sets the "target_id" field.
func (m *SystemComponentFeedbackRelationshipMutation) SetTargetID(u uuid.UUID) {
	m.target = &u
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *SystemComponentFeedbackRelationshipMutation) TargetID() (r uuid.UUID, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the SystemComponentFeedbackRelationship entity.
// If the SystemComponentFeedbackRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentFeedbackRelationshipMutation) OldTargetID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *SystemComponentFeedbackRelationshipMutation) ResetTargetID() {
	m.target = nil
}

// SetType sets the "type" field.
func (m *SystemComponentFeedbackRelationshipMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SystemComponentFeedbackRelationshipMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SystemComponentFeedbackRelationship entity.
// If the SystemComponentFeedbackRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentFeedbackRelationshipMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SystemComponentFeedbackRelationshipMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *SystemComponentFeedbackRelationshipMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemComponentFeedbackRelationshipMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemComponentFeedbackRelationship entity.
// If the SystemComponentFeedbackRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentFeedbackRelationshipMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemComponentFeedbackRelationshipMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemcomponentfeedbackrelationship.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemComponentFeedbackRelationshipMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemcomponentfeedbackrelationship.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemComponentFeedbackRelationshipMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemcomponentfeedbackrelationship.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemComponentFeedbackRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemComponentFeedbackRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemComponentFeedbackRelationship entity.
// If the SystemComponentFeedbackRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentFeedbackRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemComponentFeedbackRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearSource clears the "source" edge to the SystemComponent entity.
func (m *SystemComponentFeedbackRelationshipMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[systemcomponentfeedbackrelationship.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SystemComponent entity was cleared.
func (m *SystemComponentFeedbackRelationshipMutation) SourceCleared() bool {
	return m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *SystemComponentFeedbackRelationshipMutation) SourceIDs() (ids []uuid.UUID) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *SystemComponentFeedbackRelationshipMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// ClearTarget clears the "target" edge to the SystemComponent entity.
func (m *SystemComponentFeedbackRelationshipMutation) ClearTarget() {
	m.clearedtarget = true
	m.clearedFields[systemcomponentfeedbackrelationship.FieldTargetID] = struct{}{}
}

// TargetCleared reports if the "target" edge to the SystemComponent entity was cleared.
func (m *SystemComponentFeedbackRelationshipMutation) TargetCleared() bool {
	return m.clearedtarget
}

// TargetIDs returns the "target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetID instead. It exists only for internal usage by the builders.
func (m *SystemComponentFeedbackRelationshipMutation) TargetIDs() (ids []uuid.UUID) {
	if id := m.target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *SystemComponentFeedbackRelationshipMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
}

// Where appends a list predicates to the SystemComponentFeedbackRelationshipMutation builder.
func (m *SystemComponentFeedbackRelationshipMutation) Where(ps ...predicate.SystemComponentFeedbackRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemComponentFeedbackRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemComponentFeedbackRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemComponentFeedbackRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemComponentFeedbackRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemComponentFeedbackRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemComponentFeedbackRelationship).
func (m *SystemComponentFeedbackRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemComponentFeedbackRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.source != nil {
		fields = append(fields, systemcomponentfeedbackrelationship.FieldSourceID)
	}
	if m.target != nil {
		fields = append(fields, systemcomponentfeedbackrelationship.FieldTargetID)
	}
	if m._type != nil {
		fields = append(fields, systemcomponentfeedbackrelationship.FieldType)
	}
	if m.description != nil {
		fields = append(fields, systemcomponentfeedbackrelationship.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, systemcomponentfeedbackrelationship.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemComponentFeedbackRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemcomponentfeedbackrelationship.FieldSourceID:
		return m.SourceID()
	case systemcomponentfeedbackrelationship.FieldTargetID:
		return m.TargetID()
	case systemcomponentfeedbackrelationship.FieldType:
		return m.GetType()
	case systemcomponentfeedbackrelationship.FieldDescription:
		return m.Description()
	case systemcomponentfeedbackrelationship.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemComponentFeedbackRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemcomponentfeedbackrelationship.FieldSourceID:
		return m.OldSourceID(ctx)
	case systemcomponentfeedbackrelationship.FieldTargetID:
		return m.OldTargetID(ctx)
	case systemcomponentfeedbackrelationship.FieldType:
		return m.OldType(ctx)
	case systemcomponentfeedbackrelationship.FieldDescription:
		return m.OldDescription(ctx)
	case systemcomponentfeedbackrelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemComponentFeedbackRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentFeedbackRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemcomponentfeedbackrelationship.FieldSourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case systemcomponentfeedbackrelationship.FieldTargetID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case systemcomponentfeedbackrelationship.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case systemcomponentfeedbackrelationship.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemcomponentfeedbackrelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemComponentFeedbackRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemComponentFeedbackRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemComponentFeedbackRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentFeedbackRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemComponentFeedbackRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemComponentFeedbackRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemcomponentfeedbackrelationship.FieldDescription) {
		fields = append(fields, systemcomponentfeedbackrelationship.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemComponentFeedbackRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemComponentFeedbackRelationshipMutation) ClearField(name string) error {
	switch name {
	case systemcomponentfeedbackrelationship.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentFeedbackRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemComponentFeedbackRelationshipMutation) ResetField(name string) error {
	switch name {
	case systemcomponentfeedbackrelationship.FieldSourceID:
		m.ResetSourceID()
		return nil
	case systemcomponentfeedbackrelationship.FieldTargetID:
		m.ResetTargetID()
		return nil
	case systemcomponentfeedbackrelationship.FieldType:
		m.ResetType()
		return nil
	case systemcomponentfeedbackrelationship.FieldDescription:
		m.ResetDescription()
		return nil
	case systemcomponentfeedbackrelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentFeedbackRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemComponentFeedbackRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.source != nil {
		edges = append(edges, systemcomponentfeedbackrelationship.EdgeSource)
	}
	if m.target != nil {
		edges = append(edges, systemcomponentfeedbackrelationship.EdgeTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemComponentFeedbackRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentfeedbackrelationship.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentfeedbackrelationship.EdgeTarget:
		if id := m.target; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemComponentFeedbackRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemComponentFeedbackRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemComponentFeedbackRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsource {
		edges = append(edges, systemcomponentfeedbackrelationship.EdgeSource)
	}
	if m.clearedtarget {
		edges = append(edges, systemcomponentfeedbackrelationship.EdgeTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemComponentFeedbackRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case systemcomponentfeedbackrelationship.EdgeSource:
		return m.clearedsource
	case systemcomponentfeedbackrelationship.EdgeTarget:
		return m.clearedtarget
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemComponentFeedbackRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case systemcomponentfeedbackrelationship.EdgeSource:
		m.ClearSource()
		return nil
	case systemcomponentfeedbackrelationship.EdgeTarget:
		m.ClearTarget()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentFeedbackRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemComponentFeedbackRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case systemcomponentfeedbackrelationship.EdgeSource:
		m.ResetSource()
		return nil
	case systemcomponentfeedbackrelationship.EdgeTarget:
		m.ResetTarget()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentFeedbackRelationship edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	_type            *task.Type
	title            *string
	issue_tracker_id *string
	clearedFields    map[string]struct{}
	incident         *uuid.UUID
	clearedincident  bool
	assignee         *uuid.UUID
	clearedassignee  bool
	creator          *uuid.UUID
	clearedcreator   bool
	done             bool
	oldValue         func(context.Context) (*Task, error)
	predicates       []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uuid.UUID) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *TaskMutation) SetType(t task.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskMutation) GetType() (r task.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldType(ctx context.Context) (v task.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TaskMutation) ResetType() {
	m._type = nil
}

// SetTitle sets the "title" field.
func (m *TaskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TaskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TaskMutation) ResetTitle() {
	m.title = nil
}

// SetIncidentID sets the "incident_id" field.
func (m *TaskMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *TaskMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ClearIncidentID clears the value of the "incident_id" field.
func (m *TaskMutation) ClearIncidentID() {
	m.incident = nil
	m.clearedFields[task.FieldIncidentID] = struct{}{}
}

// IncidentIDCleared returns if the "incident_id" field was cleared in this mutation.
func (m *TaskMutation) IncidentIDCleared() bool {
	_, ok := m.clearedFields[task.FieldIncidentID]
	return ok
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *TaskMutation) ResetIncidentID() {
	m.incident = nil
	delete(m.clearedFields, task.FieldIncidentID)
}

// SetAssigneeID sets the "assignee_id" field.
func (m *TaskMutation) SetAssigneeID(u uuid.UUID) {
	m.assignee = &u
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *TaskMutation) AssigneeID() (r uuid.UUID, exists bool) {
	v := m.assignee
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAssigneeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *TaskMutation) ClearAssigneeID() {
	m.assignee = nil
	m.clearedFields[task.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *TaskMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[task.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *TaskMutation) ResetAssigneeID() {
	m.assignee = nil
	delete(m.clearedFields, task.FieldAssigneeID)
}

// SetCreatorID sets the "creator_id" field.
func (m *TaskMutation) SetCreatorID(u uuid.UUID) {
	m.creator = &u
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *TaskMutation) CreatorID() (r uuid.UUID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ClearCreatorID clears the value of the "creator_id" field.
func (m *TaskMutation) ClearCreatorID() {
	m.creator = nil
	m.clearedFields[task.FieldCreatorID] = struct{}{}
}

// CreatorIDCleared returns if the "creator_id" field was cleared in this mutation.
func (m *TaskMutation) CreatorIDCleared() bool {
	_, ok := m.clearedFields[task.FieldCreatorID]
	return ok
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *TaskMutation) ResetCreatorID() {
	m.creator = nil
	delete(m.clearedFields, task.FieldCreatorID)
}

// SetIssueTrackerID sets the "issue_tracker_id" field.
func (m *TaskMutation) SetIssueTrackerID(s string) {
	m.issue_tracker_id = &s
}

// IssueTrackerID returns the value of the "issue_tracker_id" field in the mutation.
func (m *TaskMutation) IssueTrackerID() (r string, exists bool) {
	v := m.issue_tracker_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueTrackerID returns the old "issue_tracker_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIssueTrackerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueTrackerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueTrackerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueTrackerID: %w", err)
	}
	return oldValue.IssueTrackerID, nil
}

// ClearIssueTrackerID clears the value of the "issue_tracker_id" field.
func (m *TaskMutation) ClearIssueTrackerID() {
	m.issue_tracker_id = nil
	m.clearedFields[task.FieldIssueTrackerID] = struct{}{}
}

// IssueTrackerIDCleared returns if the "issue_tracker_id" field was cleared in this mutation.
func (m *TaskMutation) IssueTrackerIDCleared() bool {
	_, ok := m.clearedFields[task.FieldIssueTrackerID]
	return ok
}

// ResetIssueTrackerID resets all changes to the "issue_tracker_id" field.
func (m *TaskMutation) ResetIssueTrackerID() {
	m.issue_tracker_id = nil
	delete(m.clearedFields, task.FieldIssueTrackerID)
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *TaskMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[task.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *TaskMutation) IncidentCleared() bool {
	return m.IncidentIDCleared() || m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *TaskMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// ClearAssignee clears the "assignee" edge to the User entity.
func (m *TaskMutation) ClearAssignee() {
	m.clearedassignee = true
	m.clearedFields[task.FieldAssigneeID] = struct{}{}
}

// AssigneeCleared reports if the "assignee" edge to the User entity was cleared.
func (m *TaskMutation) AssigneeCleared() bool {
	return m.AssigneeIDCleared() || m.clearedassignee
}

// AssigneeIDs returns the "assignee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssigneeID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) AssigneeIDs() (ids []uuid.UUID) {
	if id := m.assignee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignee resets all changes to the "assignee" edge.
func (m *TaskMutation) ResetAssignee() {
	m.assignee = nil
	m.clearedassignee = false
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *TaskMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[task.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *TaskMutation) CreatorCleared() bool {
	return m.CreatorIDCleared() || m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) CreatorIDs() (ids []uuid.UUID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *TaskMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.title != nil {
		fields = append(fields, task.FieldTitle)
	}
	if m.incident != nil {
		fields = append(fields, task.FieldIncidentID)
	}
	if m.assignee != nil {
		fields = append(fields, task.FieldAssigneeID)
	}
	if m.creator != nil {
		fields = append(fields, task.FieldCreatorID)
	}
	if m.issue_tracker_id != nil {
		fields = append(fields, task.FieldIssueTrackerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldType:
		return m.GetType()
	case task.FieldTitle:
		return m.Title()
	case task.FieldIncidentID:
		return m.IncidentID()
	case task.FieldAssigneeID:
		return m.AssigneeID()
	case task.FieldCreatorID:
		return m.CreatorID()
	case task.FieldIssueTrackerID:
		return m.IssueTrackerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldType:
		return m.OldType(ctx)
	case task.FieldTitle:
		return m.OldTitle(ctx)
	case task.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case task.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case task.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case task.FieldIssueTrackerID:
		return m.OldIssueTrackerID(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldType:
		v, ok := value.(task.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case task.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case task.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case task.FieldAssigneeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case task.FieldCreatorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case task.FieldIssueTrackerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueTrackerID(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldIncidentID) {
		fields = append(fields, task.FieldIncidentID)
	}
	if m.FieldCleared(task.FieldAssigneeID) {
		fields = append(fields, task.FieldAssigneeID)
	}
	if m.FieldCleared(task.FieldCreatorID) {
		fields = append(fields, task.FieldCreatorID)
	}
	if m.FieldCleared(task.FieldIssueTrackerID) {
		fields = append(fields, task.FieldIssueTrackerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldIncidentID:
		m.ClearIncidentID()
		return nil
	case task.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case task.FieldCreatorID:
		m.ClearCreatorID()
		return nil
	case task.FieldIssueTrackerID:
		m.ClearIssueTrackerID()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldType:
		m.ResetType()
		return nil
	case task.FieldTitle:
		m.ResetTitle()
		return nil
	case task.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case task.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case task.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case task.FieldIssueTrackerID:
		m.ResetIssueTrackerID()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.incident != nil {
		edges = append(edges, task.EdgeIncident)
	}
	if m.assignee != nil {
		edges = append(edges, task.EdgeAssignee)
	}
	if m.creator != nil {
		edges = append(edges, task.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeAssignee:
		if id := m.assignee; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedincident {
		edges = append(edges, task.EdgeIncident)
	}
	if m.clearedassignee {
		edges = append(edges, task.EdgeAssignee)
	}
	if m.clearedcreator {
		edges = append(edges, task.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeIncident:
		return m.clearedincident
	case task.EdgeAssignee:
		return m.clearedassignee
	case task.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeIncident:
		m.ClearIncident()
		return nil
	case task.EdgeAssignee:
		m.ClearAssignee()
		return nil
	case task.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeIncident:
		m.ResetIncident()
		return nil
	case task.EdgeAssignee:
		m.ResetAssignee()
		return nil
	case task.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	slug                        *string
	name                        *string
	chat_channel_id             *string
	timezone                    *string
	clearedFields               map[string]struct{}
	users                       map[uuid.UUID]struct{}
	removedusers                map[uuid.UUID]struct{}
	clearedusers                bool
	oncall_rosters              map[uuid.UUID]struct{}
	removedoncall_rosters       map[uuid.UUID]struct{}
	clearedoncall_rosters       bool
	incident_assignments        map[int]struct{}
	removedincident_assignments map[int]struct{}
	clearedincident_assignments bool
	scheduled_meetings          map[uuid.UUID]struct{}
	removedscheduled_meetings   map[uuid.UUID]struct{}
	clearedscheduled_meetings   bool
	done                        bool
	oldValue                    func(context.Context) (*Team, error)
	predicates                  []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id uuid.UUID) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *TeamMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TeamMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TeamMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetChatChannelID sets the "chat_channel_id" field.
func (m *TeamMutation) SetChatChannelID(s string) {
	m.chat_channel_id = &s
}

// ChatChannelID returns the value of the "chat_channel_id" field in the mutation.
func (m *TeamMutation) ChatChannelID() (r string, exists bool) {
	v := m.chat_channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChatChannelID returns the old "chat_channel_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldChatChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatChannelID: %w", err)
	}
	return oldValue.ChatChannelID, nil
}

// ClearChatChannelID clears the value of the "chat_channel_id" field.
func (m *TeamMutation) ClearChatChannelID() {
	m.chat_channel_id = nil
	m.clearedFields[team.FieldChatChannelID] = struct{}{}
}

// ChatChannelIDCleared returns if the "chat_channel_id" field was cleared in this mutation.
func (m *TeamMutation) ChatChannelIDCleared() bool {
	_, ok := m.clearedFields[team.FieldChatChannelID]
	return ok
}

// ResetChatChannelID resets all changes to the "chat_channel_id" field.
func (m *TeamMutation) ResetChatChannelID() {
	m.chat_channel_id = nil
	delete(m.clearedFields, team.FieldChatChannelID)
}

// SetTimezone sets the "timezone" field.
func (m *TeamMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *TeamMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *TeamMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[team.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *TeamMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[team.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *TeamMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, team.FieldTimezone)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *TeamMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *TeamMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *TeamMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *TeamMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *TeamMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *TeamMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *TeamMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddOncallRosterIDs adds the "oncall_rosters" edge to the OncallRoster entity by ids.
func (m *TeamMutation) AddOncallRosterIDs(ids ...uuid.UUID) {
	if m.oncall_rosters == nil {
		m.oncall_rosters = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.oncall_rosters[ids[i]] = struct{}{}
	}
}

// ClearOncallRosters clears the "oncall_rosters" edge to the OncallRoster entity.
func (m *TeamMutation) ClearOncallRosters() {
	m.clearedoncall_rosters = true
}

// OncallRostersCleared reports if the "oncall_rosters" edge to the OncallRoster entity was cleared.
func (m *TeamMutation) OncallRostersCleared() bool {
	return m.clearedoncall_rosters
}

// RemoveOncallRosterIDs removes the "oncall_rosters" edge to the OncallRoster entity by IDs.
func (m *TeamMutation) RemoveOncallRosterIDs(ids ...uuid.UUID) {
	if m.removedoncall_rosters == nil {
		m.removedoncall_rosters = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.oncall_rosters, ids[i])
		m.removedoncall_rosters[ids[i]] = struct{}{}
	}
}

// RemovedOncallRosters returns the removed IDs of the "oncall_rosters" edge to the OncallRoster entity.
func (m *TeamMutation) RemovedOncallRostersIDs() (ids []uuid.UUID) {
	for id := range m.removedoncall_rosters {
		ids = append(ids, id)
	}
	return
}

// OncallRostersIDs returns the "oncall_rosters" edge IDs in the mutation.
func (m *TeamMutation) OncallRostersIDs() (ids []uuid.UUID) {
	for id := range m.oncall_rosters {
		ids = append(ids, id)
	}
	return
}

// ResetOncallRosters resets all changes to the "oncall_rosters" edge.
func (m *TeamMutation) ResetOncallRosters() {
	m.oncall_rosters = nil
	m.clearedoncall_rosters = false
	m.removedoncall_rosters = nil
}

// AddIncidentAssignmentIDs adds the "incident_assignments" edge to the IncidentTeamAssignment entity by ids.
func (m *TeamMutation) AddIncidentAssignmentIDs(ids ...int) {
	if m.incident_assignments == nil {
		m.incident_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.incident_assignments[ids[i]] = struct{}{}
	}
}

// ClearIncidentAssignments clears the "incident_assignments" edge to the IncidentTeamAssignment entity.
func (m *TeamMutation) ClearIncidentAssignments() {
	m.clearedincident_assignments = true
}

// IncidentAssignmentsCleared reports if the "incident_assignments" edge to the IncidentTeamAssignment entity was cleared.
func (m *TeamMutation) IncidentAssignmentsCleared() bool {
	return m.clearedincident_assignments
}

// RemoveIncidentAssignmentIDs removes the "incident_assignments" edge to the IncidentTeamAssignment entity by IDs.
func (m *TeamMutation) RemoveIncidentAssignmentIDs(ids ...int) {
	if m.removedincident_assignments == nil {
		m.removedincident_assignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.incident_assignments, ids[i])
		m.removedincident_assignments[ids[i]] = struct{}{}
	}
}

// RemovedIncidentAssignments returns the removed IDs of the "incident_assignments" edge to the IncidentTeamAssignment entity.
func (m *TeamMutation) RemovedIncidentAssignmentsIDs() (ids []int) {
	for id := range m.removedincident_assignments {
		ids = append(ids, id)
	}
	return
}

// IncidentAssignmentsIDs returns the "incident_assignments" edge IDs in the mutation.
func (m *TeamMutation) IncidentAssignmentsIDs() (ids []int) {
	for id := range m.incident_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentAssignments resets all changes to the "incident_assignments" edge.
func (m *TeamMutation) ResetIncidentAssignments() {
	m.incident_assignments = nil
	m.clearedincident_assignments = false
	m.removedincident_assignments = nil
}

// AddScheduledMeetingIDs adds the "scheduled_meetings" edge to the MeetingSchedule entity by ids.
func (m *TeamMutation) AddScheduledMeetingIDs(ids ...uuid.UUID) {
	if m.scheduled_meetings == nil {
		m.scheduled_meetings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.scheduled_meetings[ids[i]] = struct{}{}
	}
}

// ClearScheduledMeetings clears the "scheduled_meetings" edge to the MeetingSchedule entity.
func (m *TeamMutation) ClearScheduledMeetings() {
	m.clearedscheduled_meetings = true
}

// ScheduledMeetingsCleared reports if the "scheduled_meetings" edge to the MeetingSchedule entity was cleared.
func (m *TeamMutation) ScheduledMeetingsCleared() bool {
	return m.clearedscheduled_meetings
}

// RemoveScheduledMeetingIDs removes the "scheduled_meetings" edge to the MeetingSchedule entity by IDs.
func (m *TeamMutation) RemoveScheduledMeetingIDs(ids ...uuid.UUID) {
	if m.removedscheduled_meetings == nil {
		m.removedscheduled_meetings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.scheduled_meetings, ids[i])
		m.removedscheduled_meetings[ids[i]] = struct{}{}
	}
}

// RemovedScheduledMeetings returns the removed IDs of the "scheduled_meetings" edge to the MeetingSchedule entity.
func (m *TeamMutation) RemovedScheduledMeetingsIDs() (ids []uuid.UUID) {
	for id := range m.removedscheduled_meetings {
		ids = append(ids, id)
	}
	return
}

// ScheduledMeetingsIDs returns the "scheduled_meetings" edge IDs in the mutation.
func (m *TeamMutation) ScheduledMeetingsIDs() (ids []uuid.UUID) {
	for id := range m.scheduled_meetings {
		ids = append(ids, id)
	}
	return
}

// ResetScheduledMeetings resets all changes to the "scheduled_meetings" edge.
func (m *TeamMutation) ResetScheduledMeetings() {
	m.scheduled_meetings = nil
	m.clearedscheduled_meetings = false
	m.removedscheduled_meetings = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.slug != nil {
		fields = append(fields, team.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.chat_channel_id != nil {
		fields = append(fields, team.FieldChatChannelID)
	}
	if m.timezone != nil {
		fields = append(fields, team.FieldTimezone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldSlug:
		return m.Slug()
	case team.FieldName:
		return m.Name()
	case team.FieldChatChannelID:
		return m.ChatChannelID()
	case team.FieldTimezone:
		return m.Timezone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldSlug:
		return m.OldSlug(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldChatChannelID:
		return m.OldChatChannelID(ctx)
	case team.FieldTimezone:
		return m.OldTimezone(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldChatChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatChannelID(v)
		return nil
	case team.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldChatChannelID) {
		fields = append(fields, team.FieldChatChannelID)
	}
	if m.FieldCleared(team.FieldTimezone) {
		fields = append(fields, team.FieldTimezone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldChatChannelID:
		m.ClearChatChannelID()
		return nil
	case team.FieldTimezone:
		m.ClearTimezone()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldSlug:
		m.ResetSlug()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldChatChannelID:
		m.ResetChatChannelID()
		return nil
	case team.FieldTimezone:
		m.ResetTimezone()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.users != nil {
		edges = append(edges, team.EdgeUsers)
	}
	if m.oncall_rosters != nil {
		edges = append(edges, team.EdgeOncallRosters)
	}
	if m.incident_assignments != nil {
		edges = append(edges, team.EdgeIncidentAssignments)
	}
	if m.scheduled_meetings != nil {
		edges = append(edges, team.EdgeScheduledMeetings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeOncallRosters:
		ids := make([]ent.Value, 0, len(m.oncall_rosters))
		for id := range m.oncall_rosters {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeIncidentAssignments:
		ids := make([]ent.Value, 0, len(m.incident_assignments))
		for id := range m.incident_assignments {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeScheduledMeetings:
		ids := make([]ent.Value, 0, len(m.scheduled_meetings))
		for id := range m.scheduled_meetings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedusers != nil {
		edges = append(edges, team.EdgeUsers)
	}
	if m.removedoncall_rosters != nil {
		edges = append(edges, team.EdgeOncallRosters)
	}
	if m.removedincident_assignments != nil {
		edges = append(edges, team.EdgeIncidentAssignments)
	}
	if m.removedscheduled_meetings != nil {
		edges = append(edges, team.EdgeScheduledMeetings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeOncallRosters:
		ids := make([]ent.Value, 0, len(m.removedoncall_rosters))
		for id := range m.removedoncall_rosters {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeIncidentAssignments:
		ids := make([]ent.Value, 0, len(m.removedincident_assignments))
		for id := range m.removedincident_assignments {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeScheduledMeetings:
		ids := make([]ent.Value, 0, len(m.removedscheduled_meetings))
		for id := range m.removedscheduled_meetings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedusers {
		edges = append(edges, team.EdgeUsers)
	}
	if m.clearedoncall_rosters {
		edges = append(edges, team.EdgeOncallRosters)
	}
	if m.clearedincident_assignments {
		edges = append(edges, team.EdgeIncidentAssignments)
	}
	if m.clearedscheduled_meetings {
		edges = append(edges, team.EdgeScheduledMeetings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeUsers:
		return m.clearedusers
	case team.EdgeOncallRosters:
		return m.clearedoncall_rosters
	case team.EdgeIncidentAssignments:
		return m.clearedincident_assignments
	case team.EdgeScheduledMeetings:
		return m.clearedscheduled_meetings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeUsers:
		m.ResetUsers()
		return nil
	case team.EdgeOncallRosters:
		m.ResetOncallRosters()
		return nil
	case team.EdgeIncidentAssignments:
		m.ResetIncidentAssignments()
		return nil
	case team.EdgeScheduledMeetings:
		m.ResetScheduledMeetings()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *uuid.UUID
	name                                  *string
	email                                 *string
	chat_id                               *string
	timezone                              *string
	clearedFields                         map[string]struct{}
	teams                                 map[uuid.UUID]struct{}
	removedteams                          map[uuid.UUID]struct{}
	clearedteams                          bool
	oncall_schedules                      map[uuid.UUID]struct{}
	removedoncall_schedules               map[uuid.UUID]struct{}
	clearedoncall_schedules               bool
	oncall_shifts                         map[uuid.UUID]struct{}
	removedoncall_shifts                  map[uuid.UUID]struct{}
	clearedoncall_shifts                  bool
	oncall_shift_covers                   map[uuid.UUID]struct{}
	removedoncall_shift_covers            map[uuid.UUID]struct{}
	clearedoncall_shift_covers            bool
	alerts_received                       map[uuid.UUID]struct{}
	removedalerts_received                map[uuid.UUID]struct{}
	clearedalerts_received                bool
	incident_role_assignments             map[uuid.UUID]struct{}
	removedincident_role_assignments      map[uuid.UUID]struct{}
	clearedincident_role_assignments      bool
	incident_debriefs                     map[uuid.UUID]struct{}
	removedincident_debriefs              map[uuid.UUID]struct{}
	clearedincident_debriefs              bool
	assigned_tasks                        map[uuid.UUID]struct{}
	removedassigned_tasks                 map[uuid.UUID]struct{}
	clearedassigned_tasks                 bool
	created_tasks                         map[uuid.UUID]struct{}
	removedcreated_tasks                  map[uuid.UUID]struct{}
	clearedcreated_tasks                  bool
	retrospective_review_requests         map[uuid.UUID]struct{}
	removedretrospective_review_requests  map[uuid.UUID]struct{}
	clearedretrospective_review_requests  bool
	retrospective_review_responses        map[uuid.UUID]struct{}
	removedretrospective_review_responses map[uuid.UUID]struct{}
	clearedretrospective_review_responses bool
	done                                  bool
	oldValue                              func(context.Context) (*User, error)
	predicates                            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetChatID sets the "chat_id" field.
func (m *UserMutation) SetChatID(s string) {
	m.chat_id = &s
}

// ChatID returns the value of the "chat_id" field in the mutation.
func (m *UserMutation) ChatID() (r string, exists bool) {
	v := m.chat_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChatID returns the old "chat_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldChatID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatID: %w", err)
	}
	return oldValue.ChatID, nil
}

// ClearChatID clears the value of the "chat_id" field.
func (m *UserMutation) ClearChatID() {
	m.chat_id = nil
	m.clearedFields[user.FieldChatID] = struct{}{}
}

// ChatIDCleared returns if the "chat_id" field was cleared in this mutation.
func (m *UserMutation) ChatIDCleared() bool {
	_, ok := m.clearedFields[user.FieldChatID]
	return ok
}

// ResetChatID resets all changes to the "chat_id" field.
func (m *UserMutation) ResetChatID() {
	m.chat_id = nil
	delete(m.clearedFields, user.FieldChatID)
}

// SetTimezone sets the "timezone" field.
func (m *UserMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *UserMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *UserMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[user.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *UserMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[user.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *UserMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, user.FieldTimezone)
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *UserMutation) AddTeamIDs(ids ...uuid.UUID) {
	if m.teams == nil {
		m.teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *UserMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *UserMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *UserMutation) RemoveTeamIDs(ids ...uuid.UUID) {
	if m.removedteams == nil {
		m.removedteams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *UserMutation) RemovedTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *UserMutation) TeamsIDs() (ids []uuid.UUID) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *UserMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// AddOncallScheduleIDs adds the "oncall_schedules" edge to the OncallScheduleParticipant entity by ids.
func (m *UserMutation) AddOncallScheduleIDs(ids ...uuid.UUID) {
	if m.oncall_schedules == nil {
		m.oncall_schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.oncall_schedules[ids[i]] = struct{}{}
	}
}

// ClearOncallSchedules clears the "oncall_schedules" edge to the OncallScheduleParticipant entity.
func (m *UserMutation) ClearOncallSchedules() {
	m.clearedoncall_schedules = true
}

// OncallSchedulesCleared reports if the "oncall_schedules" edge to the OncallScheduleParticipant entity was cleared.
func (m *UserMutation) OncallSchedulesCleared() bool {
	return m.clearedoncall_schedules
}

// RemoveOncallScheduleIDs removes the "oncall_schedules" edge to the OncallScheduleParticipant entity by IDs.
func (m *UserMutation) RemoveOncallScheduleIDs(ids ...uuid.UUID) {
	if m.removedoncall_schedules == nil {
		m.removedoncall_schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.oncall_schedules, ids[i])
		m.removedoncall_schedules[ids[i]] = struct{}{}
	}
}

// RemovedOncallSchedules returns the removed IDs of the "oncall_schedules" edge to the OncallScheduleParticipant entity.
func (m *UserMutation) RemovedOncallSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.removedoncall_schedules {
		ids = append(ids, id)
	}
	return
}

// OncallSchedulesIDs returns the "oncall_schedules" edge IDs in the mutation.
func (m *UserMutation) OncallSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.oncall_schedules {
		ids = append(ids, id)
	}
	return
}

// ResetOncallSchedules resets all changes to the "oncall_schedules" edge.
func (m *UserMutation) ResetOncallSchedules() {
	m.oncall_schedules = nil
	m.clearedoncall_schedules = false
	m.removedoncall_schedules = nil
}

// AddOncallShiftIDs adds the "oncall_shifts" edge to the OncallUserShift entity by ids.
func (m *UserMutation) AddOncallShiftIDs(ids ...uuid.UUID) {
	if m.oncall_shifts == nil {
		m.oncall_shifts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.oncall_shifts[ids[i]] = struct{}{}
	}
}

// ClearOncallShifts clears the "oncall_shifts" edge to the OncallUserShift entity.
func (m *UserMutation) ClearOncallShifts() {
	m.clearedoncall_shifts = true
}

// OncallShiftsCleared reports if the "oncall_shifts" edge to the OncallUserShift entity was cleared.
func (m *UserMutation) OncallShiftsCleared() bool {
	return m.clearedoncall_shifts
}

// RemoveOncallShiftIDs removes the "oncall_shifts" edge to the OncallUserShift entity by IDs.
func (m *UserMutation) RemoveOncallShiftIDs(ids ...uuid.UUID) {
	if m.removedoncall_shifts == nil {
		m.removedoncall_shifts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.oncall_shifts, ids[i])
		m.removedoncall_shifts[ids[i]] = struct{}{}
	}
}

// RemovedOncallShifts returns the removed IDs of the "oncall_shifts" edge to the OncallUserShift entity.
func (m *UserMutation) RemovedOncallShiftsIDs() (ids []uuid.UUID) {
	for id := range m.removedoncall_shifts {
		ids = append(ids, id)
	}
	return
}

// OncallShiftsIDs returns the "oncall_shifts" edge IDs in the mutation.
func (m *UserMutation) OncallShiftsIDs() (ids []uuid.UUID) {
	for id := range m.oncall_shifts {
		ids = append(ids, id)
	}
	return
}

// ResetOncallShifts resets all changes to the "oncall_shifts" edge.
func (m *UserMutation) ResetOncallShifts() {
	m.oncall_shifts = nil
	m.clearedoncall_shifts = false
	m.removedoncall_shifts = nil
}

// AddOncallShiftCoverIDs adds the "oncall_shift_covers" edge to the OncallUserShiftCover entity by ids.
func (m *UserMutation) AddOncallShiftCoverIDs(ids ...uuid.UUID) {
	if m.oncall_shift_covers == nil {
		m.oncall_shift_covers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.oncall_shift_covers[ids[i]] = struct{}{}
	}
}

// ClearOncallShiftCovers clears the "oncall_shift_covers" edge to the OncallUserShiftCover entity.
func (m *UserMutation) ClearOncallShiftCovers() {
	m.clearedoncall_shift_covers = true
}

// OncallShiftCoversCleared reports if the "oncall_shift_covers" edge to the OncallUserShiftCover entity was cleared.
func (m *UserMutation) OncallShiftCoversCleared() bool {
	return m.clearedoncall_shift_covers
}

// RemoveOncallShiftCoverIDs removes the "oncall_shift_covers" edge to the OncallUserShiftCover entity by IDs.
func (m *UserMutation) RemoveOncallShiftCoverIDs(ids ...uuid.UUID) {
	if m.removedoncall_shift_covers == nil {
		m.removedoncall_shift_covers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.oncall_shift_covers, ids[i])
		m.removedoncall_shift_covers[ids[i]] = struct{}{}
	}
}

// RemovedOncallShiftCovers returns the removed IDs of the "oncall_shift_covers" edge to the OncallUserShiftCover entity.
func (m *UserMutation) RemovedOncallShiftCoversIDs() (ids []uuid.UUID) {
	for id := range m.removedoncall_shift_covers {
		ids = append(ids, id)
	}
	return
}

// OncallShiftCoversIDs returns the "oncall_shift_covers" edge IDs in the mutation.
func (m *UserMutation) OncallShiftCoversIDs() (ids []uuid.UUID) {
	for id := range m.oncall_shift_covers {
		ids = append(ids, id)
	}
	return
}

// ResetOncallShiftCovers resets all changes to the "oncall_shift_covers" edge.
func (m *UserMutation) ResetOncallShiftCovers() {
	m.oncall_shift_covers = nil
	m.clearedoncall_shift_covers = false
	m.removedoncall_shift_covers = nil
}

// AddAlertsReceivedIDs adds the "alerts_received" edge to the OncallAlertInstance entity by ids.
func (m *UserMutation) AddAlertsReceivedIDs(ids ...uuid.UUID) {
	if m.alerts_received == nil {
		m.alerts_received = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.alerts_received[ids[i]] = struct{}{}
	}
}

// ClearAlertsReceived clears the "alerts_received" edge to the OncallAlertInstance entity.
func (m *UserMutation) ClearAlertsReceived() {
	m.clearedalerts_received = true
}

// AlertsReceivedCleared reports if the "alerts_received" edge to the OncallAlertInstance entity was cleared.
func (m *UserMutation) AlertsReceivedCleared() bool {
	return m.clearedalerts_received
}

// RemoveAlertsReceivedIDs removes the "alerts_received" edge to the OncallAlertInstance entity by IDs.
func (m *UserMutation) RemoveAlertsReceivedIDs(ids ...uuid.UUID) {
	if m.removedalerts_received == nil {
		m.removedalerts_received = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.alerts_received, ids[i])
		m.removedalerts_received[ids[i]] = struct{}{}
	}
}

// RemovedAlertsReceived returns the removed IDs of the "alerts_received" edge to the OncallAlertInstance entity.
func (m *UserMutation) RemovedAlertsReceivedIDs() (ids []uuid.UUID) {
	for id := range m.removedalerts_received {
		ids = append(ids, id)
	}
	return
}

// AlertsReceivedIDs returns the "alerts_received" edge IDs in the mutation.
func (m *UserMutation) AlertsReceivedIDs() (ids []uuid.UUID) {
	for id := range m.alerts_received {
		ids = append(ids, id)
	}
	return
}

// ResetAlertsReceived resets all changes to the "alerts_received" edge.
func (m *UserMutation) ResetAlertsReceived() {
	m.alerts_received = nil
	m.clearedalerts_received = false
	m.removedalerts_received = nil
}

// AddIncidentRoleAssignmentIDs adds the "incident_role_assignments" edge to the IncidentRoleAssignment entity by ids.
func (m *UserMutation) AddIncidentRoleAssignmentIDs(ids ...uuid.UUID) {
	if m.incident_role_assignments == nil {
		m.incident_role_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_role_assignments[ids[i]] = struct{}{}
	}
}

// ClearIncidentRoleAssignments clears the "incident_role_assignments" edge to the IncidentRoleAssignment entity.
func (m *UserMutation) ClearIncidentRoleAssignments() {
	m.clearedincident_role_assignments = true
}

// IncidentRoleAssignmentsCleared reports if the "incident_role_assignments" edge to the IncidentRoleAssignment entity was cleared.
func (m *UserMutation) IncidentRoleAssignmentsCleared() bool {
	return m.clearedincident_role_assignments
}

// RemoveIncidentRoleAssignmentIDs removes the "incident_role_assignments" edge to the IncidentRoleAssignment entity by IDs.
func (m *UserMutation) RemoveIncidentRoleAssignmentIDs(ids ...uuid.UUID) {
	if m.removedincident_role_assignments == nil {
		m.removedincident_role_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_role_assignments, ids[i])
		m.removedincident_role_assignments[ids[i]] = struct{}{}
	}
}

// RemovedIncidentRoleAssignments returns the removed IDs of the "incident_role_assignments" edge to the IncidentRoleAssignment entity.
func (m *UserMutation) RemovedIncidentRoleAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_role_assignments {
		ids = append(ids, id)
	}
	return
}

// IncidentRoleAssignmentsIDs returns the "incident_role_assignments" edge IDs in the mutation.
func (m *UserMutation) IncidentRoleAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.incident_role_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentRoleAssignments resets all changes to the "incident_role_assignments" edge.
func (m *UserMutation) ResetIncidentRoleAssignments() {
	m.incident_role_assignments = nil
	m.clearedincident_role_assignments = false
	m.removedincident_role_assignments = nil
}

// AddIncidentDebriefIDs adds the "incident_debriefs" edge to the IncidentDebrief entity by ids.
func (m *UserMutation) AddIncidentDebriefIDs(ids ...uuid.UUID) {
	if m.incident_debriefs == nil {
		m.incident_debriefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_debriefs[ids[i]] = struct{}{}
	}
}

// ClearIncidentDebriefs clears the "incident_debriefs" edge to the IncidentDebrief entity.
func (m *UserMutation) ClearIncidentDebriefs() {
	m.clearedincident_debriefs = true
}

// IncidentDebriefsCleared reports if the "incident_debriefs" edge to the IncidentDebrief entity was cleared.
func (m *UserMutation) IncidentDebriefsCleared() bool {
	return m.clearedincident_debriefs
}

// RemoveIncidentDebriefIDs removes the "incident_debriefs" edge to the IncidentDebrief entity by IDs.
func (m *UserMutation) RemoveIncidentDebriefIDs(ids ...uuid.UUID) {
	if m.removedincident_debriefs == nil {
		m.removedincident_debriefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_debriefs, ids[i])
		m.removedincident_debriefs[ids[i]] = struct{}{}
	}
}

// RemovedIncidentDebriefs returns the removed IDs of the "incident_debriefs" edge to the IncidentDebrief entity.
func (m *UserMutation) RemovedIncidentDebriefsIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_debriefs {
		ids = append(ids, id)
	}
	return
}

// IncidentDebriefsIDs returns the "incident_debriefs" edge IDs in the mutation.
func (m *UserMutation) IncidentDebriefsIDs() (ids []uuid.UUID) {
	for id := range m.incident_debriefs {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentDebriefs resets all changes to the "incident_debriefs" edge.
func (m *UserMutation) ResetIncidentDebriefs() {
	m.incident_debriefs = nil
	m.clearedincident_debriefs = false
	m.removedincident_debriefs = nil
}

// AddAssignedTaskIDs adds the "assigned_tasks" edge to the Task entity by ids.
func (m *UserMutation) AddAssignedTaskIDs(ids ...uuid.UUID) {
	if m.assigned_tasks == nil {
		m.assigned_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.assigned_tasks[ids[i]] = struct{}{}
	}
}

// ClearAssignedTasks clears the "assigned_tasks" edge to the Task entity.
func (m *UserMutation) ClearAssignedTasks() {
	m.clearedassigned_tasks = true
}

// AssignedTasksCleared reports if the "assigned_tasks" edge to the Task entity was cleared.
func (m *UserMutation) AssignedTasksCleared() bool {
	return m.clearedassigned_tasks
}

// RemoveAssignedTaskIDs removes the "assigned_tasks" edge to the Task entity by IDs.
func (m *UserMutation) RemoveAssignedTaskIDs(ids ...uuid.UUID) {
	if m.removedassigned_tasks == nil {
		m.removedassigned_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.assigned_tasks, ids[i])
		m.removedassigned_tasks[ids[i]] = struct{}{}
	}
}

// RemovedAssignedTasks returns the removed IDs of the "assigned_tasks" edge to the Task entity.
func (m *UserMutation) RemovedAssignedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedassigned_tasks {
		ids = append(ids, id)
	}
	return
}

// AssignedTasksIDs returns the "assigned_tasks" edge IDs in the mutation.
func (m *UserMutation) AssignedTasksIDs() (ids []uuid.UUID) {
	for id := range m.assigned_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedTasks resets all changes to the "assigned_tasks" edge.
func (m *UserMutation) ResetAssignedTasks() {
	m.assigned_tasks = nil
	m.clearedassigned_tasks = false
	m.removedassigned_tasks = nil
}

// AddCreatedTaskIDs adds the "created_tasks" edge to the Task entity by ids.
func (m *UserMutation) AddCreatedTaskIDs(ids ...uuid.UUID) {
	if m.created_tasks == nil {
		m.created_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_tasks[ids[i]] = struct{}{}
	}
}

// ClearCreatedTasks clears the "created_tasks" edge to the Task entity.
func (m *UserMutation) ClearCreatedTasks() {
	m.clearedcreated_tasks = true
}

// CreatedTasksCleared reports if the "created_tasks" edge to the Task entity was cleared.
func (m *UserMutation) CreatedTasksCleared() bool {
	return m.clearedcreated_tasks
}

// RemoveCreatedTaskIDs removes the "created_tasks" edge to the Task entity by IDs.
func (m *UserMutation) RemoveCreatedTaskIDs(ids ...uuid.UUID) {
	if m.removedcreated_tasks == nil {
		m.removedcreated_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_tasks, ids[i])
		m.removedcreated_tasks[ids[i]] = struct{}{}
	}
}

// RemovedCreatedTasks returns the removed IDs of the "created_tasks" edge to the Task entity.
func (m *UserMutation) RemovedCreatedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_tasks {
		ids = append(ids, id)
	}
	return
}

// CreatedTasksIDs returns the "created_tasks" edge IDs in the mutation.
func (m *UserMutation) CreatedTasksIDs() (ids []uuid.UUID) {
	for id := range m.created_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedTasks resets all changes to the "created_tasks" edge.
func (m *UserMutation) ResetCreatedTasks() {
	m.created_tasks = nil
	m.clearedcreated_tasks = false
	m.removedcreated_tasks = nil
}

// AddRetrospectiveReviewRequestIDs adds the "retrospective_review_requests" edge to the RetrospectiveReview entity by ids.
func (m *UserMutation) AddRetrospectiveReviewRequestIDs(ids ...uuid.UUID) {
	if m.retrospective_review_requests == nil {
		m.retrospective_review_requests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.retrospective_review_requests[ids[i]] = struct{}{}
	}
}

// ClearRetrospectiveReviewRequests clears the "retrospective_review_requests" edge to the RetrospectiveReview entity.
func (m *UserMutation) ClearRetrospectiveReviewRequests() {
	m.clearedretrospective_review_requests = true
}

// RetrospectiveReviewRequestsCleared reports if the "retrospective_review_requests" edge to the RetrospectiveReview entity was cleared.
func (m *UserMutation) RetrospectiveReviewRequestsCleared() bool {
	return m.clearedretrospective_review_requests
}

// RemoveRetrospectiveReviewRequestIDs removes the "retrospective_review_requests" edge to the RetrospectiveReview entity by IDs.
func (m *UserMutation) RemoveRetrospectiveReviewRequestIDs(ids ...uuid.UUID) {
	if m.removedretrospective_review_requests == nil {
		m.removedretrospective_review_requests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.retrospective_review_requests, ids[i])
		m.removedretrospective_review_requests[ids[i]] = struct{}{}
	}
}

// RemovedRetrospectiveReviewRequests returns the removed IDs of the "retrospective_review_requests" edge to the RetrospectiveReview entity.
func (m *UserMutation) RemovedRetrospectiveReviewRequestsIDs() (ids []uuid.UUID) {
	for id := range m.removedretrospective_review_requests {
		ids = append(ids, id)
	}
	return
}

// RetrospectiveReviewRequestsIDs returns the "retrospective_review_requests" edge IDs in the mutation.
func (m *UserMutation) RetrospectiveReviewRequestsIDs() (ids []uuid.UUID) {
	for id := range m.retrospective_review_requests {
		ids = append(ids, id)
	}
	return
}

// ResetRetrospectiveReviewRequests resets all changes to the "retrospective_review_requests" edge.
func (m *UserMutation) ResetRetrospectiveReviewRequests() {
	m.retrospective_review_requests = nil
	m.clearedretrospective_review_requests = false
	m.removedretrospective_review_requests = nil
}

// AddRetrospectiveReviewResponseIDs adds the "retrospective_review_responses" edge to the RetrospectiveReview entity by ids.
func (m *UserMutation) AddRetrospectiveReviewResponseIDs(ids ...uuid.UUID) {
	if m.retrospective_review_responses == nil {
		m.retrospective_review_responses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.retrospective_review_responses[ids[i]] = struct{}{}
	}
}

// ClearRetrospectiveReviewResponses clears the "retrospective_review_responses" edge to the RetrospectiveReview entity.
func (m *UserMutation) ClearRetrospectiveReviewResponses() {
	m.clearedretrospective_review_responses = true
}

// RetrospectiveReviewResponsesCleared reports if the "retrospective_review_responses" edge to the RetrospectiveReview entity was cleared.
func (m *UserMutation) RetrospectiveReviewResponsesCleared() bool {
	return m.clearedretrospective_review_responses
}

// RemoveRetrospectiveReviewResponseIDs removes the "retrospective_review_responses" edge to the RetrospectiveReview entity by IDs.
func (m *UserMutation) RemoveRetrospectiveReviewResponseIDs(ids ...uuid.UUID) {
	if m.removedretrospective_review_responses == nil {
		m.removedretrospective_review_responses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.retrospective_review_responses, ids[i])
		m.removedretrospective_review_responses[ids[i]] = struct{}{}
	}
}

// RemovedRetrospectiveReviewResponses returns the removed IDs of the "retrospective_review_responses" edge to the RetrospectiveReview entity.
func (m *UserMutation) RemovedRetrospectiveReviewResponsesIDs() (ids []uuid.UUID) {
	for id := range m.removedretrospective_review_responses {
		ids = append(ids, id)
	}
	return
}

// RetrospectiveReviewResponsesIDs returns the "retrospective_review_responses" edge IDs in the mutation.
func (m *UserMutation) RetrospectiveReviewResponsesIDs() (ids []uuid.UUID) {
	for id := range m.retrospective_review_responses {
		ids = append(ids, id)
	}
	return
}

// ResetRetrospectiveReviewResponses resets all changes to the "retrospective_review_responses" edge.
func (m *UserMutation) ResetRetrospectiveReviewResponses() {
	m.retrospective_review_responses = nil
	m.clearedretrospective_review_responses = false
	m.removedretrospective_review_responses = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.chat_id != nil {
		fields = append(fields, user.FieldChatID)
	}
	if m.timezone != nil {
		fields = append(fields, user.FieldTimezone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldChatID:
		return m.ChatID()
	case user.FieldTimezone:
		return m.Timezone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldChatID:
		return m.OldChatID(ctx)
	case user.FieldTimezone:
		return m.OldTimezone(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldChatID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatID(v)
		return nil
	case user.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldChatID) {
		fields = append(fields, user.FieldChatID)
	}
	if m.FieldCleared(user.FieldTimezone) {
		fields = append(fields, user.FieldTimezone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldChatID:
		m.ClearChatID()
		return nil
	case user.FieldTimezone:
		m.ClearTimezone()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldChatID:
		m.ResetChatID()
		return nil
	case user.FieldTimezone:
		m.ResetTimezone()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.teams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	if m.oncall_schedules != nil {
		edges = append(edges, user.EdgeOncallSchedules)
	}
	if m.oncall_shifts != nil {
		edges = append(edges, user.EdgeOncallShifts)
	}
	if m.oncall_shift_covers != nil {
		edges = append(edges, user.EdgeOncallShiftCovers)
	}
	if m.alerts_received != nil {
		edges = append(edges, user.EdgeAlertsReceived)
	}
	if m.incident_role_assignments != nil {
		edges = append(edges, user.EdgeIncidentRoleAssignments)
	}
	if m.incident_debriefs != nil {
		edges = append(edges, user.EdgeIncidentDebriefs)
	}
	if m.assigned_tasks != nil {
		edges = append(edges, user.EdgeAssignedTasks)
	}
	if m.created_tasks != nil {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.retrospective_review_requests != nil {
		edges = append(edges, user.EdgeRetrospectiveReviewRequests)
	}
	if m.retrospective_review_responses != nil {
		edges = append(edges, user.EdgeRetrospectiveReviewResponses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOncallSchedules:
		ids := make([]ent.Value, 0, len(m.oncall_schedules))
		for id := range m.oncall_schedules {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOncallShifts:
		ids := make([]ent.Value, 0, len(m.oncall_shifts))
		for id := range m.oncall_shifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOncallShiftCovers:
		ids := make([]ent.Value, 0, len(m.oncall_shift_covers))
		for id := range m.oncall_shift_covers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAlertsReceived:
		ids := make([]ent.Value, 0, len(m.alerts_received))
		for id := range m.alerts_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncidentRoleAssignments:
		ids := make([]ent.Value, 0, len(m.incident_role_assignments))
		for id := range m.incident_role_assignments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncidentDebriefs:
		ids := make([]ent.Value, 0, len(m.incident_debriefs))
		for id := range m.incident_debriefs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedTasks:
		ids := make([]ent.Value, 0, len(m.assigned_tasks))
		for id := range m.assigned_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTasks:
		ids := make([]ent.Value, 0, len(m.created_tasks))
		for id := range m.created_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRetrospectiveReviewRequests:
		ids := make([]ent.Value, 0, len(m.retrospective_review_requests))
		for id := range m.retrospective_review_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRetrospectiveReviewResponses:
		ids := make([]ent.Value, 0, len(m.retrospective_review_responses))
		for id := range m.retrospective_review_responses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedteams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	if m.removedoncall_schedules != nil {
		edges = append(edges, user.EdgeOncallSchedules)
	}
	if m.removedoncall_shifts != nil {
		edges = append(edges, user.EdgeOncallShifts)
	}
	if m.removedoncall_shift_covers != nil {
		edges = append(edges, user.EdgeOncallShiftCovers)
	}
	if m.removedalerts_received != nil {
		edges = append(edges, user.EdgeAlertsReceived)
	}
	if m.removedincident_role_assignments != nil {
		edges = append(edges, user.EdgeIncidentRoleAssignments)
	}
	if m.removedincident_debriefs != nil {
		edges = append(edges, user.EdgeIncidentDebriefs)
	}
	if m.removedassigned_tasks != nil {
		edges = append(edges, user.EdgeAssignedTasks)
	}
	if m.removedcreated_tasks != nil {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.removedretrospective_review_requests != nil {
		edges = append(edges, user.EdgeRetrospectiveReviewRequests)
	}
	if m.removedretrospective_review_responses != nil {
		edges = append(edges, user.EdgeRetrospectiveReviewResponses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOncallSchedules:
		ids := make([]ent.Value, 0, len(m.removedoncall_schedules))
		for id := range m.removedoncall_schedules {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOncallShifts:
		ids := make([]ent.Value, 0, len(m.removedoncall_shifts))
		for id := range m.removedoncall_shifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOncallShiftCovers:
		ids := make([]ent.Value, 0, len(m.removedoncall_shift_covers))
		for id := range m.removedoncall_shift_covers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAlertsReceived:
		ids := make([]ent.Value, 0, len(m.removedalerts_received))
		for id := range m.removedalerts_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncidentRoleAssignments:
		ids := make([]ent.Value, 0, len(m.removedincident_role_assignments))
		for id := range m.removedincident_role_assignments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncidentDebriefs:
		ids := make([]ent.Value, 0, len(m.removedincident_debriefs))
		for id := range m.removedincident_debriefs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedTasks:
		ids := make([]ent.Value, 0, len(m.removedassigned_tasks))
		for id := range m.removedassigned_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTasks:
		ids := make([]ent.Value, 0, len(m.removedcreated_tasks))
		for id := range m.removedcreated_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRetrospectiveReviewRequests:
		ids := make([]ent.Value, 0, len(m.removedretrospective_review_requests))
		for id := range m.removedretrospective_review_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRetrospectiveReviewResponses:
		ids := make([]ent.Value, 0, len(m.removedretrospective_review_responses))
		for id := range m.removedretrospective_review_responses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedteams {
		edges = append(edges, user.EdgeTeams)
	}
	if m.clearedoncall_schedules {
		edges = append(edges, user.EdgeOncallSchedules)
	}
	if m.clearedoncall_shifts {
		edges = append(edges, user.EdgeOncallShifts)
	}
	if m.clearedoncall_shift_covers {
		edges = append(edges, user.EdgeOncallShiftCovers)
	}
	if m.clearedalerts_received {
		edges = append(edges, user.EdgeAlertsReceived)
	}
	if m.clearedincident_role_assignments {
		edges = append(edges, user.EdgeIncidentRoleAssignments)
	}
	if m.clearedincident_debriefs {
		edges = append(edges, user.EdgeIncidentDebriefs)
	}
	if m.clearedassigned_tasks {
		edges = append(edges, user.EdgeAssignedTasks)
	}
	if m.clearedcreated_tasks {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.clearedretrospective_review_requests {
		edges = append(edges, user.EdgeRetrospectiveReviewRequests)
	}
	if m.clearedretrospective_review_responses {
		edges = append(edges, user.EdgeRetrospectiveReviewResponses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTeams:
		return m.clearedteams
	case user.EdgeOncallSchedules:
		return m.clearedoncall_schedules
	case user.EdgeOncallShifts:
		return m.clearedoncall_shifts
	case user.EdgeOncallShiftCovers:
		return m.clearedoncall_shift_covers
	case user.EdgeAlertsReceived:
		return m.clearedalerts_received
	case user.EdgeIncidentRoleAssignments:
		return m.clearedincident_role_assignments
	case user.EdgeIncidentDebriefs:
		return m.clearedincident_debriefs
	case user.EdgeAssignedTasks:
		return m.clearedassigned_tasks
	case user.EdgeCreatedTasks:
		return m.clearedcreated_tasks
	case user.EdgeRetrospectiveReviewRequests:
		return m.clearedretrospective_review_requests
	case user.EdgeRetrospectiveReviewResponses:
		return m.clearedretrospective_review_responses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTeams:
		m.ResetTeams()
		return nil
	case user.EdgeOncallSchedules:
		m.ResetOncallSchedules()
		return nil
	case user.EdgeOncallShifts:
		m.ResetOncallShifts()
		return nil
	case user.EdgeOncallShiftCovers:
		m.ResetOncallShiftCovers()
		return nil
	case user.EdgeAlertsReceived:
		m.ResetAlertsReceived()
		return nil
	case user.EdgeIncidentRoleAssignments:
		m.ResetIncidentRoleAssignments()
		return nil
	case user.EdgeIncidentDebriefs:
		m.ResetIncidentDebriefs()
		return nil
	case user.EdgeAssignedTasks:
		m.ResetAssignedTasks()
		return nil
	case user.EdgeCreatedTasks:
		m.ResetCreatedTasks()
		return nil
	case user.EdgeRetrospectiveReviewRequests:
		m.ResetRetrospectiveReviewRequests()
		return nil
	case user.EdgeRetrospectiveReviewResponses:
		m.ResetRetrospectiveReviewResponses()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
